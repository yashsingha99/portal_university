{"version":3,"file":"index.mjs","sources":["../src/parse-multipart.ts","../src/parse-type.ts","../src/policy.ts","../src/template-configuration.ts","../src/format-yup-error.ts","../src/errors.ts","../src/validators.ts","../src/string-formatting.ts","../src/print-value.ts","../src/yup.ts","../src/object-formatting.ts","../src/config.ts","../src/code-generator.ts","../src/content-types.ts","../src/env-helper.ts","../src/relations.ts","../src/set-creator-fields.ts","../src/hooks.ts","../src/provider-factory.ts","../src/pagination.ts","../src/async.ts","../src/sanitize/visitors/remove-password.ts","../src/sanitize/visitors/remove-private.ts","../src/sanitize/visitors/remove-restricted-relations.ts","../src/sanitize/visitors/remove-morph-to-relations.ts","../src/sanitize/visitors/remove-dynamic-zones.ts","../src/sanitize/visitors/remove-disallowed-fields.ts","../src/sanitize/visitors/remove-restricted-fields.ts","../src/traverse-entity.ts","../src/traverse/factory.ts","../src/traverse/query-filters.ts","../src/traverse/query-sort.ts","../src/traverse/query-populate.ts","../src/traverse/query-fields.ts","../src/operators.ts","../src/sanitize/sanitizers.ts","../src/sanitize/index.ts","../src/validate/utils.ts","../src/validate/visitors/throw-password.ts","../src/validate/visitors/throw-private.ts","../src/validate/visitors/throw-restricted-relations.ts","../src/validate/visitors/throw-morph-to-relations.ts","../src/validate/visitors/throw-dynamic-zones.ts","../src/validate/visitors/throw-disallowed-fields.ts","../src/validate/visitors/throw-restricted-fields.ts","../src/validate/validators.ts","../src/validate/index.ts","../src/convert-query-params.ts","../src/import-default.ts","../src/template.ts","../src/file.ts","../src/webhook.ts"],"sourcesContent":["import _ from 'lodash';\nimport type Koa from 'koa';\n\nexport const parseMultipartData = (ctx: Koa.Context) => {\n  if (!ctx.is('multipart')) {\n    return { data: ctx.request.body, files: {} };\n  }\n\n  const { body = {}, files = {} } = ctx.request;\n\n  if (!body.data) {\n    return ctx.badRequest(\n      `When using multipart/form-data you need to provide your data in a JSON 'data' field.`\n    );\n  }\n\n  let data;\n  try {\n    data = JSON.parse(body.data);\n  } catch (error) {\n    return ctx.badRequest(`Invalid 'data' field. 'data' should be a valid JSON.`);\n  }\n\n  const filesToUpload = Object.keys(files).reduce((acc, key) => {\n    const fullPath = _.toPath(key);\n\n    if (fullPath.length <= 1 || fullPath[0] !== 'files') {\n      return ctx.badRequest(\n        `When using multipart/form-data you need to provide your files by prefixing them with the 'files'.\nFor example, when a media file is named \"avatar\", make sure the form key name is \"files.avatar\"`\n      );\n    }\n\n    const path = _.tail(fullPath);\n    acc[path.join('.')] = files[key];\n    return acc;\n  }, {} as NonNullable<Koa.Request['files']>);\n\n  return {\n    data,\n    files: filesToUpload,\n  };\n};\n","import _ = require('lodash');\nimport dates = require('date-fns');\n\nconst timeRegex = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\n\nconst isDate = (v: unknown): v is Date => {\n  return dates.isDate(v);\n};\n\nconst parseTime = (value: unknown): string => {\n  if (isDate(value)) {\n    return dates.format(value, 'HH:mm:ss.SSS');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n  const result = value.match(timeRegex);\n\n  if (result === null) {\n    throw new Error('Invalid time format, expected HH:mm:ss.SSS');\n  }\n\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\n  const fractionPart = _.padEnd(fraction.slice(1), 3, '0');\n\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\n};\n\nconst parseDate = (value: unknown) => {\n  if (isDate(value)) {\n    return dates.format(value, 'yyyy-MM-dd');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n\n    if (dates.isValid(date)) return dates.format(date, 'yyyy-MM-dd');\n\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  }\n};\n\nconst parseDateTimeOrTimestamp = (value: unknown) => {\n  if (isDate(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n    if (dates.isValid(date)) return date;\n\n    const milliUnixDate = dates.parse(value, 'T', new Date());\n    if (dates.isValid(milliUnixDate)) return milliUnixDate;\n\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  }\n};\n\ntype TypeMap = {\n  boolean: boolean;\n  integer: number;\n  biginteger: number;\n  float: number;\n  decimal: number;\n  time: string;\n  date: string;\n  timestamp: Date;\n  datetime: Date;\n};\n\nexport interface ParseTypeOptions<T extends keyof TypeMap> {\n  type: T;\n  value: unknown;\n  forceCast?: boolean;\n}\n\nconst parseBoolean = (value: unknown, options: { forceCast?: boolean }): boolean => {\n  const { forceCast = false } = options;\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    if (['true', 't', '1', 1].includes(value)) {\n      return true;\n    }\n\n    if (['false', 'f', '0', 0].includes(value)) {\n      return false;\n    }\n  }\n\n  if (forceCast) {\n    return Boolean(value);\n  }\n\n  throw new Error('Invalid boolean input. Expected \"t\",\"1\",\"true\",\"false\",\"0\",\"f\"');\n};\n\n/**\n * Cast basic values based on attribute type\n */\nconst parseType = <Type extends keyof TypeMap>(options: ParseTypeOptions<Type>): TypeMap[Type] => {\n  const { type, value, forceCast } = options;\n\n  switch (type) {\n    case 'boolean':\n      return parseBoolean(value, { forceCast }) as TypeMap[Type];\n    case 'integer':\n    case 'biginteger':\n    case 'float':\n    case 'decimal': {\n      return _.toNumber(value) as TypeMap[Type];\n    }\n    case 'time': {\n      return parseTime(value) as TypeMap[Type];\n    }\n    case 'date': {\n      return parseDate(value) as TypeMap[Type];\n    }\n    case 'timestamp':\n    case 'datetime': {\n      return parseDateTimeOrTimestamp(value) as TypeMap[Type];\n    }\n    default:\n      return value as TypeMap[Type];\n  }\n};\n\nexport default parseType;\n","/**\n * Policies util\n */\n\nimport _ from 'lodash';\nimport { eq } from 'lodash/fp';\nimport type Koa from 'koa';\n\nconst PLUGIN_PREFIX = 'plugin::';\nconst API_PREFIX = 'api::';\n\ninterface PolicyInfo {\n  name: string;\n  config: unknown;\n}\n\ntype PolicyConfig = string | PolicyInfo | (() => PolicyInfo);\n\ninterface PolicyContext {\n  pluginName?: string;\n  apiName?: string;\n}\n\ninterface RouteInfo {\n  method: string;\n  endpoint: string;\n  controller: string;\n  action: string;\n  plugin: string;\n}\n\nconst parsePolicy = (policy: string | PolicyInfo) => {\n  if (typeof policy === 'string') {\n    return { policyName: policy, config: {} };\n  }\n\n  const { name, config } = policy;\n  return { policyName: name, config };\n};\n\nconst searchLocalPolicy = (policyName: string, policyContext: PolicyContext) => {\n  const { pluginName, apiName } = policyContext ?? {};\n\n  if (pluginName) {\n    return strapi.policy(`${PLUGIN_PREFIX}${pluginName}.${policyName}`);\n  }\n\n  if (apiName) {\n    return strapi.policy(`${API_PREFIX}${apiName}.${policyName}`);\n  }\n};\n\nconst globalPolicy = ({ method, endpoint, controller, action, plugin }: RouteInfo) => {\n  return async (ctx: Koa.Context, next: () => void) => {\n    ctx.request.route = {\n      endpoint: `${method} ${endpoint}`,\n      controller: _.toLower(controller),\n      action: _.toLower(action),\n      verb: _.toLower(method),\n      plugin,\n    };\n\n    await next();\n  };\n};\n\nconst resolvePolicies = (config: PolicyConfig[], policyContext: PolicyContext) => {\n  const { pluginName, apiName } = policyContext ?? {};\n\n  return config.map((policyConfig) => {\n    return {\n      handler: getPolicy(policyConfig, { pluginName, apiName }),\n      config: (typeof policyConfig === 'object' && policyConfig.config) || {},\n    };\n  });\n};\n\nconst findPolicy = (name: string, policyContext: PolicyContext) => {\n  const { pluginName, apiName } = policyContext ?? {};\n  const resolvedPolicy = strapi.policy(name);\n\n  if (resolvedPolicy !== undefined) {\n    return resolvedPolicy;\n  }\n\n  const localPolicy = searchLocalPolicy(name, { pluginName, apiName });\n\n  if (localPolicy !== undefined) {\n    return localPolicy;\n  }\n\n  throw new Error(`Could not find policy \"${name}\"`);\n};\n\nconst getPolicy = (policyConfig: PolicyConfig, policyContext?: PolicyContext) => {\n  const { pluginName, apiName } = policyContext ?? {};\n\n  if (typeof policyConfig === 'function') {\n    return policyConfig;\n  }\n\n  const { policyName, config } = parsePolicy(policyConfig);\n\n  const policy = findPolicy(policyName, { pluginName, apiName });\n\n  if (typeof policy === 'function') {\n    return policy;\n  }\n\n  if (policy.validator) {\n    policy.validator(config);\n  }\n\n  return policy.handler;\n};\n\ninterface Options {\n  name: string;\n  validator?(config: unknown): void;\n  handler(...args: any[]): any;\n}\n\nconst createPolicy = (options: Options) => {\n  const { name = 'unnamed', validator, handler } = options;\n\n  const wrappedValidator = (config: unknown) => {\n    if (validator) {\n      try {\n        validator(config);\n      } catch (e) {\n        throw new Error(`Invalid config passed to \"${name}\" policy.`);\n      }\n    }\n  };\n\n  return {\n    name,\n    validator: wrappedValidator,\n    handler,\n  };\n};\n\nconst createPolicyContext = (type: string, ctx: object) => {\n  return Object.assign(\n    {\n      is: eq(type),\n      get type() {\n        return type;\n      },\n    },\n    ctx\n  );\n};\n\nexport {\n  getPolicy as get,\n  resolvePolicies as resolve,\n  globalPolicy,\n  createPolicy,\n  createPolicyContext,\n};\n","import { isString, isPlainObject } from 'lodash';\n\nconst regex = /\\$\\{[^()]*\\}/g;\nconst excludeConfigPaths = ['info.scripts'];\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isPlainObject(value);\n\n/**\n * Allow dynamic config values through the native ES6 template string function.\n */\nconst templateConfiguration = (obj: Record<string, unknown>, configPath = '') => {\n  // Allow values which looks like such as an ES6 literal string without parenthesis inside (aka function call).\n  // Exclude config with conflicting syntax (e.g. npm scripts).\n  return Object.keys(obj).reduce((acc, key) => {\n    const value = obj[key];\n\n    if (isObj(value) && !isString(value)) {\n      acc[key] = templateConfiguration(value, `${configPath}.${key}`);\n    } else if (\n      isString(value) &&\n      !excludeConfigPaths.includes(configPath.substr(1)) &&\n      value.match(regex) !== null\n    ) {\n      // eslint-disable-next-line prefer-template, no-eval\n      acc[key] = eval('`' + value + '`');\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {} as Record<string, unknown>);\n};\n\nexport { templateConfiguration };\n","import { isEmpty, toPath } from 'lodash/fp';\nimport { ValidationError } from 'yup';\n\nconst formatYupInnerError = (yupError: ValidationError) => ({\n  path: toPath(yupError.path),\n  message: yupError.message,\n  name: yupError.name,\n});\n\nconst formatYupErrors = (yupError: ValidationError) => ({\n  errors: isEmpty(yupError.inner)\n    ? [formatYupInnerError(yupError)]\n    : yupError.inner.map(formatYupInnerError),\n  message: yupError.message,\n});\n\nexport { formatYupErrors };\n","/* eslint-disable max-classes-per-file */\n\nimport yup from 'yup';\nimport { HttpError } from 'http-errors';\nimport { formatYupErrors } from './format-yup-error';\n\n/* ApplicationError */\nclass ApplicationError<\n  TName extends string = 'ApplicationError',\n  TMessage extends string = string,\n  TDetails = unknown\n> extends Error {\n  name: TName;\n\n  details: TDetails;\n\n  message: TMessage;\n\n  constructor(\n    message = 'An application error occured' as TMessage,\n    details: TDetails = {} as TDetails\n  ) {\n    super();\n    this.name = 'ApplicationError' as TName;\n    this.message = message;\n    this.details = details;\n  }\n}\n\nclass ValidationError<\n  TMessage extends string = string,\n  TDetails = unknown\n> extends ApplicationError<'ValidationError', TMessage, TDetails> {\n  constructor(message: TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'ValidationError';\n  }\n}\n\ninterface YupFormattedError {\n  path: string[];\n  message: string;\n  name: string;\n}\n\nclass YupValidationError<TMessage extends string = string> extends ValidationError<\n  TMessage,\n  { errors: YupFormattedError[] }\n> {\n  constructor(yupError: yup.ValidationError, message?: TMessage) {\n    super('Validation' as TMessage);\n    const { errors, message: yupMessage } = formatYupErrors(yupError);\n    this.message = message || (yupMessage as TMessage);\n    this.details = { errors };\n  }\n}\n\nclass PaginationError<\n  TMessage extends string = string,\n  TDetails = unknown\n> extends ApplicationError<'PaginationError', TMessage, TDetails> {\n  constructor(message = 'Invalid pagination' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PaginationError';\n    this.message = message;\n  }\n}\n\nclass NotFoundError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\n  'NotFoundError',\n  TMessage,\n  TDetails\n> {\n  constructor(message = 'Entity not found' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'NotFoundError';\n    this.message = message;\n  }\n}\n\nclass ForbiddenError<\n  TName extends string = 'ForbiddenError',\n  TMessage extends string = string,\n  TDetails = unknown\n> extends ApplicationError<TName, TMessage, TDetails> {\n  constructor(message = 'Forbidden access' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'ForbiddenError' as TName;\n    this.message = message;\n  }\n}\n\nclass UnauthorizedError<\n  TMessage extends string = string,\n  TDetails = unknown\n> extends ApplicationError<'UnauthorizedError', TMessage, TDetails> {\n  constructor(message = 'Unauthorized' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'UnauthorizedError';\n    this.message = message;\n  }\n}\n\nclass RateLimitError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\n  'RateLimitError',\n  TMessage,\n  TDetails\n> {\n  constructor(\n    message = 'Too many requests, please try again later.' as TMessage,\n    details?: TDetails\n  ) {\n    super(message, details);\n    this.name = 'RateLimitError';\n    this.message = message;\n    this.details = details || ({} as TDetails);\n  }\n}\n\nclass PayloadTooLargeError<\n  TMessage extends string = string,\n  TDetails = unknown\n> extends ApplicationError<'PayloadTooLargeError', TMessage, TDetails> {\n  constructor(message = 'Entity too large' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PayloadTooLargeError';\n    this.message = message;\n  }\n}\n\nclass PolicyError<TMessage extends string = string, TDetails = unknown> extends ForbiddenError<\n  'PolicyError',\n  TMessage,\n  TDetails\n> {\n  constructor(message = 'Policy Failed' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PolicyError';\n    this.message = message;\n    this.details = details || ({} as TDetails);\n  }\n}\n\nclass NotImplementedError<\n  TMessage extends string = string,\n  TDetails = unknown\n> extends ApplicationError<'NotImplementedError', TMessage, TDetails> {\n  constructor(message = 'This feature is not implemented yet' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'NotImplementedError';\n    this.message = message;\n  }\n}\n\nexport {\n  HttpError,\n  ApplicationError,\n  ValidationError,\n  YupValidationError,\n  PaginationError,\n  NotFoundError,\n  ForbiddenError,\n  UnauthorizedError,\n  RateLimitError,\n  PayloadTooLargeError,\n  PolicyError,\n  NotImplementedError,\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable no-template-curly-in-string */\nimport * as yup from 'yup';\nimport { defaults } from 'lodash/fp';\nimport { YupValidationError } from './errors';\n\nconst handleYupError = (error: yup.ValidationError, errorMessage?: string) => {\n  throw new YupValidationError(error, errorMessage);\n};\n\nconst defaultValidationParam = { strict: true, abortEarly: false };\n\nconst validateYupSchema =\n  (schema: yup.AnySchema, options = {}) =>\n  async (body: unknown, errorMessage?: string) => {\n    try {\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\n      const result = await schema.validate(body, optionsWithDefaults);\n      return result;\n    } catch (e) {\n      if (e instanceof yup.ValidationError) {\n        handleYupError(e, errorMessage);\n      }\n\n      throw e;\n    }\n  };\n\nconst validateYupSchemaSync =\n  (schema: yup.AnySchema, options = {}) =>\n  (body: unknown, errorMessage?: string) => {\n    try {\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\n      return schema.validateSync(body, optionsWithDefaults);\n    } catch (e) {\n      if (e instanceof yup.ValidationError) {\n        handleYupError(e, errorMessage);\n      }\n\n      throw e;\n    }\n  };\n\nexport { handleYupError, validateYupSchema, validateYupSchemaSync };\n","import _, { kebabCase } from 'lodash';\nimport { trimChars, trimCharsEnd, trimCharsStart } from 'lodash/fp';\nimport slugify from '@sindresorhus/slugify';\n\nconst nameToSlug = (name: string, options: slugify.Options = { separator: '-' }) =>\n  slugify(name, options);\n\nconst nameToCollectionName = (name: string) => slugify(name, { separator: '_' });\n\nconst toRegressedEnumValue = (value: string) =>\n  slugify(value, {\n    decamelize: false,\n    lowercase: false,\n    separator: '_',\n  });\n\nconst getCommonBeginning = (...strings: string[]) =>\n  _.takeWhile(strings[0], (char, index) => strings.every((string) => string[index] === char)).join(\n    ''\n  );\n\nconst getCommonPath = (...paths: string[]) => {\n  const [segments, ...otherSegments] = paths.map((it) => _.split(it, '/'));\n  return _.join(\n    _.takeWhile(segments, (str, index) => otherSegments.every((it) => it[index] === str)),\n    '/'\n  );\n};\n\nconst escapeQuery = (query: string, charsToEscape: string, escapeChar = '\\\\') => {\n  return query\n    .split('')\n    .reduce(\n      (escapedQuery, char) =>\n        charsToEscape.includes(char)\n          ? `${escapedQuery}${escapeChar}${char}`\n          : `${escapedQuery}${char}`,\n      ''\n    );\n};\n\nconst stringIncludes = (arr: unknown[], val: unknown) => arr.map(String).includes(String(val));\nconst stringEquals = (a: unknown, b: unknown) => String(a) === String(b);\nconst isCamelCase = (value: string) => /^[a-z][a-zA-Z0-9]+$/.test(value);\nconst isKebabCase = (value: string) => /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/.test(value);\nconst startsWithANumber = (value: string) => /^[0-9]/.test(value);\n\nconst joinBy = (joint: string, ...args: string[]) => {\n  const trim = trimChars(joint);\n  const trimEnd = trimCharsEnd(joint);\n  const trimStart = trimCharsStart(joint);\n\n  return args.reduce((url, path, index) => {\n    if (args.length === 1) return path;\n    if (index === 0) return trimEnd(path);\n    if (index === args.length - 1) return url + joint + trimStart(path);\n    return url + joint + trim(path);\n  }, '');\n};\n\nconst toKebabCase = (value: string) => kebabCase(value);\n\nexport {\n  nameToSlug,\n  nameToCollectionName,\n  getCommonBeginning,\n  getCommonPath,\n  escapeQuery,\n  stringIncludes,\n  stringEquals,\n  isCamelCase,\n  isKebabCase,\n  toKebabCase,\n  toRegressedEnumValue,\n  startsWithANumber,\n  joinBy,\n};\n","// Code copied from the yup library (https://github.com/jquense/yup)\n// https://github.com/jquense/yup/blob/2778b88bdacd5260d593c6468793da2e77daf21f/src/util/printValue.ts\n\nconst { toString } = Object.prototype;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\n\nfunction printNumber(val: number) {\n  // eslint-disable-next-line eqeqeq\n  if (val != +val) return 'NaN';\n  const isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? '-0' : `${val}`;\n}\n\nfunction printSimpleValue(val: unknown, quoteStrings = false) {\n  if (val == null || val === true || val === false) return `${val}`;\n\n  if (typeof val === 'number') return printNumber(val);\n  if (typeof val === 'string') return quoteStrings ? `\"${val}\"` : val;\n  if (typeof val === 'function') return `[Function ${val.name || 'anonymous'}]`;\n  if (typeof val === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n\n  const tag = toString.call(val).slice(8, -1);\n\n  if (tag === 'Date') {\n    const v = val as Date;\n    return Number.isNaN(v.getTime()) ? `${v}` : v.toISOString();\n  }\n  if (tag === 'Error' || val instanceof Error) return `[${errorToString.call(val)}]`;\n  if (tag === 'RegExp') return regExpToString.call(val);\n\n  return null;\n}\n\nfunction printValue(value: unknown, quoteStrings: boolean) {\n  const result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n\n  return JSON.stringify(\n    value,\n    function replacer(key, value) {\n      const result = printSimpleValue(this[key], quoteStrings);\n      if (result !== null) return result;\n      return value;\n    },\n    2\n  );\n}\n\nexport { printValue };\n","/* eslint-disable no-template-curly-in-string */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport * as yup from 'yup';\nimport _ from 'lodash';\nimport { isNumber, isInteger, get } from 'lodash/fp';\nimport * as utils from './string-formatting';\nimport { printValue } from './print-value';\n\nexport * from 'yup';\n\n// @ts-ignore\nexport const strapiID = (): InstanceType<typeof StrapiIDSchema> => new StrapiIDSchema();\n\nconst isNotNilTest = (value: unknown) => !_.isNil(value);\n\nconst isNotNullTest = (value: unknown) => !_.isNull(value);\n\nyup.addMethod(yup.mixed, 'notNil', function isNotNill(msg = '${path} must be defined.') {\n  return this.test('defined', msg, isNotNilTest);\n});\n\nyup.addMethod(yup.mixed, 'notNull', function isNotNull(msg = '${path} cannot be null.') {\n  return this.test('defined', msg, isNotNullTest);\n});\n\nyup.addMethod(yup.mixed, 'isFunction', function isFunction(message = '${path} is not a function') {\n  return this.test(\n    'is a function',\n    message,\n    (value) => _.isUndefined(value) || _.isFunction(value)\n  );\n});\n\nyup.addMethod(\n  yup.string,\n  'isCamelCase',\n  function isCamelCase(message = '${path} is not in camel case (anExampleOfCamelCase)') {\n    return this.test('is in camelCase', message, (value) =>\n      value ? utils.isCamelCase(value) : true\n    );\n  }\n);\n\nyup.addMethod(\n  yup.string,\n  'isKebabCase',\n  function isKebabCase(message = '${path} is not in kebab case (an-example-of-kebab-case)') {\n    return this.test('is in kebab-case', message, (value) =>\n      value ? utils.isKebabCase(value) : true\n    );\n  }\n);\n\nyup.addMethod(\n  yup.object,\n  'onlyContainsFunctions',\n  function onlyContainsFunctions(message = '${path} contains values that are not functions') {\n    return this.test(\n      'only contains functions',\n      message,\n      (value) => _.isUndefined(value) || (value && Object.values(value).every(_.isFunction))\n    );\n  }\n);\n\nyup.addMethod(\n  yup.array,\n  'uniqueProperty',\n  function uniqueProperty(propertyName: string, message: string) {\n    return this.test('unique', message, function unique(list) {\n      const errors: yup.ValidationError[] = [];\n\n      list?.forEach((element, index) => {\n        const sameElements = list.filter(\n          (e) => get(propertyName, e) === get(propertyName, element)\n        );\n        if (sameElements.length > 1) {\n          errors.push(\n            this.createError({\n              path: `${this.path}[${index}].${propertyName}`,\n              message,\n            })\n          );\n        }\n      });\n\n      if (errors.length) {\n        throw new yup.ValidationError(errors);\n      }\n      return true;\n    });\n  }\n);\n\nexport class StrapiIDSchema extends yup.MixedSchema {\n  constructor() {\n    super({ type: 'strapiID' });\n  }\n\n  _typeCheck(value: unknown): value is string | number {\n    return typeof value === 'string' || (isNumber(value) && isInteger(value) && value >= 0);\n  }\n}\n\ndeclare module 'yup' {\n  const strapiID: () => InstanceType<typeof StrapiIDSchema>;\n\n  interface BaseSchema {\n    isFunction(message?: string): this;\n    notNil(message?: string): this;\n    notNull(message?: string): this;\n  }\n\n  interface StringSchema {\n    isCamelCase(message?: string): this;\n    isKebabCase(message?: string): this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface ObjectSchema<TShape> {\n    onlyContainsFunctions(message?: string): this;\n  }\n}\n\ninterface NoTypeOptions {\n  path: string;\n  type: string;\n  value: unknown;\n  originalValue: unknown;\n}\n\n// Temporary fix of this issue : https://github.com/jquense/yup/issues/616\nyup.setLocale({\n  mixed: {\n    notType(options: NoTypeOptions) {\n      const { path, type, value, originalValue } = options;\n      const isCast = originalValue != null && originalValue !== value;\n      const msg =\n        `${path} must be a \\`${type}\\` type, ` +\n        `but the final value was: \\`${printValue(value, true)}\\`${\n          isCast ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : '.'\n        }`;\n\n      /* Remove comment that is not supposed to be seen by the enduser\n      if (value === null) {\n        msg += `\\n If \"null\" is intended as an empty value be sure to mark the schema as \\`.nullable()\\``;\n      }\n      */\n      return msg;\n    },\n  },\n});\n","import _ from 'lodash';\n\nconst removeUndefined = <T extends object>(obj: T) =>\n  _.pickBy(obj, (value) => typeof value !== 'undefined');\n\nconst keysDeep = (obj: object, path: string[] = []): string[] =>\n  !_.isObject(obj)\n    ? [path.join('.')]\n    : _.reduce(\n        obj,\n        (acc, next, key) => _.concat(acc, keysDeep(next, [...path, key])),\n        [] as string[]\n      );\n\nexport { removeUndefined, keysDeep };\n","import _ from 'lodash';\nimport { getCommonPath } from './string-formatting';\nimport type { Config } from './types';\n\ninterface ServerConfig {\n  url: string;\n}\n\nexport const getConfigUrls = (config: Config, forAdminBuild = false) => {\n  const serverConfig = config.get<ServerConfig>('server');\n  const adminConfig = config.get('admin');\n\n  // Defines serverUrl value\n  let serverUrl = _.get(serverConfig, 'url', '');\n  serverUrl = _.trim(serverUrl, '/ ');\n  if (typeof serverUrl !== 'string') {\n    throw new Error('Invalid server url config. Make sure the url is a string.');\n  }\n  if (serverUrl.startsWith('http')) {\n    try {\n      serverUrl = _.trim(new URL(serverConfig.url).toString(), '/');\n    } catch (e) {\n      throw new Error(\n        'Invalid server url config. Make sure the url defined in server.js is valid.'\n      );\n    }\n  } else if (serverUrl !== '') {\n    serverUrl = `/${serverUrl}`;\n  }\n\n  // Defines adminUrl value\n  let adminUrl = _.get(adminConfig, 'url', '/admin');\n  adminUrl = _.trim(adminUrl, '/ ');\n  if (typeof adminUrl !== 'string') {\n    throw new Error('Invalid admin url config. Make sure the url is a non-empty string.');\n  }\n  if (adminUrl.startsWith('http')) {\n    try {\n      adminUrl = _.trim(new URL(adminUrl).toString(), '/');\n    } catch (e) {\n      throw new Error('Invalid admin url config. Make sure the url defined in server.js is valid.');\n    }\n  } else {\n    adminUrl = `${serverUrl}/${adminUrl}`;\n  }\n\n  // Defines adminPath value\n  let adminPath = adminUrl;\n  if (\n    serverUrl.startsWith('http') &&\n    adminUrl.startsWith('http') &&\n    new URL(adminUrl).origin === new URL(serverUrl).origin &&\n    !forAdminBuild\n  ) {\n    adminPath = adminUrl.replace(getCommonPath(serverUrl, adminUrl), '');\n    adminPath = `/${_.trim(adminPath, '/')}`;\n  } else if (adminUrl.startsWith('http')) {\n    adminPath = new URL(adminUrl).pathname;\n  }\n\n  return {\n    serverUrl,\n    adminUrl,\n    adminPath,\n  };\n};\n\nconst getAbsoluteUrl =\n  (adminOrServer: 'admin' | 'server') =>\n  (config: Config, forAdminBuild = false) => {\n    const { serverUrl, adminUrl } = getConfigUrls(config, forAdminBuild);\n    const url = adminOrServer === 'server' ? serverUrl : adminUrl;\n\n    if (url.startsWith('http')) {\n      return url;\n    }\n\n    const hostname =\n      config.get('environment') === 'development' &&\n      ['127.0.0.1', '0.0.0.0'].includes(config.get('server.host'))\n        ? 'localhost'\n        : config.get('server.host');\n\n    return `http://${hostname}:${config.get('server.port')}${url}`;\n  };\n\nexport const getAbsoluteAdminUrl = getAbsoluteUrl('admin');\nexport const getAbsoluteServerUrl = getAbsoluteUrl('server');\n","// Using timestamp (milliseconds) to be sure it is unique\n// + converting timestamp to base 36 for better readibility\nconst generateTimestampCode = (date: Date) => {\n  const referDate = date || new Date();\n\n  return referDate.getTime().toString(36);\n};\n\nexport { generateTimestampCode };\n","import _ from 'lodash';\nimport { has, getOr, union } from 'lodash/fp';\nimport type {\n  Model,\n  Kind,\n  Attribute,\n  RelationalAttribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  WithRequired,\n} from './types';\n\nconst SINGLE_TYPE = 'singleType';\nconst COLLECTION_TYPE = 'collectionType';\n\nconst ID_ATTRIBUTE = 'id';\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\n\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\n\nconst DP_PUB_STATE_LIVE = 'live';\nconst DP_PUB_STATE_PREVIEW = 'preview';\nconst DP_PUB_STATES = [DP_PUB_STATE_LIVE, DP_PUB_STATE_PREVIEW];\n\nconst constants = {\n  ID_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  DP_PUB_STATES,\n  DP_PUB_STATE_LIVE,\n  DP_PUB_STATE_PREVIEW,\n  SINGLE_TYPE,\n  COLLECTION_TYPE,\n};\n\nconst getTimestamps = (model: Model) => {\n  const attributes = [];\n\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_AT_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_AT_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getCreatorFields = (model: Model) => {\n  const attributes = [];\n\n  if (has(CREATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_BY_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_BY_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getNonWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  const nonWritableAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([ID_ATTRIBUTE, ...getTimestamps(model), ...nonWritableAttributes]);\n};\n\nconst getWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\n};\n\nconst isWritableAttribute = (model: Model, attributeName: string) => {\n  return getWritableAttributes(model).includes(attributeName);\n};\n\nconst getNonVisibleAttributes = (model: Model) => {\n  const nonVisibleAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([ID_ATTRIBUTE, ...getTimestamps(model), ...nonVisibleAttributes]);\n};\n\nconst getVisibleAttributes = (model: Model) => {\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\n};\n\nconst isVisibleAttribute = (model: Model, attributeName: string) => {\n  return getVisibleAttributes(model).includes(attributeName);\n};\n\nconst getOptions = (model: Model) =>\n  _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\n\nconst hasDraftAndPublish = (model: Model) =>\n  _.get(model, 'options.draftAndPublish', false) === true;\n\nconst isDraft = <T extends object>(data: T, model: Model) =>\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\n\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\nconst isKind = (kind: Kind) => (model: Model) => model.kind === kind;\n\nconst getStoredPrivateAttributes = (model: Model) =>\n  union(\n    (strapi?.config?.get('api.responses.privateAttributes', []) ?? []) as Array<string>,\n    getOr([], 'options.privateAttributes', model)\n  );\n\nconst getPrivateAttributes = (model: Model) => {\n  return _.union(\n    getStoredPrivateAttributes(model),\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\n  );\n};\n\nconst isPrivateAttribute = (model: Model, attributeName: string) => {\n  if (model?.attributes?.[attributeName]?.private === true) {\n    return true;\n  }\n  return getStoredPrivateAttributes(model).includes(attributeName);\n};\n\nconst isScalarAttribute = (attribute: Attribute) => {\n  return !['media', 'component', 'relation', 'dynamiczone'].includes(attribute?.type);\n};\nconst isMediaAttribute = (attribute: Attribute) => attribute?.type === 'media';\nconst isRelationalAttribute = (attribute: Attribute): attribute is RelationalAttribute =>\n  attribute?.type === 'relation';\n\nconst isComponentAttribute = (\n  attribute: Attribute\n): attribute is ComponentAttribute | DynamicZoneAttribute =>\n  ['component', 'dynamiczone'].includes(attribute?.type);\n\nconst isDynamicZoneAttribute = (attribute: Attribute): attribute is DynamicZoneAttribute =>\n  attribute?.type === 'dynamiczone';\nconst isMorphToRelationalAttribute = (attribute: Attribute) => {\n  return isRelationalAttribute(attribute) && attribute?.relation?.startsWith?.('morphTo');\n};\n\nconst getComponentAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isComponentAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getScalarAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isScalarAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\n/**\n * Checks if an attribute is of type `type`\n * @param {object} attribute\n * @param {string} type\n */\nconst isTypedAttribute = (attribute: Attribute, type: string) => {\n  return _.has(attribute, 'type') && attribute.type === type;\n};\n\n/**\n *  Returns a route prefix for a contentType\n * @param {object} contentType\n * @returns {string}\n */\nconst getContentTypeRoutePrefix = (contentType: WithRequired<Model, 'info'>) => {\n  return isSingleType(contentType)\n    ? _.kebabCase(contentType.info.singularName)\n    : _.kebabCase(contentType.info.pluralName);\n};\n\nexport {\n  isScalarAttribute,\n  isMediaAttribute,\n  isRelationalAttribute,\n  isComponentAttribute,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  isPrivateAttribute,\n  constants,\n  getNonWritableAttributes,\n  getComponentAttributes,\n  getScalarAttributes,\n  getWritableAttributes,\n  isWritableAttribute,\n  getNonVisibleAttributes,\n  getVisibleAttributes,\n  getTimestamps,\n  getCreatorFields,\n  isVisibleAttribute,\n  hasDraftAndPublish,\n  getOptions,\n  isDraft,\n  isSingleType,\n  isCollectionType,\n  isKind,\n  getContentTypeRoutePrefix,\n};\n","import _ from 'lodash';\n\nfunction envFn<T>(key: string, defaultValue?: T): string | T | undefined {\n  return _.has(process.env, key) ? process.env[key] : defaultValue;\n}\n\nfunction getKey(key: string) {\n  return process.env[key] ?? '';\n}\n\nconst utils = {\n  int(key: string, defaultValue?: number): number | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return parseInt(getKey(key), 10);\n  },\n\n  float(key: string, defaultValue?: number): number | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return parseFloat(getKey(key));\n  },\n\n  bool(key: string, defaultValue?: boolean): boolean | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return getKey(key) === 'true';\n  },\n\n  json(key: string, defaultValue?: object) {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    try {\n      return JSON.parse(getKey(key));\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Invalid json environment variable ${key}: ${error.message}`);\n      }\n\n      throw error;\n    }\n  },\n\n  array(key: string, defaultValue?: string[]): string[] | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    let value = getKey(key);\n\n    if (value.startsWith('[') && value.endsWith(']')) {\n      value = value.substring(1, value.length - 1);\n    }\n\n    return value.split(',').map((v) => {\n      return _.trim(_.trim(v, ' '), '\"');\n    });\n  },\n\n  date(key: string, defaultValue?: Date): Date | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return new Date(getKey(key));\n  },\n\n  /**\n   * Gets a value from env that matches oneOf provided values\n   * @param {string} key\n   * @param {string[]} expectedValues\n   * @param {string|undefined} defaultValue\n   * @returns {string|undefined}\n   */\n  oneOf(key: string, expectedValues?: unknown[], defaultValue?: unknown) {\n    if (!expectedValues) {\n      throw new Error(`env.oneOf requires expectedValues`);\n    }\n\n    if (defaultValue && !expectedValues.includes(defaultValue)) {\n      throw new Error(`env.oneOf requires defaultValue to be included in expectedValues`);\n    }\n\n    const rawValue = env(key, defaultValue);\n    return expectedValues.includes(rawValue) ? rawValue : defaultValue;\n  },\n};\n\nconst env = Object.assign(envFn, utils);\n\nexport default env;\n","import type { Attribute, Model } from './types';\n\nimport { isRelationalAttribute } from './content-types';\n\nconst MANY_RELATIONS = ['oneToMany', 'manyToMany'];\n\nconst getRelationalFields = (contentType: Model) => {\n  return Object.keys(contentType.attributes).filter((attributeName) => {\n    return contentType.attributes[attributeName].type === 'relation';\n  });\n};\n\nconst isOneToAny = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToOne', 'oneToMany'].includes(attribute.relation);\nconst isManyToAny = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['manyToMany', 'manyToOne'].includes(attribute.relation);\nconst isAnyToOne = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToOne', 'manyToOne'].includes(attribute.relation);\nconst isAnyToMany = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToMany', 'manyToMany'].includes(attribute.relation);\n\nexport const constants = {\n  MANY_RELATIONS,\n};\n\nexport { getRelationalFields, isOneToAny, isManyToAny, isAnyToOne, isAnyToMany };\n","import { assign, assoc } from 'lodash/fp';\nimport * as contentTypes from './content-types';\n\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypes.constants;\n\nexport interface Options {\n  user: User;\n  isEdition?: boolean;\n}\n\ninterface User {\n  id: string | number;\n}\n\nconst setCreatorFields =\n  <TData extends object>({ user, isEdition = false }: Options) =>\n  <TDataInner extends object = TData>(data: TDataInner) => {\n    if (isEdition) {\n      return assoc(UPDATED_BY_ATTRIBUTE, user.id, data);\n    }\n\n    return assign(data, {\n      [CREATED_BY_ATTRIBUTE]: user.id,\n      [UPDATED_BY_ATTRIBUTE]: user.id,\n    });\n  };\n\nexport default setCreatorFields;\n","import { eq, remove, cloneDeep } from 'lodash/fp';\n\nexport type Handler = (...args: any[]) => any;\n\nexport interface Hook<T extends Handler = Handler> {\n  getHandlers(): Handler[];\n  register(handler: T): Hook<T>;\n  delete(handler: T): Hook<T>;\n  call(...args: any[]): void;\n}\n\nexport interface AsyncSeriesHook extends Hook {\n  call(...args: any[]): Promise<void>;\n}\nexport interface AsyncSeriesWaterfallHook extends Hook {\n  call(...args: any[]): Promise<any>;\n}\n\nexport interface AsyncParallelHook extends Hook {\n  call(...args: any[]): Promise<any[]>;\n}\n\nexport interface AsyncBailHook extends Hook {\n  call(...args: any[]): Promise<any>;\n}\n\n/**\n * Create a default Strapi hook\n */\nconst createHook = <T extends Handler = Handler>(): Hook<T> => {\n  type State = {\n    handlers: T[];\n  };\n\n  const state: State = {\n    handlers: [],\n  };\n\n  return {\n    getHandlers() {\n      return state.handlers;\n    },\n\n    register(handler: T) {\n      state.handlers.push(handler);\n\n      return this;\n    },\n\n    delete(handler: T) {\n      state.handlers = remove(eq(handler), state.handlers);\n\n      return this;\n    },\n\n    call() {\n      throw new Error('Method not implemented');\n    },\n  };\n};\n\n/**\n * Create an async series hook.\n * Upon execution, it will execute every handler in order with the same context\n */\nconst createAsyncSeriesHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    for (const handler of this.getHandlers()) {\n      await handler(context);\n    }\n  },\n});\n\n/**\n * Create an async series waterfall hook.\n * Upon execution, it will execute every handler in order and pass the return value of the last handler to the next one\n */\nconst createAsyncSeriesWaterfallHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(param: unknown) {\n    let res = param;\n\n    for (const handler of this.getHandlers()) {\n      res = await handler(res);\n    }\n\n    return res;\n  },\n});\n\n/**\n * Create an async parallel hook.\n * Upon execution, it will execute every registered handler in band.\n */\nconst createAsyncParallelHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    const promises = this.getHandlers().map((handler) => handler(cloneDeep(context)));\n\n    return Promise.all(promises);\n  },\n});\n\n/**\n * Create an async parallel hook.\n * Upon execution, it will execute every registered handler in serie and return the first result found.\n */\nconst createAsyncBailHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    for (const handler of this.getHandlers()) {\n      const result = await handler(context);\n\n      if (result !== undefined) {\n        return result;\n      }\n    }\n  },\n});\n\nexport const internals = {\n  // Internal utils\n  createHook,\n};\n\nexport {\n  createAsyncSeriesHook,\n  createAsyncSeriesWaterfallHook,\n  createAsyncParallelHook,\n  createAsyncBailHook,\n};\n","import { cloneDeep } from 'lodash/fp';\nimport {\n  createAsyncSeriesHook,\n  createAsyncParallelHook,\n  AsyncSeriesHook,\n  AsyncParallelHook,\n} from './hooks';\n\nexport interface ProviderHooksMap {\n  willRegister: AsyncSeriesHook;\n  didRegister: AsyncParallelHook;\n  willDelete: AsyncParallelHook;\n  didDelete: AsyncParallelHook;\n}\n\n/**\n * Creates a new object containing various hooks used by the providers\n */\nconst createProviderHooksMap = (): ProviderHooksMap => ({\n  // Register events\n  willRegister: createAsyncSeriesHook(),\n  didRegister: createAsyncParallelHook(),\n  // Delete events\n  willDelete: createAsyncParallelHook(),\n  didDelete: createAsyncParallelHook(),\n});\n\nexport interface Options {\n  throwOnDuplicates?: boolean;\n}\n\ntype Item = Record<string, unknown>;\n\nexport interface Provider {\n  hooks: ProviderHooksMap;\n  register(key: string, item: Item): Promise<Provider>;\n  delete(key: string): Promise<Provider>;\n  get(key: string): Item | undefined;\n  getWhere(filters?: Record<string, unknown>): Item[];\n  values(): Item[];\n  keys(): string[];\n  has(key: string): boolean;\n  size(): number;\n  clear(): Promise<Provider>;\n}\n\nexport type ProviderFactory = (options?: Options) => Provider;\n\n/**\n * A Provider factory\n */\nconst providerFactory: ProviderFactory = (options = {}) => {\n  const { throwOnDuplicates = true } = options;\n\n  const state = {\n    hooks: createProviderHooksMap(),\n    registry: new Map<string, Item>(),\n  };\n\n  return {\n    hooks: state.hooks,\n\n    async register(key: string, item: Item) {\n      if (throwOnDuplicates && this.has(key)) {\n        throw new Error(`Duplicated item key: ${key}`);\n      }\n\n      await state.hooks.willRegister.call({ key, value: item });\n\n      state.registry.set(key, item);\n\n      await state.hooks.didRegister.call({ key, value: cloneDeep(item) });\n\n      return this;\n    },\n\n    async delete(key: string) {\n      if (this.has(key)) {\n        const item = this.get(key);\n\n        await state.hooks.willDelete.call({ key, value: cloneDeep(item) });\n\n        state.registry.delete(key);\n\n        await state.hooks.didDelete.call({ key, value: cloneDeep(item) });\n      }\n\n      return this;\n    },\n\n    get(key: string) {\n      return state.registry.get(key);\n    },\n\n    getWhere(filters = {}) {\n      const items = this.values();\n      const filtersEntries = Object.entries(filters);\n\n      if (filtersEntries.length === 0) {\n        return items;\n      }\n\n      return items.filter((item) => {\n        return filtersEntries.every(([key, value]) => item[key] === value);\n      });\n    },\n\n    values() {\n      return Array.from(state.registry.values());\n    },\n\n    keys() {\n      return Array.from(state.registry.keys());\n    },\n\n    has(key: string) {\n      return state.registry.has(key);\n    },\n\n    size() {\n      return state.registry.size;\n    },\n\n    async clear() {\n      const keys = this.keys();\n\n      for (const key of keys) {\n        await this.delete(key);\n      }\n\n      return this;\n    },\n  };\n};\n\nexport default providerFactory;\n","import { merge, pipe, omit, isNil } from 'lodash/fp';\nimport { PaginationError } from './errors';\n\ninterface PaginationArgs {\n  page: number;\n  pageSize: number;\n  start: number;\n  limit: number;\n}\n\nexport interface Pagination {\n  start: number;\n  limit: number;\n}\n\nconst STRAPI_DEFAULTS = {\n  offset: {\n    start: 0,\n    limit: 10,\n  },\n  page: {\n    page: 1,\n    pageSize: 10,\n  },\n};\n\nconst paginationAttributes = ['start', 'limit', 'page', 'pageSize'];\n\nconst withMaxLimit = (limit: number, maxLimit = -1) => {\n  if (maxLimit === -1 || limit < maxLimit) {\n    return limit;\n  }\n\n  return maxLimit;\n};\n\n// Ensure minimum page & pageSize values (page >= 1, pageSize >= 0, start >= 0, limit >= 0)\nconst ensureMinValues = ({ start, limit }: Pagination) => ({\n  start: Math.max(start, 0),\n  limit: limit === -1 ? limit : Math.max(limit, 1),\n});\n\nconst ensureMaxValues =\n  (maxLimit = -1) =>\n  ({ start, limit }: { start: number; limit: number }) => ({\n    start,\n    limit: withMaxLimit(limit, maxLimit),\n  });\n\n// Apply maxLimit as the limit when limit is -1\nconst withNoLimit = (pagination: Pagination, maxLimit = -1) => ({\n  ...pagination,\n  limit: pagination.limit === -1 ? maxLimit : pagination.limit,\n});\n\nconst withDefaultPagination = (\n  args: Partial<PaginationArgs>,\n  { defaults = {}, maxLimit = -1 } = {}\n) => {\n  const defaultValues = merge(STRAPI_DEFAULTS, defaults);\n\n  const usePagePagination = !isNil(args.page) || !isNil(args.pageSize);\n  const useOffsetPagination = !isNil(args.start) || !isNil(args.limit);\n\n  const ensureValidValues = pipe(ensureMinValues, ensureMaxValues(maxLimit));\n\n  // If there is no pagination attribute, don't modify the payload\n  if (!usePagePagination && !useOffsetPagination) {\n    return merge(args, ensureValidValues(defaultValues.offset));\n  }\n\n  // If there is page & offset pagination attributes, throw an error\n  if (usePagePagination && useOffsetPagination) {\n    throw new PaginationError('Cannot use both page & offset pagination in the same query');\n  }\n\n  const pagination: Pagination = {\n    start: 0,\n    limit: 0,\n  };\n\n  // Start / Limit\n  if (useOffsetPagination) {\n    const { start, limit } = merge(defaultValues.offset, args);\n\n    Object.assign(pagination, { start, limit });\n  }\n\n  // Page / PageSize\n  if (usePagePagination) {\n    const { page, pageSize } = merge(defaultValues.page, {\n      ...args,\n      pageSize: Math.max(1, args.pageSize ?? 0),\n    });\n\n    Object.assign(pagination, {\n      start: (page - 1) * pageSize,\n      limit: pageSize,\n    });\n  }\n\n  // Handle -1 limit\n  Object.assign(pagination, withNoLimit(pagination, maxLimit));\n\n  const replacePaginationAttributes = pipe(\n    // Remove pagination attributes\n    omit(paginationAttributes),\n    // Merge the object with the new pagination + ensure minimum & maximum values\n    merge(ensureValidValues(pagination))\n  );\n\n  return replacePaginationAttributes(args);\n};\n\nexport { withDefaultPagination };\n","import pMap from 'p-map';\nimport { curry } from 'lodash/fp';\n\ntype AnyFunc = (...args: any) => any;\n\n/*\n NOTE: This type is here to enforce piped functions have the right input/output types\n For a list of functions it will return a new list of function but will answer the return type of the previous is the arg type of the next function\n*/\ntype PipeArgs<F extends AnyFunc[], PrevReturn = Parameters<F[0]>[0]> = F extends [\n  (arg: any) => infer B\n]\n  ? [(arg: PrevReturn) => B]\n  : F extends [(arg: any) => infer B, ...infer Tail]\n  ? Tail extends AnyFunc[]\n    ? [(arg: PrevReturn) => B, ...PipeArgs<Tail, B>]\n    : []\n  : [];\n\nexport function pipeAsync<F extends AnyFunc[], FirstFn extends F[0]>(\n  ...fns: PipeArgs<F> extends F ? F : PipeArgs<F>\n) {\n  type Args = Parameters<FirstFn>;\n  type ReturnT = F extends [...AnyFunc[], (...arg: any) => infer R]\n    ? R extends Promise<infer InnerType>\n      ? InnerType\n      : R\n    : never;\n\n  const [firstFn, ...fnRest] = fns;\n\n  return async (...args: Args): Promise<ReturnT> => {\n    let res: ReturnT = await firstFn.apply(firstFn, args);\n\n    for (let i = 0; i < fnRest.length; i += 1) {\n      res = await fnRest[i](res);\n    }\n\n    return res;\n  };\n}\n\nexport const mapAsync = curry(pMap);\n\nexport const reduceAsync =\n  (mixedArray: any[]) =>\n  async <T>(iteratee: AnyFunc, initialValue?: T) => {\n    let acc = initialValue;\n    for (let i = 0; i < mixedArray.length; i += 1) {\n      acc = await iteratee(acc, await mixedArray[i], i);\n    }\n    return acc;\n  };\n\nexport const forEachAsync = async <T, R>(\n  array: T[],\n  func: pMap.Mapper<T, R>,\n  options: pMap.Options\n) => {\n  await pMap(array, func, options);\n};\n","import type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (attribute?.type === 'password') {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isPrivateAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, attribute }, { remove }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import * as contentTypeUtils from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst ACTIONS_TO_VERIFY = ['find'];\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\n\ntype MorphArray = Array<{ __type: string }>;\n\nexport default (auth: unknown): Visitor =>\n  async ({ data, key, attribute, schema }, { remove, set }) => {\n    if (!attribute) {\n      return;\n    }\n\n    const isRelation = attribute.type === 'relation';\n\n    if (!isRelation) {\n      return;\n    }\n\n    const handleMorphRelation = async () => {\n      const newMorphValue: Record<string, unknown>[] = [];\n\n      for (const element of (data as Record<string, MorphArray>)[key]) {\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n        if (isAllowed) {\n          newMorphValue.push(element);\n        }\n      }\n\n      // If the new value is empty, remove the relation completely\n      if (newMorphValue.length === 0) {\n        remove(key);\n      } else {\n        set(key, newMorphValue);\n      }\n    };\n\n    const handleRegularRelation = async () => {\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\n\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n      // If the authenticated user don't have access to any of the scopes, then remove the field\n      if (!isAllowed) {\n        remove(key);\n      }\n    };\n\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\n\n    // Polymorphic relations\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\n      await handleMorphRelation();\n      return;\n    }\n\n    // Creator relations\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\n      // do nothing\n      return;\n    }\n\n    // Regular relations\n    await handleRegularRelation();\n  };\n\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\n  for (const scope of scopes) {\n    try {\n      await strapi.auth.verify(auth, { scope });\n      return true;\n    } catch {\n      continue;\n    }\n  }\n\n  return false;\n};\n","import { isMorphToRelationalAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (isMorphToRelationalAttribute(attribute)) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isDynamicZoneAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (isDynamicZoneAttribute(attribute)) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\n\nexport default (allowedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }, { remove }) => {\n    // All fields are allowed\n    if (allowedFields === null) {\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\n      );\n    }\n\n    if (isNil(path)) {\n      return;\n    }\n\n    const containedPaths = getContainedPaths(path);\n\n    /**\n     * Tells if the current path should be kept or not based\n     * on the success of the check functions for any of the allowed paths.\n     *\n     * The check functions are defined as follow:\n     *\n     * `containedPaths.includes(p)`\n     * @example\n     * ```js\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match but isn't handled by this check\n     * ```\n     *\n     * `p.startsWith(`${path}.`)`\n     * @example\n     * ```js\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match but isn't handled by this check\n     * ```\n     */\n    const isPathAllowed = allowedFields.some(\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\n    );\n\n    if (isPathAllowed) {\n      return;\n    }\n\n    // Remove otherwise\n    remove(key);\n  };\n\n/**\n * Retrieve the list of allowed paths based on the given path\n *\n * @example\n * ```js\n * const containedPaths = getContainedPaths('foo');\n * // ['foo']\n *\n *  * const containedPaths = getContainedPaths('foo.bar');\n * // ['foo', 'foo.bar']\n *\n *  * const containedPaths = getContainedPaths('foo.bar.field');\n * // ['foo', 'foo.bar', 'foo.bar.field']\n * ```\n */\nconst getContainedPaths = (path: string) => {\n  const parts = toPath(path);\n\n  return parts.reduce((acc, value, index, list) => {\n    return [...acc, list.slice(0, index + 1).join('.')];\n  }, [] as string[]);\n};\n","import { isArray, isString } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\n\nexport default (restrictedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }, { remove }) => {\n    // Remove all fields\n    if (restrictedFields === null) {\n      remove(key);\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\n      );\n    }\n\n    // Remove if an exact match was found\n    if (restrictedFields.includes(path as string)) {\n      remove(key);\n      return;\n    }\n\n    // Remove nested matches\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\n      path?.toString().startsWith(`${allowedPath}.`)\n    );\n    if (isRestrictedNested) {\n      remove(key);\n    }\n  };\n","import { clone, isObject, isArray, isNil, curry } from 'lodash/fp';\nimport type { AnyAttribute, Model, Data } from './types';\nimport { isRelationalAttribute, isMediaAttribute } from './content-types';\n\nexport type VisitorUtils = ReturnType<typeof createVisitorUtils>;\n\nexport interface VisitorOptions {\n  data: Record<string, unknown>;\n  schema: Model;\n  key: string;\n  value: Data[keyof Data];\n  attribute: AnyAttribute;\n  path: Path;\n}\n\nexport type Visitor = (visitorOptions: VisitorOptions, visitorUtils: VisitorUtils) => void;\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n}\n\nexport interface TraverseOptions {\n  path?: Path;\n  schema: Model;\n}\n\nconst traverseMorphRelationTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n  const targetSchema = strapi.getModel(entry.__type);\n\n  const traverseOptions = { schema: targetSchema, path };\n\n  return traverseEntity(visitor, traverseOptions, entry);\n};\n\nconst traverseRelationTarget =\n  (schema: Model) => async (visitor: Visitor, path: Path, entry: Data) => {\n    const traverseOptions = { schema, path };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\nconst traverseMediaTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n  const targetSchemaUID = 'plugin::upload.file';\n  const targetSchema = strapi.getModel(targetSchemaUID);\n\n  const traverseOptions = { schema: targetSchema, path };\n\n  return traverseEntity(visitor, traverseOptions, entry);\n};\n\nconst traverseComponent = async (visitor: Visitor, path: Path, schema: Model, entry: Data) => {\n  const traverseOptions = { schema, path };\n\n  return traverseEntity(visitor, traverseOptions, entry);\n};\n\nconst visitDynamicZoneEntry = async (visitor: Visitor, path: Path, entry: Data) => {\n  const targetSchema = strapi.getModel(entry.__component);\n  const traverseOptions = { schema: targetSchema, path };\n\n  return traverseEntity(visitor, traverseOptions, entry);\n};\nconst traverseEntity = async (visitor: Visitor, options: TraverseOptions, entity: Data) => {\n  const { path = { raw: null, attribute: null }, schema } = options;\n\n  // End recursion\n  if (!isObject(entity) || isNil(schema)) {\n    return entity;\n  }\n\n  // Don't mutate the original entity object\n  // only clone at 1st level as the next level will get clone when traversed\n  const copy = clone(entity);\n  const visitorUtils = createVisitorUtils({ data: copy });\n\n  const keys = Object.keys(copy);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    // Retrieve the attribute definition associated to the key from the schema\n    const attribute = schema.attributes[key];\n\n    // If the attribute doesn't exist within the schema, ignore it\n    if (isNil(attribute)) {\n      continue;\n    }\n\n    const newPath = { ...path };\n\n    newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n\n    if (!isNil(attribute)) {\n      newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n    }\n\n    // Visit the current attribute\n    const visitorOptions: VisitorOptions = {\n      data: copy,\n      schema,\n      key,\n      value: copy[key],\n      attribute,\n      path: newPath,\n    };\n\n    await visitor(visitorOptions, visitorUtils);\n\n    // Extract the value for the current key (after calling the visitor)\n    const value = copy[key];\n\n    // Ignore Nil values\n    if (isNil(value)) {\n      continue;\n    }\n\n    if (isRelationalAttribute(attribute)) {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      const method = isMorphRelation\n        ? traverseMorphRelationTarget\n        : traverseRelationTarget(strapi.getModel(attribute.target));\n\n      if (isArray(value)) {\n        const res = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await method(visitor, newPath, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await method(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (isMediaAttribute(attribute)) {\n      // need to update copy\n      if (isArray(value)) {\n        const res = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await traverseMediaTarget(visitor, newPath, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await traverseMediaTarget(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const targetSchema = strapi.getModel(attribute.component);\n\n      if (isArray(value)) {\n        const res: Data[] = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await traverseComponent(visitor, newPath, targetSchema, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await traverseComponent(visitor, newPath, targetSchema, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone' && isArray(value)) {\n      const res = new Array(value.length);\n      for (let i = 0; i < value.length; i += 1) {\n        res[i] = await visitDynamicZoneEntry(visitor, newPath, value[i]);\n      }\n      copy[key] = res;\n\n      continue;\n    }\n  }\n\n  return copy;\n};\n\nconst createVisitorUtils = ({ data }: { data: Data }) => ({\n  remove(key: string) {\n    delete data[key];\n  },\n\n  set(key: string, value: Data) {\n    data[key] = value;\n  },\n});\n\nexport default curry(traverseEntity);\n","/* eslint-disable @typescript-eslint/no-loop-func */\nimport { isNil, pick } from 'lodash/fp';\nimport {\n  AnyAttribute,\n  Attribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  Model,\n  RelationalAttribute,\n} from '../types';\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n}\n\nexport interface TraverseOptions {\n  path?: Path;\n  schema: Model;\n}\n\nexport interface VisitorOptions {\n  data: unknown;\n  value: unknown;\n  schema: Model;\n  key: string;\n  attribute: AnyAttribute;\n  path: Path;\n}\n\nexport type Traverse = (\n  visitor: Visitor,\n  options: TraverseOptions,\n  data: unknown\n) => Promise<unknown>;\n\nexport interface Visitor {\n  (visitorOptions: VisitorOptions, opts: Pick<TransformUtils, 'set' | 'remove'>): void;\n}\n\ninterface Interceptor<T = unknown> {\n  predicate(data: unknown): data is T;\n  handler(\n    visitor: Visitor,\n    options: TraverseOptions,\n    data: T,\n    recurseOptions: { recurse: Traverse }\n  ): void;\n}\n\ninterface ParseUtils<T> {\n  transform(data: T): unknown;\n  remove(key: string, data: T): unknown;\n  set(key: string, valeu: unknown, data: T): unknown;\n  keys(data: T): string[];\n  get(key: string, data: T): unknown;\n}\n\ninterface Parser<T = unknown> {\n  predicate(data: unknown): data is T;\n  parser(data: T): ParseUtils<T>;\n}\n\ninterface Ignore {\n  (ctx: Context): boolean;\n}\n\ninterface AttributeHandler<AttributeType = Attribute> {\n  predicate(ctx: Context<AttributeType>): boolean;\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\n}\ninterface CommonHandler<AttributeType = Attribute> {\n  predicate(ctx: Context<AttributeType>): boolean;\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\n}\n\nexport interface TransformUtils {\n  remove(key: string): void;\n  set(key: string, valeu: unknown): void;\n  recurse: Traverse;\n}\n\ninterface Context<AttributeType = Attribute> {\n  key: string;\n  value: unknown;\n  attribute: AttributeType;\n  schema: Model;\n  path: Path;\n  data: unknown;\n  visitor: Visitor;\n}\ninterface State {\n  parsers: Parser[];\n  interceptors: Interceptor[];\n  ignore: Ignore[];\n  handlers: {\n    attributes: AttributeHandler[];\n    common: CommonHandler[];\n  };\n}\n\nconst DEFAULT_PATH = { raw: null, attribute: null };\n\nexport default () => {\n  const state: State = {\n    parsers: [],\n    interceptors: [],\n    ignore: [],\n    handlers: {\n      attributes: [],\n      common: [],\n    },\n  };\n\n  const traverse: Traverse = async (visitor, options, data) => {\n    const { path = DEFAULT_PATH, schema } = options ?? {};\n\n    // interceptors\n    for (const { predicate, handler } of state.interceptors) {\n      if (predicate(data)) {\n        return handler(visitor, options, data, { recurse: traverse });\n      }\n    }\n\n    // parsers\n    const parser = state.parsers.find((parser) => parser.predicate(data))?.parser;\n    const utils = parser?.(data);\n\n    // Return the data untouched if we don't know how to traverse it\n    if (!utils) {\n      return data;\n    }\n\n    // main loop\n    let out = utils.transform(data);\n    const keys = utils.keys(out);\n\n    for (const key of keys) {\n      const attribute =\n        schema?.attributes?.[key] ??\n        // FIX: Needed to not break existing behavior on the API.\n        //      It looks for the attribute in the DB metadata when the key is in snake_case\n        schema?.attributes?.[strapi.db.metadata.get(schema?.uid).columnToAttribute[key]];\n\n      const newPath = { ...path };\n\n      newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n\n      if (!isNil(attribute)) {\n        newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n      }\n\n      // visitors\n\n      const visitorOptions: VisitorOptions = {\n        key,\n        value: utils.get(key, out),\n        attribute,\n        schema,\n        path: newPath,\n        data: out,\n      };\n\n      const transformUtils: TransformUtils = {\n        remove(key) {\n          out = utils.remove(key, out);\n        },\n        set(key, value) {\n          out = utils.set(key, value, out);\n        },\n        recurse: traverse,\n      };\n\n      await visitor(visitorOptions, pick(['remove', 'set'], transformUtils));\n\n      const value = utils.get(key, out);\n\n      const createContext = (): Context => ({\n        key,\n        value,\n        attribute,\n        schema,\n        path: newPath,\n        data: out,\n        visitor,\n      });\n\n      // ignore\n      const ignoreCtx = createContext();\n      const shouldIgnore = state.ignore.some((predicate) => predicate(ignoreCtx));\n\n      if (shouldIgnore) {\n        continue;\n      }\n\n      // handlers\n      const handlers = [...state.handlers.common, ...state.handlers.attributes];\n\n      for await (const handler of handlers) {\n        const ctx = createContext();\n        const pass = await handler.predicate(ctx);\n\n        if (pass) {\n          await handler.handler(ctx, pick(['recurse', 'set'], transformUtils));\n        }\n      }\n    }\n\n    return out;\n  };\n\n  return {\n    traverse,\n\n    intercept<T>(predicate: Interceptor<T>['predicate'], handler: Interceptor<T>['handler']) {\n      state.interceptors.push({ predicate, handler });\n      return this;\n    },\n\n    parse<T>(predicate: Parser<T>['predicate'], parser: Parser<T>['parser']) {\n      state.parsers.push({ predicate, parser });\n      return this;\n    },\n\n    ignore(predicate: Ignore) {\n      state.ignore.push(predicate);\n      return this;\n    },\n\n    on(predicate: CommonHandler['predicate'], handler: CommonHandler['handler']) {\n      state.handlers.common.push({ predicate, handler });\n      return this;\n    },\n\n    onAttribute(predicate: AttributeHandler['predicate'], handler: AttributeHandler['handler']) {\n      state.handlers.attributes.push({ predicate, handler });\n      return this;\n    },\n\n    onRelation(handler: AttributeHandler<RelationalAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'relation', handler);\n    },\n\n    onMedia(handler: AttributeHandler<RelationalAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'media', handler);\n    },\n\n    onComponent(handler: AttributeHandler<ComponentAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'component', handler);\n    },\n\n    onDynamicZone(handler: AttributeHandler<DynamicZoneAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'dynamiczone', handler);\n    },\n  };\n};\n","import { curry, isObject, isEmpty, isArray, isNil, cloneDeep, omit } from 'lodash/fp';\n\nimport traverseFactory from './factory';\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst filters = traverseFactory()\n  .intercept(\n    // Intercept filters arrays and apply the traversal to each one individually\n    isArray,\n    async (visitor, options, filters, { recurse }) => {\n      return Promise.all(\n        filters.map((filter, i) => {\n          // In filters, only operators such as $and, $in, $notIn or $or and implicit operators like [...]\n          // can have a value array, thus we can update the raw path but not the attribute one\n          const newPath = options.path\n            ? { ...options.path, raw: `${options.path.raw}[${i}]` }\n            : options.path;\n\n          return recurse(visitor, { ...options, path: newPath }, filter);\n        })\n        // todo: move that to the visitors\n      ).then((res) => res.filter((val) => !(isObject(val) && isEmpty(val))));\n    }\n  )\n  .intercept(\n    // Ignore non object filters and return the value as-is\n    (filters): filters is unknown => !isObject(filters),\n    (_, __, filters) => {\n      return filters;\n    }\n  )\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      return omit(key, data);\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Ignore null or undefined values\n  .ignore(({ value }) => isNil(value))\n  // Recursion on operators (non attributes)\n  .on(\n    ({ attribute }) => isNil(attribute),\n    async ({ key, visitor, path, value, schema }, { set, recurse }) => {\n      set(key, await recurse(visitor, { schema, path }, value));\n    }\n  )\n  // Handle relation recursion\n  .onRelation(async ({ key, attribute, visitor, path, value }, { set, recurse }) => {\n    const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n    if (isMorphRelation) {\n      return;\n    }\n\n    const targetSchemaUID = attribute.target;\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  .onComponent(async ({ key, attribute, visitor, path, value }, { set, recurse }) => {\n    const targetSchema = strapi.getModel(attribute.component);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  // Handle media recursion\n  .onMedia(async ({ key, visitor, path, value }, { set, recurse }) => {\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  });\n\nexport default curry(filters.traverse);\n","import {\n  curry,\n  isString,\n  isObject,\n  map,\n  trim,\n  split,\n  isEmpty,\n  flatten,\n  pipe,\n  isNil,\n  first,\n  cloneDeep,\n} from 'lodash/fp';\n\nimport traverseFactory from './factory';\n\nconst ORDERS = { asc: 'asc', desc: 'desc' };\nconst ORDER_VALUES = Object.values(ORDERS);\n\nconst isSortOrder = (value: string) => ORDER_VALUES.includes(value.toLowerCase());\nconst isStringArray = (value: unknown): value is string[] =>\n  Array.isArray(value) && value.every(isString);\nconst isObjectArray = (value: unknown): value is object[] =>\n  Array.isArray(value) && value.every(isObject);\nconst isNestedSorts = (value: unknown): value is string =>\n  isString(value) && value.split(',').length > 1;\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst sort = traverseFactory()\n  .intercept(\n    // String with chained sorts (foo,bar,foobar) => split, map(recurse), then recompose\n    isNestedSorts,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(\n        sort\n          .split(',')\n          .map(trim)\n          .map((nestedSort) => recurse(visitor, options, nestedSort))\n      ).then((res) => res.filter((part) => !isEmpty(part)).join(','));\n    }\n  )\n  .intercept(\n    // Array of strings ['foo', 'foo,bar'] => map(recurse), then filter out empty items\n    isStringArray,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\n      );\n    }\n  )\n  .intercept(\n    // Array of objects [{ foo: 'asc' }, { bar: 'desc', baz: 'asc' }] => map(recurse), then filter out empty items\n    isObjectArray,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\n      );\n    }\n  )\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = pipe(split('.'), map(split(':')), flatten);\n    const recompose = (parts: string[]) => {\n      if (parts.length === 0) {\n        return undefined;\n      }\n\n      return parts.reduce((acc, part) => {\n        if (isEmpty(part)) {\n          return acc;\n        }\n\n        if (acc === '') {\n          return part;\n        }\n\n        return isSortOrder(part) ? `${acc}:${part}` : `${acc}.${part}`;\n      }, '');\n    };\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Handle deep sort on relation\n  .onRelation(async ({ key, value, attribute, visitor, path }, { set, recurse }) => {\n    const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n    if (isMorphRelation) {\n      return;\n    }\n\n    const targetSchemaUID = attribute.target;\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  // Handle deep sort on media\n  .onMedia(async ({ key, path, visitor, value }, { recurse, set }) => {\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  // Handle deep sort on components\n  .onComponent(async ({ key, value, visitor, path, attribute }, { recurse, set }) => {\n    const targetSchema = strapi.getModel(attribute.component);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  });\n\nexport default curry(sort.traverse);\n","import {\n  curry,\n  isString,\n  isArray,\n  isEmpty,\n  split,\n  isObject,\n  trim,\n  isNil,\n  cloneDeep,\n  join,\n  first,\n  omit,\n  merge,\n} from 'lodash/fp';\n\nimport traverseFactory from './factory';\nimport { Attribute } from '../types';\nimport { isMorphToRelationalAttribute } from '../content-types';\n\nconst isKeyword = (keyword: string) => {\n  return ({ key, attribute }: { key: string; attribute: Attribute }) => {\n    return !attribute && keyword === key;\n  };\n};\n\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\nconst isWildCardConstant = (value: unknown): value is '*' => value === '*';\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst populate = traverseFactory()\n  // Array of strings ['foo', 'foo.bar'] => map(recurse), then filter out empty items\n  .intercept(isStringArray, async (visitor, options, populate, { recurse }) => {\n    const visitedPopulate = await Promise.all(\n      populate.map((nestedPopulate) => recurse(visitor, options, nestedPopulate))\n    );\n\n    return visitedPopulate.filter((item) => !isNil(item));\n  })\n  // Transform wildcard populate to an exhaustive list of attributes to populate.\n  .intercept(isWildCardConstant, (visitor, options, _data, { recurse }) => {\n    const attributes = options.schema?.attributes;\n\n    // This should never happen, but adding the check in\n    // case this method is called with wrong parameters\n    if (!attributes) {\n      return '*';\n    }\n\n    const parsedPopulate = Object.entries(attributes)\n      // Get the list of all attributes that can be populated\n      .filter(([, value]) => ['relation', 'component', 'dynamiczone', 'media'].includes(value.type))\n      // Only keep the attributes key\n      .reduce((acc, [key]) => ({ ...acc, [key]: true }), {});\n\n    return recurse(visitor, options, parsedPopulate);\n  })\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = split('.');\n    const recompose = join('.');\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) || isEmpty(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  .ignore(({ key, attribute }) => {\n    return ['sort', 'filters', 'fields'].includes(key) && !attribute;\n  })\n  .on(\n    // Handle recursion on populate.\"populate\"\n    isKeyword('populate'),\n    async ({ key, visitor, path, value, schema }, { set, recurse }) => {\n      const newValue = await recurse(visitor, { schema, path }, value);\n\n      set(key, newValue);\n    }\n  )\n  .on(isKeyword('on'), async ({ key, visitor, path, value }, { set, recurse }) => {\n    const newOn: Record<string, unknown> = {};\n\n    if (!isObj(value)) {\n      return;\n    }\n\n    for (const [uid, subPopulate] of Object.entries(value)) {\n      const model = strapi.getModel(uid);\n      const newPath = { ...path, raw: `${path.raw}[${uid}]` };\n\n      newOn[uid] = await recurse(visitor, { schema: model, path: newPath }, subPopulate);\n    }\n\n    set(key, newOn);\n  })\n  // Handle populate on relation\n  .onRelation(async ({ key, value, attribute, visitor, path, schema }, { set, recurse }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    if (isMorphToRelationalAttribute(attribute)) {\n      // Don't traverse values that cannot be parsed\n      if (!isObject(value) || !('on' in value && isObject(value?.on))) {\n        return;\n      }\n\n      // If there is a populate fragment defined, traverse it\n      const newValue = await recurse(visitor, { schema, path }, { on: value?.on });\n\n      set(key, { on: newValue });\n    }\n\n    const targetSchemaUID = attribute.target;\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  // Handle populate on media\n  .onMedia(async ({ key, path, visitor, value }, { recurse, set }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  // Handle populate on components\n  .onComponent(async ({ key, value, visitor, path, attribute }, { recurse, set }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    const targetSchema = strapi.getModel(attribute.component);\n\n    const newValue = await recurse(visitor, { schema: targetSchema, path }, value);\n\n    set(key, newValue);\n  })\n  // Handle populate on dynamic zones\n  .onDynamicZone(async ({ key, value, attribute, schema, visitor, path }, { set, recurse }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    if (isObject(value)) {\n      const { components } = attribute;\n\n      const newValue = {};\n\n      // Handle legacy DZ params\n      let newProperties: unknown = omit('on', value);\n\n      for (const componentUID of components) {\n        const componentSchema = strapi.getModel(componentUID);\n\n        const properties = await recurse(visitor, { schema: componentSchema, path }, value);\n        newProperties = merge(newProperties, properties);\n      }\n\n      Object.assign(newValue, newProperties);\n\n      // Handle new morph fragment syntax\n      if ('on' in value && value.on) {\n        const newOn = await recurse(visitor, { schema, path }, { on: value.on });\n\n        // Recompose both syntaxes\n        Object.assign(newValue, newOn);\n      }\n\n      set(key, newValue);\n    } else {\n      const newValue = await recurse(visitor, { schema, path }, value);\n\n      set(key, newValue);\n    }\n  });\n\nexport default curry(populate.traverse);\n","import { curry, isArray, isString, eq, trim, constant } from 'lodash/fp';\n\nimport traverseFactory from './factory';\n\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\nconst fields = traverseFactory()\n  // Interecept array of strings\n  .intercept(isStringArray, async (visitor, options, fields, { recurse }) => {\n    return Promise.all(fields.map((field) => recurse(visitor, options, field)));\n  })\n  // Return wildcards as is\n  .intercept((value): value is string => eq('*', value), constant('*'))\n  // Parse string values\n  // Since we're parsing strings only, each value should be an attribute name (and it's value, undefined),\n  // thus it shouldn't be possible to set a new value, and get should return the whole data if key === data\n  .parse(isString, () => ({\n    transform: trim,\n\n    remove(key, data) {\n      return data === key ? undefined : data;\n    },\n\n    set(_key, _value, data) {\n      return data;\n    },\n\n    keys(data) {\n      return [data];\n    },\n\n    get(key, data) {\n      return key === data ? data : undefined;\n    },\n  }));\n\nexport default curry(fields.traverse);\n","const GROUP_OPERATORS = ['$and', '$or'];\n\nconst WHERE_OPERATORS = [\n  '$not',\n  '$in',\n  '$notIn',\n  '$eq',\n  '$eqi',\n  '$ne',\n  '$nei',\n  '$gt',\n  '$gte',\n  '$lt',\n  '$lte',\n  '$null',\n  '$notNull',\n  '$between',\n  '$startsWith',\n  '$endsWith',\n  '$startsWithi',\n  '$endsWithi',\n  '$contains',\n  '$notContains',\n  '$containsi',\n  '$notContainsi',\n  // Experimental, only for internal use\n  '$jsonSupersetOf',\n];\n\nconst CAST_OPERATORS = [\n  '$not',\n  '$in',\n  '$notIn',\n  '$eq',\n  '$ne',\n  '$gt',\n  '$gte',\n  '$lt',\n  '$lte',\n  '$between',\n];\n\nconst ARRAY_OPERATORS = ['$in', '$notIn', '$between'];\n\nconst OPERATORS = {\n  where: WHERE_OPERATORS,\n  cast: CAST_OPERATORS,\n  group: GROUP_OPERATORS,\n  array: ARRAY_OPERATORS,\n};\n\n// for performance, cache all operators in lowercase\nconst OPERATORS_LOWERCASE = Object.fromEntries(\n  Object.entries(OPERATORS).map(([key, values]) => [\n    key,\n    values.map((value) => value.toLowerCase()),\n  ])\n);\n\nconst isObjKey = <T extends object>(key: string | symbol | number, obj: T): key is keyof T => {\n  return key in obj;\n};\n\nexport const isOperatorOfType = (type: string, key: string, ignoreCase = false) => {\n  if (ignoreCase) {\n    return OPERATORS_LOWERCASE[type]?.includes(key.toLowerCase()) ?? false;\n  }\n\n  if (isObjKey(type, OPERATORS)) {\n    return OPERATORS[type]?.includes(key) ?? false;\n  }\n\n  return false;\n};\n\nexport const isOperator = (key: string, ignoreCase = false) => {\n  return Object.keys(OPERATORS).some((type) => isOperatorOfType(type, key, ignoreCase));\n};\n","import { curry, isEmpty, isNil, isArray, isObject } from 'lodash/fp';\n\nimport { pipeAsync } from '../async';\nimport traverseEntity from '../traverse-entity';\nimport { isScalarAttribute } from '../content-types';\n\nimport {\n  traverseQueryFilters,\n  traverseQuerySort,\n  traverseQueryPopulate,\n  traverseQueryFields,\n} from '../traverse';\n\nimport {\n  removePassword,\n  removePrivate,\n  removeDynamicZones,\n  removeMorphToRelations,\n} from './visitors';\nimport { isOperator } from '../operators';\n\nimport type { Model, Data } from '../types';\n\nconst sanitizePasswords = (schema: Model) => async (entity: Data) => {\n  if (!schema) {\n    throw new Error('Missing schema in sanitizePasswords');\n  }\n  return traverseEntity(removePassword, { schema }, entity);\n};\n\nconst defaultSanitizeOutput = async (schema: Model, entity: Data) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultSanitizeOutput');\n  }\n  return traverseEntity(\n    (...args) => {\n      removePassword(...args);\n      removePrivate(...args);\n    },\n    { schema },\n    entity\n  );\n};\n\nconst defaultSanitizeFilters = curry((schema: Model, filters: unknown) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultSanitizeFilters');\n  }\n  return pipeAsync(\n    // Remove keys that are not attributes or valid operators\n    traverseQueryFilters(\n      ({ key, attribute }, { remove }) => {\n        const isAttribute = !!attribute;\n\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not checking it\n        if (key === 'id') {\n          return;\n        }\n\n        if (!isAttribute && !isOperator(key)) {\n          remove(key);\n        }\n      },\n      { schema }\n    ),\n    // Remove dynamic zones from filters\n    traverseQueryFilters(removeDynamicZones, { schema }),\n    // Remove morpTo relations from filters\n    traverseQueryFilters(removeMorphToRelations, { schema }),\n    // Remove passwords from filters\n    traverseQueryFilters(removePassword, { schema }),\n    // Remove private from filters\n    traverseQueryFilters(removePrivate, { schema }),\n    // Remove empty objects\n    traverseQueryFilters(\n      ({ key, value }, { remove }) => {\n        if (isObject(value) && isEmpty(value)) {\n          remove(key);\n        }\n      },\n      { schema }\n    )\n  )(filters);\n});\n\nconst defaultSanitizeSort = curry((schema: Model, sort: unknown) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultSanitizeSort');\n  }\n  return pipeAsync(\n    // Remove non attribute keys\n    traverseQuerySort(\n      ({ key, attribute }, { remove }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not checking it\n        if (key === 'id') {\n          return;\n        }\n\n        if (!attribute) {\n          remove(key);\n        }\n      },\n      { schema }\n    ),\n    // Remove dynamic zones from sort\n    traverseQuerySort(removeDynamicZones, { schema }),\n    // Remove morpTo relations from sort\n    traverseQuerySort(removeMorphToRelations, { schema }),\n    // Remove private from sort\n    traverseQuerySort(removePrivate, { schema }),\n    // Remove passwords from filters\n    traverseQuerySort(removePassword, { schema }),\n    // Remove keys for empty non-scalar values\n    traverseQuerySort(\n      ({ key, attribute, value }, { remove }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not removing it\n        if (key === 'id') {\n          return;\n        }\n\n        if (!isScalarAttribute(attribute) && isEmpty(value)) {\n          remove(key);\n        }\n      },\n      { schema }\n    )\n  )(sort);\n});\n\nconst defaultSanitizeFields = curry((schema: Model, fields: unknown) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultSanitizeFields');\n  }\n  return pipeAsync(\n    // Only keep scalar attributes\n    traverseQueryFields(\n      ({ key, attribute }, { remove }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not checking it\n        if (key === 'id') {\n          return;\n        }\n\n        if (isNil(attribute) || !isScalarAttribute(attribute)) {\n          remove(key);\n        }\n      },\n      { schema }\n    ),\n    // Remove private fields\n    traverseQueryFields(removePrivate, { schema }),\n    // Remove password fields\n    traverseQueryFields(removePassword, { schema }),\n    // Remove nil values from fields array\n    (value) => (isArray(value) ? value.filter((field) => !isNil(field)) : value)\n  )(fields);\n});\n\nconst defaultSanitizePopulate = curry((schema: Model, populate: unknown) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultSanitizePopulate');\n  }\n  return pipeAsync(\n    traverseQueryPopulate(\n      async ({ key, value, schema, attribute }, { set }) => {\n        if (attribute) {\n          return;\n        }\n\n        if (key === 'sort') {\n          set(key, await defaultSanitizeSort(schema, value));\n        }\n\n        if (key === 'filters') {\n          set(key, await defaultSanitizeFilters(schema, value));\n        }\n\n        if (key === 'fields') {\n          set(key, await defaultSanitizeFields(schema, value));\n        }\n      },\n      { schema }\n    ),\n    // Remove private fields\n    traverseQueryPopulate(removePrivate, { schema })\n  )(populate);\n});\n\nexport {\n  sanitizePasswords,\n  defaultSanitizeOutput,\n  defaultSanitizeFilters,\n  defaultSanitizeSort,\n  defaultSanitizeFields,\n  defaultSanitizePopulate,\n};\n","import { CurriedFunction1 } from 'lodash';\nimport { isArray, cloneDeep, omit } from 'lodash/fp';\n\nimport { getNonWritableAttributes } from '../content-types';\nimport { pipeAsync } from '../async';\n\nimport * as visitors from './visitors';\nimport * as sanitizers from './sanitizers';\nimport traverseEntity from '../traverse-entity';\n\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\nimport type { Model, Data } from '../types';\n\nexport interface Options {\n  auth?: unknown;\n}\n\ninterface Sanitizer {\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\n}\nexport interface SanitizeFunc {\n  (data: unknown, schema: Model, options?: Options): Promise<unknown>;\n}\n\nconst createContentAPISanitizers = () => {\n  const sanitizeInput: SanitizeFunc = (data: unknown, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeInput');\n    }\n    if (isArray(data)) {\n      return Promise.all(data.map((entry) => sanitizeInput(entry, schema, { auth })));\n    }\n\n    const nonWritableAttributes = getNonWritableAttributes(schema);\n\n    const transforms = [\n      // Remove first level ID in inputs\n      omit('id'),\n      // Remove non-writable attributes\n      traverseEntity(visitors.removeRestrictedFields(nonWritableAttributes), { schema }),\n    ];\n\n    if (auth) {\n      // Remove restricted relations\n      transforms.push(traverseEntity(visitors.removeRestrictedRelations(auth), { schema }));\n    }\n\n    // Apply sanitizers from registry if exists\n    strapi.sanitizers\n      .get('content-api.input')\n      .forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\n\n    return pipeAsync(...transforms)(data as Data);\n  };\n\n  const sanitizeOutput: SanitizeFunc = async (data, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeOutput');\n    }\n    if (isArray(data)) {\n      const res = new Array(data.length);\n      for (let i = 0; i < data.length; i += 1) {\n        res[i] = await sanitizeOutput(data[i], schema, { auth });\n      }\n      return res;\n    }\n\n    const transforms = [(data: Data) => sanitizers.defaultSanitizeOutput(schema, data)];\n\n    if (auth) {\n      transforms.push(traverseEntity(visitors.removeRestrictedRelations(auth), { schema }));\n    }\n\n    // Apply sanitizers from registry if exists\n    strapi.sanitizers\n      .get('content-api.output')\n      .forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\n\n    return pipeAsync(...transforms)(data as Data);\n  };\n\n  const sanitizeQuery = async (\n    query: Record<string, unknown>,\n    schema: Model,\n    { auth }: Options = {}\n  ) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeQuery');\n    }\n    const { filters, sort, fields, populate } = query;\n\n    const sanitizedQuery = cloneDeep(query);\n\n    if (filters) {\n      Object.assign(sanitizedQuery, { filters: await sanitizeFilters(filters, schema, { auth }) });\n    }\n\n    if (sort) {\n      Object.assign(sanitizedQuery, { sort: await sanitizeSort(sort, schema, { auth }) });\n    }\n\n    if (fields) {\n      Object.assign(sanitizedQuery, { fields: await sanitizeFields(fields, schema) });\n    }\n\n    if (populate) {\n      Object.assign(sanitizedQuery, { populate: await sanitizePopulate(populate, schema) });\n    }\n\n    return sanitizedQuery;\n  };\n\n  const sanitizeFilters: SanitizeFunc = (filters, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeFilters');\n    }\n    if (isArray(filters)) {\n      return Promise.all(filters.map((filter) => sanitizeFilters(filter, schema, { auth })));\n    }\n\n    const transforms = [sanitizers.defaultSanitizeFilters(schema)];\n\n    if (auth) {\n      transforms.push(traverseQueryFilters(visitors.removeRestrictedRelations(auth), { schema }));\n    }\n\n    return pipeAsync(...transforms)(filters);\n  };\n\n  const sanitizeSort: SanitizeFunc = (sort, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeSort');\n    }\n    const transforms = [sanitizers.defaultSanitizeSort(schema)];\n\n    if (auth) {\n      transforms.push(traverseQuerySort(visitors.removeRestrictedRelations(auth), { schema }));\n    }\n\n    return pipeAsync(...transforms)(sort);\n  };\n\n  const sanitizeFields: SanitizeFunc = (fields, schema: Model) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeFields');\n    }\n    const transforms = [sanitizers.defaultSanitizeFields(schema)];\n\n    return pipeAsync(...transforms)(fields);\n  };\n\n  const sanitizePopulate: SanitizeFunc = (populate, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizePopulate');\n    }\n    const transforms = [sanitizers.defaultSanitizePopulate(schema)];\n\n    if (auth) {\n      transforms.push(traverseQueryPopulate(visitors.removeRestrictedRelations(auth), { schema }));\n    }\n\n    return pipeAsync(...transforms)(populate);\n  };\n\n  return {\n    input: sanitizeInput,\n    output: sanitizeOutput,\n    query: sanitizeQuery,\n    filters: sanitizeFilters,\n    sort: sanitizeSort,\n    fields: sanitizeFields,\n    populate: sanitizePopulate,\n  };\n};\n\nconst contentAPI = createContentAPISanitizers();\n\nexport default {\n  contentAPI,\n  sanitizers,\n  visitors,\n};\n","import { ValidationError } from '../errors';\n\nexport const throwInvalidParam = ({ key }: { key: string }) => {\n  throw new ValidationError(`Invalid parameter ${key}`);\n};\n","import { throwInvalidParam } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }) => {\n  if (attribute?.type === 'password') {\n    throwInvalidParam({ key });\n  }\n};\n\nexport default visitor;\n","import { isPrivateAttribute } from '../../content-types';\nimport { throwInvalidParam } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, attribute }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    throwInvalidParam({ key });\n  }\n};\n\nexport default visitor;\n","import * as contentTypeUtils from '../../content-types';\nimport { throwInvalidParam } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst ACTIONS_TO_VERIFY = ['find'];\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\n\ntype MorphArray = Array<{ __type: string }>;\n\nexport default (auth: unknown): Visitor =>\n  async ({ data, key, attribute, schema }) => {\n    if (!attribute) {\n      return;\n    }\n\n    const isRelation = attribute.type === 'relation';\n\n    if (!isRelation) {\n      return;\n    }\n\n    const handleMorphRelation = async () => {\n      for (const element of (data as Record<string, MorphArray>)[key]) {\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n        if (!isAllowed) {\n          throwInvalidParam({ key });\n        }\n      }\n    };\n\n    const handleRegularRelation = async () => {\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\n\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n      // If the authenticated user don't have access to any of the scopes\n      if (!isAllowed) {\n        throwInvalidParam({ key });\n      }\n    };\n\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\n\n    // Polymorphic relations\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\n      await handleMorphRelation();\n      return;\n    }\n\n    // Creator relations\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\n      // do nothing\n      return;\n    }\n\n    // Regular relations\n    await handleRegularRelation();\n  };\n\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\n  for (const scope of scopes) {\n    try {\n      await strapi.auth.verify(auth, { scope });\n      return true;\n    } catch {\n      continue;\n    }\n  }\n\n  return false;\n};\n","import { isMorphToRelationalAttribute } from '../../content-types';\nimport { throwInvalidParam } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }) => {\n  if (isMorphToRelationalAttribute(attribute)) {\n    throwInvalidParam({ key });\n  }\n};\n\nexport default visitor;\n","import { isDynamicZoneAttribute } from '../../content-types';\nimport { throwInvalidParam } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }) => {\n  if (isDynamicZoneAttribute(attribute)) {\n    throwInvalidParam({ key });\n  }\n};\n\nexport default visitor;\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\nimport { throwInvalidParam } from '../utils';\n\nexport default (allowedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }) => {\n    // All fields are allowed\n    if (allowedFields === null) {\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\n      );\n    }\n\n    if (isNil(path)) {\n      return;\n    }\n\n    const containedPaths = getContainedPaths(path);\n\n    /**\n     * Tells if the current path should be kept or not based\n     * on the success of the check functions for any of the allowed paths.\n     *\n     * The check functions are defined as follow:\n     *\n     * `containedPaths.includes(p)`\n     * @example\n     * ```js\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match but isn't handled by this check\n     * ```\n     *\n     * `p.startsWith(`${path}.`)`\n     * @example\n     * ```js\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match but isn't handled by this check\n     * ```\n     */\n    const isPathAllowed = allowedFields.some(\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\n    );\n\n    if (isPathAllowed) {\n      return;\n    }\n\n    // throw otherwise\n    throwInvalidParam({ key });\n  };\n\n/**\n * Retrieve the list of allowed paths based on the given path\n *\n * @example\n * ```js\n * const containedPaths = getContainedPaths('foo');\n * // ['foo']\n *\n *  * const containedPaths = getContainedPaths('foo.bar');\n * // ['foo', 'foo.bar']\n *\n *  * const containedPaths = getContainedPaths('foo.bar.field');\n * // ['foo', 'foo.bar', 'foo.bar.field']\n * ```\n */\nconst getContainedPaths = (path: string) => {\n  const parts = toPath(path);\n\n  return parts.reduce((acc, value, index, list) => {\n    return [...acc, list.slice(0, index + 1).join('.')];\n  }, [] as string[]);\n};\n","import { isArray, isString } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\nimport { throwInvalidParam } from '../utils';\n\nexport default (restrictedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }) => {\n    // all fields\n    if (restrictedFields === null) {\n      throwInvalidParam({ key });\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\n      );\n    }\n\n    // if an exact match was found\n    if (restrictedFields.includes(path as string)) {\n      throwInvalidParam({ key });\n    }\n\n    // nested matches\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\n      path?.toString().startsWith(`${allowedPath}.`)\n    );\n    if (isRestrictedNested) {\n      throwInvalidParam({ key });\n    }\n  };\n","import { curry, isEmpty, isNil } from 'lodash/fp';\n\nimport { pipeAsync } from '../async';\nimport traverseEntity from '../traverse-entity';\nimport { isScalarAttribute } from '../content-types';\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryFields } from '../traverse';\nimport { throwPassword, throwPrivate, throwDynamicZones, throwMorphToRelations } from './visitors';\nimport { isOperator } from '../operators';\nimport { throwInvalidParam } from './utils';\nimport type { Model, Data } from '../types';\n\nconst throwPasswords = (schema: Model) => async (entity: Data) => {\n  if (!schema) {\n    throw new Error('Missing schema in throwPasswords');\n  }\n\n  return traverseEntity(throwPassword, { schema }, entity);\n};\n\nconst defaultValidateFilters = curry((schema: Model, filters: unknown) => {\n  // TODO: schema checks should check that it is a validate schema with yup\n  if (!schema) {\n    throw new Error('Missing schema in defaultValidateFilters');\n  }\n  return pipeAsync(\n    // keys that are not attributes or valid operators\n    traverseQueryFilters(\n      ({ key, attribute }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not removing it\n        if (key === 'id') {\n          return;\n        }\n\n        const isAttribute = !!attribute;\n\n        if (!isAttribute && !isOperator(key)) {\n          throwInvalidParam({ key });\n        }\n      },\n      { schema }\n    ),\n    // dynamic zones from filters\n    traverseQueryFilters(throwDynamicZones, { schema }),\n    // morphTo relations from filters; because you can't have deep filtering on morph relations\n    traverseQueryFilters(throwMorphToRelations, { schema }),\n    // passwords from filters\n    traverseQueryFilters(throwPassword, { schema }),\n    // private from filters\n    traverseQueryFilters(throwPrivate, { schema })\n    // we allow empty objects to validate and only sanitize them out, so that users may write \"lazy\" queries without checking their params exist\n  )(filters);\n});\n\nconst defaultValidateSort = curry((schema: Model, sort: unknown) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultValidateSort');\n  }\n\n  return pipeAsync(\n    // non attribute keys\n    traverseQuerySort(\n      ({ key, attribute }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not removing it\n        if (key === 'id') {\n          return;\n        }\n\n        if (!attribute) {\n          throwInvalidParam({ key });\n        }\n      },\n      { schema }\n    ),\n    // dynamic zones from sort\n    traverseQuerySort(throwDynamicZones, { schema }),\n    // morphTo relations from sort\n    traverseQuerySort(throwMorphToRelations, { schema }),\n    // private from sort\n    traverseQuerySort(throwPrivate, { schema }),\n    // passwords from filters\n    traverseQuerySort(throwPassword, { schema }),\n    // keys for empty non-scalar values\n    traverseQuerySort(\n      ({ key, attribute, value }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not removing it\n        if (key === 'id') {\n          return;\n        }\n\n        if (!isScalarAttribute(attribute) && isEmpty(value)) {\n          throwInvalidParam({ key });\n        }\n      },\n      { schema }\n    )\n  )(sort);\n});\n\nconst defaultValidateFields = curry((schema: Model, fields: unknown) => {\n  if (!schema) {\n    throw new Error('Missing schema in defaultValidateFields');\n  }\n  return pipeAsync(\n    // Only allow scalar attributes\n    traverseQueryFields(\n      ({ key, attribute }) => {\n        // ID is not an attribute per se, so we need to make\n        // an extra check to ensure we're not removing it\n        if (key === 'id') {\n          return;\n        }\n\n        if (isNil(attribute) || !isScalarAttribute(attribute)) {\n          throwInvalidParam({ key });\n        }\n      },\n      { schema }\n    ),\n    // private fields\n    traverseQueryFields(throwPrivate, { schema }),\n    // password fields\n    traverseQueryFields(throwPassword, { schema })\n  )(fields);\n});\n\nexport { throwPasswords, defaultValidateFilters, defaultValidateSort, defaultValidateFields };\n","import { CurriedFunction1 } from 'lodash';\nimport { isArray, isObject } from 'lodash/fp';\n\nimport { getNonWritableAttributes } from '../content-types';\nimport { pipeAsync } from '../async';\nimport { throwInvalidParam } from './utils';\n\nimport * as visitors from './visitors';\nimport * as validators from './validators';\nimport traverseEntity from '../traverse-entity';\n\nimport { traverseQueryFilters, traverseQuerySort } from '../traverse';\n\nimport { Model, Data } from '../types';\n\nexport interface Options {\n  auth?: unknown;\n}\n\ninterface Validator {\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\n}\nexport interface ValidateFunc {\n  (data: unknown, schema: Model, options?: Options): Promise<void>;\n}\n\nconst createContentAPIValidators = () => {\n  const validateInput: ValidateFunc = async (data: unknown, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateInput');\n    }\n\n    if (isArray(data)) {\n      await Promise.all(data.map((entry) => validateInput(entry, schema, { auth })));\n      return;\n    }\n\n    const nonWritableAttributes = getNonWritableAttributes(schema);\n\n    const transforms = [\n      (data: unknown) => {\n        if (isObject(data) && 'id' in data) {\n          throwInvalidParam({ key: 'id' });\n        }\n      },\n      // non-writable attributes\n      traverseEntity(visitors.throwRestrictedFields(nonWritableAttributes), { schema }),\n    ];\n\n    if (auth) {\n      // restricted relations\n      transforms.push(traverseEntity(visitors.throwRestrictedRelations(auth), { schema }));\n    }\n\n    // Apply validators from registry if exists\n    strapi.validators\n      .get('content-api.input')\n      .forEach((validator: Validator) => transforms.push(validator(schema)));\n\n    pipeAsync(...transforms)(data as Data);\n  };\n\n  const validateQuery = async (\n    query: Record<string, unknown>,\n    schema: Model,\n    { auth }: Options = {}\n  ) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateQuery');\n    }\n    const { filters, sort, fields } = query;\n\n    if (filters) {\n      await validateFilters(filters, schema, { auth });\n    }\n\n    if (sort) {\n      await validateSort(sort, schema, { auth });\n    }\n\n    if (fields) {\n      await validateFields(fields, schema);\n    }\n\n    // TODO: validate populate\n  };\n\n  const validateFilters: ValidateFunc = async (filters, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateFilters');\n    }\n    if (isArray(filters)) {\n      await Promise.all(filters.map((filter) => validateFilters(filter, schema, { auth })));\n      return;\n    }\n\n    const transforms = [validators.defaultValidateFilters(schema)];\n\n    if (auth) {\n      transforms.push(traverseQueryFilters(visitors.throwRestrictedRelations(auth), { schema }));\n    }\n\n    return pipeAsync(...transforms)(filters);\n  };\n\n  const validateSort: ValidateFunc = async (sort, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateSort');\n    }\n    const transforms = [validators.defaultValidateSort(schema)];\n\n    if (auth) {\n      transforms.push(traverseQuerySort(visitors.throwRestrictedRelations(auth), { schema }));\n    }\n\n    return pipeAsync(...transforms)(sort);\n  };\n\n  const validateFields: ValidateFunc = (fields, schema: Model) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateFields');\n    }\n    const transforms = [validators.defaultValidateFields(schema)];\n\n    return pipeAsync(...transforms)(fields);\n  };\n\n  return {\n    input: validateInput,\n    query: validateQuery,\n    filters: validateFilters,\n    sort: validateSort,\n    fields: validateFields,\n  };\n};\n\nconst contentAPI = createContentAPIValidators();\n\nexport default {\n  contentAPI,\n  validators,\n  visitors,\n};\n","/* eslint-disable max-classes-per-file */\n\n/**\n * Converts the standard Strapi REST query params to a more usable format for querying\n * You can read more here: https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#filters\n */\n\nimport {\n  isNil,\n  toNumber,\n  isInteger,\n  has,\n  isEmpty,\n  isObject,\n  cloneDeep,\n  get,\n  mergeAll,\n  isArray,\n  isString,\n} from 'lodash/fp';\nimport _ from 'lodash';\nimport parseType from './parse-type';\nimport * as contentTypesUtils from './content-types';\nimport { PaginationError } from './errors';\nimport { isDynamicZoneAttribute, isMorphToRelationalAttribute } from './content-types';\nimport { Model } from './types';\nimport { isOperator } from './operators';\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\n\ntype SortOrder = 'asc' | 'desc';\n\nexport interface SortMap {\n  [key: string]: SortOrder | SortMap;\n}\n\nexport interface SortParamsObject {\n  [key: string]: SortOrder | SortParamsObject;\n}\ntype SortParams = string | string[] | SortParamsObject | SortParamsObject[];\ntype FieldsParams = string | string[];\n\ntype FiltersParams = unknown;\n\nexport interface PopulateAttributesParams {\n  [key: string]: PopulateObjectParams;\n}\nexport interface PopulateObjectParams {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: PopulateParams;\n  publicationState?: 'live' | 'preview';\n  on: PopulateAttributesParams;\n}\n\ntype PopulateParams = string | string[] | PopulateAttributesParams;\n\nexport interface Params {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: PopulateParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n  publicationState?: 'live' | 'preview';\n}\n\ntype FiltersQuery = (options: { meta: Model }) => WhereQuery | undefined;\ntype OrderByQuery = SortMap | SortMap[];\ntype SelectQuery = string | string[];\nexport interface WhereQuery {\n  [key: string]: any;\n}\n\ntype PopulateQuery =\n  | boolean\n  | string[]\n  | {\n      [key: string]: PopulateQuery;\n    };\n\nexport interface Query {\n  orderBy?: OrderByQuery;\n  select?: SelectQuery;\n  where?: WhereQuery;\n  // NOTE: those are internal DB filters do not modify\n  filters?: FiltersQuery;\n  populate?: PopulateQuery;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number;\n  offset?: number;\n  page?: number;\n  pageSize?: number;\n}\n\nclass InvalidOrderError extends Error {\n  constructor() {\n    super();\n    this.message = 'Invalid order. order can only be one of asc|desc|ASC|DESC';\n  }\n}\nclass InvalidSortError extends Error {\n  constructor() {\n    super();\n    this.message =\n      'Invalid sort parameter. Expected a string, an array of strings, a sort object or an array of sort objects';\n  }\n}\n\nfunction validateOrder(order: string): asserts order is SortOrder {\n  if (!isString(order) || !['asc', 'desc'].includes(order.toLocaleLowerCase())) {\n    throw new InvalidOrderError();\n  }\n}\n\nconst convertCountQueryParams = (countQuery: unknown): boolean => {\n  return parseType({ type: 'boolean', value: countQuery });\n};\n\nconst convertOrderingQueryParams = (ordering: unknown) => {\n  return ordering;\n};\n\nconst isPlainObject = (value: unknown): value is Record<string, unknown> => _.isPlainObject(value);\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\n/**\n * Sort query parser\n */\nconst convertSortQueryParams = (sortQuery: SortParams): OrderByQuery => {\n  if (typeof sortQuery === 'string') {\n    return convertStringSortQueryParam(sortQuery);\n  }\n\n  if (isStringArray(sortQuery)) {\n    return sortQuery.flatMap((sortValue: string) => convertStringSortQueryParam(sortValue));\n  }\n\n  if (Array.isArray(sortQuery)) {\n    return sortQuery.map((sortValue) => convertNestedSortQueryParam(sortValue));\n  }\n\n  if (isPlainObject(sortQuery)) {\n    return convertNestedSortQueryParam(sortQuery);\n  }\n\n  throw new InvalidSortError();\n};\n\nconst convertStringSortQueryParam = (sortQuery: string): SortMap[] => {\n  return sortQuery.split(',').map((value) => convertSingleSortQueryParam(value));\n};\n\nconst convertSingleSortQueryParam = (sortQuery: string): SortMap => {\n  if (!sortQuery) {\n    return {};\n  }\n\n  if (!isString(sortQuery)) {\n    throw new Error('Invalid sort query');\n  }\n\n  // split field and order param with default order to ascending\n  const [field, order = 'asc'] = sortQuery.split(':');\n\n  if (field.length === 0) {\n    throw new Error('Field cannot be empty');\n  }\n\n  validateOrder(order);\n\n  // TODO: field should be a valid path on an object model\n\n  return _.set({}, field, order);\n};\n\nconst convertNestedSortQueryParam = (sortQuery: SortParamsObject): SortMap => {\n  const transformedSort: SortMap = {};\n  for (const field of Object.keys(sortQuery)) {\n    const order = sortQuery[field];\n\n    // this is a deep sort\n    if (isPlainObject(order)) {\n      transformedSort[field] = convertNestedSortQueryParam(order);\n    } else if (typeof order === 'string') {\n      validateOrder(order);\n      transformedSort[field] = order;\n    } else {\n      throw Error(`Invalid sort type expected object or string got ${typeof order}`);\n    }\n  }\n\n  return transformedSort;\n};\n\n/**\n * Start query parser\n */\nconst convertStartQueryParams = (startQuery: unknown): number => {\n  const startAsANumber = _.toNumber(startQuery);\n\n  if (!_.isInteger(startAsANumber) || startAsANumber < 0) {\n    throw new Error(`convertStartQueryParams expected a positive integer got ${startAsANumber}`);\n  }\n\n  return startAsANumber;\n};\n\n/**\n * Limit query parser\n */\nconst convertLimitQueryParams = (limitQuery: unknown): number | undefined => {\n  const limitAsANumber = _.toNumber(limitQuery);\n\n  if (!_.isInteger(limitAsANumber) || (limitAsANumber !== -1 && limitAsANumber < 0)) {\n    throw new Error(`convertLimitQueryParams expected a positive integer got ${limitAsANumber}`);\n  }\n\n  if (limitAsANumber === -1) {\n    return undefined;\n  }\n\n  return limitAsANumber;\n};\n\nconst convertPageQueryParams = (page: unknown): number => {\n  const pageVal = toNumber(page);\n\n  if (!isInteger(pageVal) || pageVal <= 0) {\n    throw new PaginationError(\n      `Invalid 'page' parameter. Expected an integer > 0, received: ${page}`\n    );\n  }\n\n  return pageVal;\n};\n\nconst convertPageSizeQueryParams = (pageSize: unknown, page: unknown): number => {\n  const pageSizeVal = toNumber(pageSize);\n\n  if (!isInteger(pageSizeVal) || pageSizeVal <= 0) {\n    throw new PaginationError(\n      `Invalid 'pageSize' parameter. Expected an integer > 0, received: ${page}`\n    );\n  }\n\n  return pageSizeVal;\n};\n\nconst validatePaginationParams = (\n  page: unknown,\n  pageSize: unknown,\n  start: unknown,\n  limit: unknown\n) => {\n  const isPagePagination = !isNil(page) || !isNil(pageSize);\n  const isOffsetPagination = !isNil(start) || !isNil(limit);\n\n  if (isPagePagination && isOffsetPagination) {\n    throw new PaginationError(\n      'Invalid pagination attributes. You cannot use page and offset pagination in the same query'\n    );\n  }\n};\n\nclass InvalidPopulateError extends Error {\n  constructor() {\n    super();\n    this.message =\n      'Invalid populate parameter. Expected a string, an array of strings, a populate object';\n  }\n}\n\n// NOTE: we could support foo.* or foo.bar.* etc later on\nconst convertPopulateQueryParams = (\n  populate: PopulateParams,\n  schema?: Model,\n  depth = 0\n): PopulateQuery => {\n  if (depth === 0 && populate === '*') {\n    return true;\n  }\n\n  if (typeof populate === 'string') {\n    return populate.split(',').map((value) => _.trim(value));\n  }\n\n  if (Array.isArray(populate)) {\n    // map convert\n    return _.uniq(\n      populate.flatMap((value) => {\n        if (typeof value !== 'string') {\n          throw new InvalidPopulateError();\n        }\n\n        return value.split(',').map((value) => _.trim(value));\n      })\n    );\n  }\n\n  if (_.isPlainObject(populate)) {\n    return convertPopulateObject(populate, schema);\n  }\n\n  throw new InvalidPopulateError();\n};\n\nconst convertPopulateObject = (populate: PopulateAttributesParams, schema?: Model) => {\n  if (!schema) {\n    return {};\n  }\n\n  const { attributes } = schema;\n\n  return Object.entries(populate).reduce((acc, [key, subPopulate]) => {\n    const attribute = attributes[key];\n\n    if (!attribute) {\n      return acc;\n    }\n\n    // Allow adding an 'on' strategy to populate queries for morphTo relations and dynamic zones\n    const isAllowedAttributeForFragmentPopulate =\n      isDynamicZoneAttribute(attribute) || isMorphToRelationalAttribute(attribute);\n\n    const hasFragmentPopulateDefined =\n      typeof subPopulate === 'object' && 'on' in subPopulate && !isNil(subPopulate.on);\n\n    if (isAllowedAttributeForFragmentPopulate && hasFragmentPopulateDefined) {\n      return {\n        ...acc,\n        [key]: {\n          on: Object.entries(subPopulate.on).reduce(\n            (acc, [type, typeSubPopulate]) => ({\n              ...acc,\n              [type]: convertNestedPopulate(typeSubPopulate, strapi.getModel(type)),\n            }),\n            {}\n          ),\n        },\n      };\n    }\n\n    // TODO: This is a query's populate fallback for DynamicZone and is kept for legacy purpose.\n    //       Removing it could break existing user queries but it should be removed in V5.\n    if (isDynamicZoneAttribute(attribute)) {\n      const populates = attribute.components\n        .map((uid) => strapi.getModel(uid))\n        .map((schema) => convertNestedPopulate(subPopulate, schema))\n        .map((populate) => (populate === true ? {} : populate)) // cast boolean to empty object to avoid merging issues\n        .filter((populate) => populate !== false);\n\n      if (isEmpty(populates)) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [key]: mergeAll(populates),\n      };\n    }\n\n    if (isMorphToRelationalAttribute(attribute)) {\n      return { ...acc, [key]: convertNestedPopulate(subPopulate, undefined) };\n    }\n\n    // NOTE: Retrieve the target schema UID.\n    // Only handles basic relations, medias and component since it's not possible\n    // to populate with options for a dynamic zone or a polymorphic relation\n    let targetSchemaUID;\n\n    if (attribute.type === 'relation') {\n      targetSchemaUID = attribute.target;\n    } else if (attribute.type === 'component') {\n      targetSchemaUID = attribute.component;\n    } else if (attribute.type === 'media') {\n      targetSchemaUID = 'plugin::upload.file';\n    } else {\n      return acc;\n    }\n\n    const targetSchema = strapi.getModel(targetSchemaUID);\n\n    // ignore the sub-populate for the current key if there is no schema associated\n    if (!targetSchema) {\n      return acc;\n    }\n\n    const populateObject = convertNestedPopulate(subPopulate, targetSchema);\n\n    if (!populateObject) {\n      return acc;\n    }\n\n    return {\n      ...acc,\n      [key]: populateObject,\n    };\n  }, {});\n};\n\nconst convertNestedPopulate = (subPopulate: PopulateObjectParams, schema?: Model) => {\n  if (_.isString(subPopulate)) {\n    return parseType({ type: 'boolean', value: subPopulate, forceCast: true });\n  }\n\n  if (_.isBoolean(subPopulate)) {\n    return subPopulate;\n  }\n\n  if (!isPlainObject(subPopulate)) {\n    throw new Error(`Invalid nested populate. Expected '*' or an object`);\n  }\n\n  const { sort, filters, fields, populate, count, ordering, page, pageSize, start, limit } =\n    subPopulate;\n\n  const query: Query = {};\n\n  if (sort) {\n    query.orderBy = convertSortQueryParams(sort);\n  }\n\n  if (filters) {\n    query.where = convertFiltersQueryParams(filters, schema);\n  }\n\n  if (fields) {\n    query.select = convertFieldsQueryParams(fields);\n  }\n\n  if (populate) {\n    query.populate = convertPopulateQueryParams(populate, schema);\n  }\n\n  if (count) {\n    query.count = convertCountQueryParams(count);\n  }\n\n  if (ordering) {\n    query.ordering = convertOrderingQueryParams(ordering);\n  }\n\n  validatePaginationParams(page, pageSize, start, limit);\n\n  if (!isNil(page)) {\n    query.page = convertPageQueryParams(page);\n  }\n\n  if (!isNil(pageSize)) {\n    query.pageSize = convertPageSizeQueryParams(pageSize, page);\n  }\n\n  if (!isNil(start)) {\n    query.offset = convertStartQueryParams(start);\n  }\n\n  if (!isNil(limit)) {\n    query.limit = convertLimitQueryParams(limit);\n  }\n\n  convertPublicationStateParams(schema, subPopulate, query);\n\n  return query;\n};\n\n// TODO: ensure field is valid in content types (will probably have to check strapi.contentTypes since it can be a string.path)\nconst convertFieldsQueryParams = (fields: FieldsParams, depth = 0): SelectQuery | undefined => {\n  if (depth === 0 && fields === '*') {\n    return undefined;\n  }\n\n  if (typeof fields === 'string') {\n    const fieldsValues = fields.split(',').map((value) => _.trim(value));\n    return _.uniq(['id', ...fieldsValues]);\n  }\n\n  if (isStringArray(fields)) {\n    // map convert\n    const fieldsValues = fields\n      .flatMap((value) => convertFieldsQueryParams(value, depth + 1))\n      .filter((v) => !isNil(v)) as string[];\n\n    return _.uniq(['id', ...fieldsValues]);\n  }\n\n  throw new Error('Invalid fields parameter. Expected a string or an array of strings');\n};\n\nconst isValidSchemaAttribute = (key: string, schema?: Model) => {\n  if (key === 'id') {\n    return true;\n  }\n\n  if (!schema) {\n    return false;\n  }\n\n  return Object.keys(schema.attributes).includes(key);\n};\n\nconst convertFiltersQueryParams = (filters: FiltersParams, schema?: Model): WhereQuery => {\n  // Filters need to be either an array or an object\n  // Here we're only checking for 'object' type since typeof [] => object and typeof {} => object\n  if (!isObject(filters)) {\n    throw new Error('The filters parameter must be an object or an array');\n  }\n\n  // Don't mutate the original object\n  const filtersCopy = cloneDeep(filters);\n\n  return convertAndSanitizeFilters(filtersCopy, schema);\n};\n\nconst convertAndSanitizeFilters = (filters: FiltersParams, schema?: Model): WhereQuery => {\n  if (Array.isArray(filters)) {\n    return (\n      filters\n        // Sanitize each filter\n        .map((filter) => convertAndSanitizeFilters(filter, schema))\n        // Filter out empty filters\n        .filter((filter) => !isPlainObject(filter) || !isEmpty(filter))\n    );\n  }\n\n  if (!isPlainObject(filters)) {\n    return filters as WhereQuery;\n  }\n\n  const removeOperator = (operator: string) => delete filters[operator];\n\n  // Here, `key` can either be an operator or an attribute name\n  for (const [key, value] of Object.entries(filters)) {\n    const attribute = get(key, schema?.attributes);\n    const validKey = isOperator(key) || isValidSchemaAttribute(key, schema);\n\n    if (!validKey) {\n      removeOperator(key);\n    }\n    // Handle attributes\n    else if (attribute) {\n      // Relations\n      if (attribute.type === 'relation') {\n        filters[key] = convertAndSanitizeFilters(value, strapi.getModel(attribute.target));\n      }\n\n      // Components\n      else if (attribute.type === 'component') {\n        filters[key] = convertAndSanitizeFilters(value, strapi.getModel(attribute.component));\n      }\n\n      // Media\n      else if (attribute.type === 'media') {\n        filters[key] = convertAndSanitizeFilters(value, strapi.getModel('plugin::upload.file'));\n      }\n\n      // Dynamic Zones\n      else if (attribute.type === 'dynamiczone') {\n        removeOperator(key);\n      }\n\n      // Password attributes\n      else if (attribute.type === 'password') {\n        // Always remove password attributes from filters object\n        removeOperator(key);\n      }\n\n      // Scalar attributes\n      else {\n        filters[key] = convertAndSanitizeFilters(value, schema);\n      }\n    }\n\n    // Handle operators\n    else if (['$null', '$notNull'].includes(key)) {\n      filters[key] = parseType({ type: 'boolean', value: filters[key], forceCast: true });\n    } else if (isObject(value)) {\n      filters[key] = convertAndSanitizeFilters(value, schema);\n    }\n\n    // Remove empty objects & arrays\n    if (isPlainObject(filters[key]) && isEmpty(filters[key])) {\n      removeOperator(key);\n    }\n  }\n\n  return filters;\n};\n\nconst convertPublicationStateParams = (\n  schema?: Model,\n  params: { publicationState?: 'live' | 'preview' } = {},\n  query: Query = {}\n) => {\n  if (!schema) {\n    return;\n  }\n\n  const { publicationState } = params;\n\n  if (!_.isNil(publicationState)) {\n    if (!contentTypesUtils.constants.DP_PUB_STATES.includes(publicationState)) {\n      throw new Error(\n        `Invalid publicationState. Expected one of 'preview','live' received: ${publicationState}.`\n      );\n    }\n\n    // NOTE: this is the query layer filters not the entity service filters\n    query.filters = ({ meta }: { meta: Model }) => {\n      if (publicationState === 'live' && has(PUBLISHED_AT_ATTRIBUTE, meta.attributes)) {\n        return { [PUBLISHED_AT_ATTRIBUTE]: { $notNull: true } };\n      }\n    };\n  }\n};\n\nconst transformParamsToQuery = (uid: string, params: Params): Query => {\n  // NOTE: can be a CT, a Compo or nothing in the case of polymorphism (DZ & morph relations)\n  const schema = strapi.getModel(uid);\n\n  const query: Query = {};\n\n  const { _q, sort, filters, fields, populate, page, pageSize, start, limit } = params;\n\n  if (!isNil(_q)) {\n    query._q = _q;\n  }\n\n  if (!isNil(sort)) {\n    query.orderBy = convertSortQueryParams(sort);\n  }\n\n  if (!isNil(filters)) {\n    query.where = convertFiltersQueryParams(filters, schema);\n  }\n\n  if (!isNil(fields)) {\n    query.select = convertFieldsQueryParams(fields);\n  }\n\n  if (!isNil(populate)) {\n    query.populate = convertPopulateQueryParams(populate, schema);\n  }\n\n  validatePaginationParams(page, pageSize, start, limit);\n\n  if (!isNil(page)) {\n    query.page = convertPageQueryParams(page);\n  }\n\n  if (!isNil(pageSize)) {\n    query.pageSize = convertPageSizeQueryParams(pageSize, page);\n  }\n\n  if (!isNil(start)) {\n    query.offset = convertStartQueryParams(start);\n  }\n\n  if (!isNil(limit)) {\n    query.limit = convertLimitQueryParams(limit);\n  }\n\n  convertPublicationStateParams(schema, params, query);\n\n  return query;\n};\n\nexport default {\n  convertSortQueryParams,\n  convertStartQueryParams,\n  convertLimitQueryParams,\n  convertPopulateQueryParams,\n  convertFiltersQueryParams,\n  convertFieldsQueryParams,\n  convertPublicationStateParams,\n  transformParamsToQuery,\n};\n","/* eslint-disable @typescript-eslint/no-var-requires */\n\nexport default function importDefault(modName: string) {\n  const mod = require(modName);\n  return mod && mod.__esModule ? mod.default : mod;\n}\n","/**\n * Create a strict interpolation RegExp based on the given variables' name\n */\nconst createStrictInterpolationRegExp = (allowedVariableNames: string[], flags: string) => {\n  const oneOfVariables = allowedVariableNames.join('|');\n\n  // 1. We need to match the delimiters: <%= ... %>\n  // 2. We accept any number of whitespaces characters before and/or after the variable name: \\s* ... \\s*\n  // 3. We only accept values from the variable list as interpolation variables' name: : (${oneOfVariables})\n  return new RegExp(`<%=\\\\s*(${oneOfVariables})\\\\s*%>`, flags);\n};\n\n/**\n * Create a loose interpolation RegExp to match as many groups as possible\n */\nconst createLooseInterpolationRegExp = (flags: string) => new RegExp(/<%=([\\s\\S]+?)%>/, flags);\n\nexport { createStrictInterpolationRegExp, createLooseInterpolationRegExp };\n","/**\n * Utils file containing file treatment utils\n */\nimport { Readable, Writable, WritableOptions } from 'node:stream';\n\nconst kbytesToBytes = (kbytes: number) => kbytes * 1000;\nconst bytesToKbytes = (bytes: number) => Math.round((bytes / 1000) * 100) / 100;\nconst bytesToHumanReadable = (bytes: number) => {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  if (bytes === 0) return '0 Bytes';\n  const i = parseInt(`${Math.floor(Math.log(bytes) / Math.log(1000))}`, 10);\n  return `${Math.round(bytes / 1000 ** i)} ${sizes[i]}`;\n};\n\nconst streamToBuffer = (stream: Readable) =>\n  new Promise((resolve, reject) => {\n    const chunks: Uint8Array[] = [];\n    stream.on('data', (chunk) => {\n      chunks.push(chunk);\n    });\n    stream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on('error', reject);\n  });\n\nconst getStreamSize = (stream: Readable) =>\n  new Promise((resolve, reject) => {\n    let size = 0;\n    stream.on('data', (chunk) => {\n      size += Buffer.byteLength(chunk);\n    });\n    stream.on('close', () => resolve(size));\n    stream.on('error', reject);\n    stream.resume();\n  });\n\n/**\n * Create a writeable Node.js stream that discards received data.\n * Useful for testing, draining a stream of data, etc.\n */\nfunction writableDiscardStream(options: WritableOptions) {\n  return new Writable({\n    ...options,\n    write(chunk, encding, callback) {\n      setImmediate(callback);\n    },\n  });\n}\n\nexport {\n  streamToBuffer,\n  bytesToHumanReadable,\n  bytesToKbytes,\n  kbytesToBytes,\n  getStreamSize,\n  writableDiscardStream,\n};\n","const webhookEvents = {\n  ENTRY_CREATE: 'entry.create',\n  ENTRY_UPDATE: 'entry.update',\n  ENTRY_DELETE: 'entry.delete',\n  ENTRY_PUBLISH: 'entry.publish',\n  ENTRY_UNPUBLISH: 'entry.unpublish',\n  MEDIA_CREATE: 'media.create',\n  MEDIA_UPDATE: 'media.update',\n  MEDIA_DELETE: 'media.delete',\n};\n\ntype WebhookEvents = Record<string, string>;\n\n/**\n * TODO V5: remove this file\n * @deprecated\n */\nconst deprecatedWebhookEvents = new Proxy<WebhookEvents>(webhookEvents, {\n  get(target, prop: string) {\n    console.warn(\n      '[deprecated] @strapi/utils/webhook will no longer exist in the next major release of Strapi. ' +\n        'Instead, the webhookEvents object can be retrieved from strapi.webhookStore.allowedEvents'\n    );\n    return target[prop];\n  },\n});\n\nexport default {\n  webhookEvents: deprecatedWebhookEvents,\n};\n"],"names":["acc","key","_","value","policy","isObj","isPlainObject","errors","yup","index","trim","result","isCamelCase","utils.isCamelCase","isKebabCase","utils.isKebabCase","obj","PUBLISHED_AT_ATTRIBUTE","CREATED_BY_ATTRIBUTE","UPDATED_BY_ATTRIBUTE","constants","contentTypes.constants","filters","pagination","defaults","visitor","remove","ACTIONS_TO_VERIFY","contentTypeUtils.constants","hasAccessToSomeScopes","contentTypeUtils.isMorphToRelationalAttribute","isString","getContainedPaths","i","parser","utils","isStringArray","sort","populate","newValue","fields","traverseEntity","removePassword","removePrivate","removeDynamicZones","removeMorphToRelations","schema","visitors.removeRestrictedFields","visitors.removeRestrictedRelations","data","sanitizers.defaultSanitizeOutput","sanitizers.defaultSanitizeFilters","sanitizers.defaultSanitizeSort","sanitizers.defaultSanitizeFields","sanitizers.defaultSanitizePopulate","contentAPI","visitors","throwPassword","throwDynamicZones","throwMorphToRelations","throwPrivate","visitors.throwRestrictedFields","visitors.throwRestrictedRelations","validators.defaultValidateFilters","validators.defaultValidateSort","validators.defaultValidateFields","contentTypesUtils.constants"],"mappings":"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"}