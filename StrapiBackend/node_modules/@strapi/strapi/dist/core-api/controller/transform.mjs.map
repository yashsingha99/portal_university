{"version":3,"file":"transform.mjs","sources":["../../../src/core-api/controller/transform.ts"],"sourcesContent":["import { isNil, isPlainObject } from 'lodash/fp';\nimport { parseMultipartData } from '@strapi/utils';\nimport type Koa from 'koa';\nimport type { Common, Schema, UID } from '@strapi/types';\n\ntype TransformedEntry = {\n  id: string;\n  attributes: Record<string, unknown>;\n  meta?: Record<string, unknown>;\n};\n\ntype TransformedComponent = {\n  id: string;\n  [key: string]: unknown;\n};\n\ntype Entry = {\n  id: string;\n  [key: string]: Entry | Entry[] | string | number | null | boolean | Date;\n};\n\nfunction isEntry(property: unknown): property is Entry | Entry[] {\n  return property === null || isPlainObject(property) || Array.isArray(property);\n}\n\nfunction isDZEntries(property: unknown): property is (Entry & { __component: UID.Component })[] {\n  return Array.isArray(property);\n}\n\nconst parseBody = (ctx: Koa.Context) => {\n  if (ctx.is('multipart')) {\n    return parseMultipartData(ctx);\n  }\n\n  const { data } = ctx.request.body || {};\n\n  return { data };\n};\n\nconst transformResponse = (\n  resource: any,\n  meta: unknown = {},\n  opts: { contentType?: Schema.ContentType | Schema.Component } = {}\n) => {\n  if (isNil(resource)) {\n    return resource;\n  }\n\n  return {\n    data: transformEntry(resource, opts?.contentType),\n    meta,\n  };\n};\n\nfunction transformComponent<T extends Entry | Entry[] | null>(\n  data: T,\n  component: Schema.Component\n): T extends Entry[] ? TransformedComponent[] : T extends Entry ? TransformedComponent : null;\nfunction transformComponent(\n  data: Entry | Entry[] | null,\n  component: Schema.Component\n): TransformedComponent | TransformedComponent[] | null {\n  if (Array.isArray(data)) {\n    return data.map((datum) => transformComponent(datum, component));\n  }\n\n  const res = transformEntry(data, component);\n\n  if (isNil(res)) {\n    return res;\n  }\n\n  const { id, attributes } = res;\n  return { id, ...attributes };\n}\n\nfunction transformEntry<T extends Entry | Entry[] | null>(\n  entry: T,\n  type?: Schema.ContentType | Schema.Component\n): T extends Entry[] ? TransformedEntry[] : T extends Entry ? TransformedEntry : null;\nfunction transformEntry(\n  entry: Entry | Entry[] | null,\n  type?: Schema.ContentType | Schema.Component\n): TransformedEntry | TransformedEntry[] | null {\n  if (isNil(entry)) {\n    return entry;\n  }\n\n  if (Array.isArray(entry)) {\n    return entry.map((singleEntry) => transformEntry(singleEntry, type));\n  }\n\n  if (!isPlainObject(entry)) {\n    throw new Error('Entry must be an object');\n  }\n\n  const { id, ...properties } = entry;\n\n  const attributeValues: Record<string, unknown> = {};\n\n  for (const key of Object.keys(properties)) {\n    const property = properties[key];\n    const attribute = type && type.attributes[key];\n\n    if (attribute && attribute.type === 'relation' && isEntry(property) && 'target' in attribute) {\n      const data = transformEntry(\n        property,\n        strapi.contentType(attribute.target as Common.UID.ContentType)\n      );\n\n      attributeValues[key] = { data };\n    } else if (attribute && attribute.type === 'component' && isEntry(property)) {\n      attributeValues[key] = transformComponent(property, strapi.components[attribute.component]);\n    } else if (attribute && attribute.type === 'dynamiczone' && isDZEntries(property)) {\n      if (isNil(property)) {\n        attributeValues[key] = property;\n      }\n\n      attributeValues[key] = property.map((subProperty) => {\n        return transformComponent(subProperty, strapi.components[subProperty.__component]);\n      });\n    } else if (attribute && attribute.type === 'media' && isEntry(property)) {\n      const data = transformEntry(property, strapi.contentType('plugin::upload.file'));\n\n      attributeValues[key] = { data };\n    } else {\n      attributeValues[key] = property;\n    }\n  }\n\n  return {\n    id,\n    attributes: attributeValues,\n    // NOTE: not necessary for now\n    // meta: {},\n  };\n}\n\nexport { parseBody, transformResponse };\n"],"names":[],"mappings":";;AAqBA,SAAS,QAAQ,UAAgD;AAC/D,SAAO,aAAa,QAAQ,cAAc,QAAQ,KAAK,MAAM,QAAQ,QAAQ;AAC/E;AAEA,SAAS,YAAY,UAA2E;AACvF,SAAA,MAAM,QAAQ,QAAQ;AAC/B;AAEM,MAAA,YAAY,CAAC,QAAqB;AAClC,MAAA,IAAI,GAAG,WAAW,GAAG;AACvB,WAAO,mBAAmB,GAAG;AAAA,EAC/B;AAEA,QAAM,EAAE,KAAK,IAAI,IAAI,QAAQ,QAAQ,CAAA;AAErC,SAAO,EAAE,KAAK;AAChB;AAEM,MAAA,oBAAoB,CACxB,UACA,OAAgB,CAAA,GAChB,OAAgE,CAAA,MAC7D;AACC,MAAA,MAAM,QAAQ,GAAG;AACZ,WAAA;AAAA,EACT;AAEO,SAAA;AAAA,IACL,MAAM,eAAe,UAAU,MAAM,WAAW;AAAA,IAChD;AAAA,EAAA;AAEJ;AAMA,SAAS,mBACP,MACA,WACsD;AAClD,MAAA,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAO,KAAK,IAAI,CAAC,UAAU,mBAAmB,OAAO,SAAS,CAAC;AAAA,EACjE;AAEM,QAAA,MAAM,eAAe,MAAM,SAAS;AAEtC,MAAA,MAAM,GAAG,GAAG;AACP,WAAA;AAAA,EACT;AAEM,QAAA,EAAE,IAAI,WAAe,IAAA;AACpB,SAAA,EAAE,IAAI,GAAG;AAClB;AAMA,SAAS,eACP,OACA,MAC8C;AAC1C,MAAA,MAAM,KAAK,GAAG;AACT,WAAA;AAAA,EACT;AAEI,MAAA,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,MAAM,IAAI,CAAC,gBAAgB,eAAe,aAAa,IAAI,CAAC;AAAA,EACrE;AAEI,MAAA,CAAC,cAAc,KAAK,GAAG;AACnB,UAAA,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAEA,QAAM,EAAE,IAAI,GAAG,WAAA,IAAe;AAE9B,QAAM,kBAA2C,CAAA;AAEjD,aAAW,OAAO,OAAO,KAAK,UAAU,GAAG;AACnC,UAAA,WAAW,WAAW,GAAG;AAC/B,UAAM,YAAY,QAAQ,KAAK,WAAW,GAAG;AAEzC,QAAA,aAAa,UAAU,SAAS,cAAc,QAAQ,QAAQ,KAAK,YAAY,WAAW;AAC5F,YAAM,OAAO;AAAA,QACX;AAAA,QACA,OAAO,YAAY,UAAU,MAAgC;AAAA,MAAA;AAG/C,sBAAA,GAAG,IAAI,EAAE;IAAK,WACrB,aAAa,UAAU,SAAS,eAAe,QAAQ,QAAQ,GAAG;AAC3D,sBAAA,GAAG,IAAI,mBAAmB,UAAU,OAAO,WAAW,UAAU,SAAS,CAAC;AAAA,IAAA,WACjF,aAAa,UAAU,SAAS,iBAAiB,YAAY,QAAQ,GAAG;AAC7E,UAAA,MAAM,QAAQ,GAAG;AACnB,wBAAgB,GAAG,IAAI;AAAA,MACzB;AAEA,sBAAgB,GAAG,IAAI,SAAS,IAAI,CAAC,gBAAgB;AACnD,eAAO,mBAAmB,aAAa,OAAO,WAAW,YAAY,WAAW,CAAC;AAAA,MAAA,CAClF;AAAA,IAAA,WACQ,aAAa,UAAU,SAAS,WAAW,QAAQ,QAAQ,GAAG;AACvE,YAAM,OAAO,eAAe,UAAU,OAAO,YAAY,qBAAqB,CAAC;AAE/D,sBAAA,GAAG,IAAI,EAAE;IAAK,OACzB;AACL,sBAAgB,GAAG,IAAI;AAAA,IACzB;AAAA,EACF;AAEO,SAAA;AAAA,IACL;AAAA,IACA,YAAY;AAAA;AAAA;AAAA,EAAA;AAIhB;"}