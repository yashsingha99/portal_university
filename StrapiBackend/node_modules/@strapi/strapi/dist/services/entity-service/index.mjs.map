{"version":3,"file":"index.mjs","sources":["../../../src/services/entity-service/index.ts"],"sourcesContent":["import _ from 'lodash';\nimport delegate from 'delegates';\nimport { errors as databaseErrors } from '@strapi/database';\nimport {\n  contentTypes as contentTypesUtils,\n  sanitize,\n  errors,\n  relations as relationUtils,\n  convertQueryParams,\n} from '@strapi/utils';\nimport type { Database } from '@strapi/database';\nimport type {\n  Strapi,\n  EntityService,\n  EntityValidator,\n  EventHub,\n  Common,\n  Schema,\n  Shared,\n  Utils,\n} from '@strapi/types';\n\nimport uploadFiles from '../utils/upload-files';\n\nimport {\n  omitComponentData,\n  getComponents,\n  createComponents,\n  updateComponents,\n  deleteComponents,\n  cloneComponents,\n} from './components';\n\nimport { pickSelectionParams } from './params';\nimport { applyTransforms } from './attributes';\n\nconst { transformParamsToQuery } = convertQueryParams;\n\ntype Decoratable<T> = T & {\n  decorate(\n    decorator: (old: EntityService.EntityService) => EntityService.EntityService & {\n      [key: string]: unknown;\n    }\n  ): void;\n};\n\ntype Context = {\n  contentType: Schema.ContentType;\n};\n\nconst transformLoadParamsToQuery = (\n  uid: string,\n  field: string,\n  params: Record<string, unknown>,\n  pagination = {}\n) => {\n  const query = transformParamsToQuery(uid, { populate: { [field]: params } as any }) as any;\n\n  const res = {\n    ...query.populate[field],\n    ...pagination,\n  };\n\n  return res;\n};\n\nconst databaseErrorsToTransform = [\n  databaseErrors.InvalidTimeError,\n  databaseErrors.InvalidDateTimeError,\n  databaseErrors.InvalidDateError,\n  databaseErrors.InvalidRelationError,\n];\n\nconst creationPipeline = (data: Record<string, unknown>, context: Context) => {\n  return applyTransforms(data, context);\n};\n\nconst updatePipeline = (data: Record<string, unknown>, context: Context) => {\n  return applyTransforms(data, context);\n};\n\nconst ALLOWED_WEBHOOK_EVENTS = {\n  ENTRY_CREATE: 'entry.create',\n  ENTRY_UPDATE: 'entry.update',\n  ENTRY_DELETE: 'entry.delete',\n};\n\nconst createDefaultImplementation = ({\n  strapi,\n  db,\n  eventHub,\n  entityValidator,\n}: {\n  strapi: Strapi;\n  db: Database;\n  eventHub: EventHub;\n  entityValidator: EntityValidator;\n}): EntityService.EntityService => ({\n  /**\n   * Upload files utility\n   */\n  uploadFiles,\n\n  async wrapParams(options: any = {}) {\n    return options;\n  },\n\n  async wrapResult(result: any = {}) {\n    return result;\n  },\n\n  async emitEvent(uid, event: string, entity) {\n    // Ignore audit log events to prevent infinite loops\n    if (uid === ('admin::audit-log' as Common.UID.ContentType)) {\n      return;\n    }\n\n    const model = strapi.getModel(uid);\n    const sanitizedEntity = await sanitize.sanitizers.defaultSanitizeOutput(model, entity);\n\n    eventHub.emit(event, {\n      model: model.modelName,\n      uid: model.uid,\n      entry: sanitizedEntity,\n    });\n  },\n\n  async findMany(uid, opts) {\n    const { kind } = strapi.getModel(uid);\n\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findMany' });\n\n    const query = transformParamsToQuery(uid, wrappedParams);\n\n    if (kind === 'singleType') {\n      const entity = db.query(uid).findOne(query);\n      return this.wrapResult(entity, { uid, action: 'findOne' });\n    }\n\n    const entities = await db.query(uid).findMany(query);\n    return this.wrapResult(entities, { uid, action: 'findMany' });\n  },\n\n  async findPage(uid, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findPage' });\n\n    const query = transformParamsToQuery(uid, wrappedParams);\n\n    const page = await db.query(uid).findPage(query);\n    return {\n      ...page,\n      results: await this.wrapResult(page.results, { uid, action: 'findPage' }),\n    };\n  },\n\n  // TODO: streamline the logic based on the populate option\n  async findWithRelationCountsPage(uid, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findWithRelationCounts' });\n\n    const query = transformParamsToQuery(uid, wrappedParams);\n\n    const entities = await db.query(uid).findPage(query);\n    return {\n      ...entities,\n      results: await this.wrapResult(entities.results, { uid, action: 'findWithRelationCounts' }),\n    };\n  },\n\n  async findWithRelationCounts(uid, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findWithRelationCounts' });\n\n    const query = transformParamsToQuery(uid, wrappedParams);\n\n    const entities = await db.query(uid).findMany(query);\n    return this.wrapResult(entities, { uid, action: 'findWithRelationCounts' });\n  },\n\n  async findOne(uid, entityId, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findOne' });\n\n    const query = transformParamsToQuery(uid, pickSelectionParams(wrappedParams));\n\n    const entity = await db.query(uid).findOne({ ...query, where: { id: entityId } });\n    return this.wrapResult(entity, { uid, action: 'findOne' });\n  },\n\n  async count(uid, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'count' });\n\n    const query = transformParamsToQuery(uid, wrappedParams);\n\n    return db.query(uid).count(query);\n  },\n\n  async create<\n    TUID extends Common.UID.ContentType,\n    TParams extends EntityService.Params.Pick<TUID, 'data' | 'files' | 'fields' | 'populate'>\n  >(uid: TUID, params?: TParams) {\n    const wrappedParams = await this.wrapParams<TParams>(params, { uid, action: 'create' });\n    const { data, files } = wrappedParams;\n\n    if (!data) {\n      throw new Error('cannot create');\n    }\n\n    const model = strapi.getModel(uid) as Shared.ContentTypes[Common.UID.ContentType];\n\n    const isDraft = contentTypesUtils.isDraft(data, model);\n    const validData = await entityValidator.validateEntityCreation(model, data, { isDraft });\n\n    // select / populate\n    const query = transformParamsToQuery(uid, pickSelectionParams(wrappedParams));\n\n    // TODO: wrap into transaction\n    const componentData = await createComponents(uid, validData);\n\n    const entityData = creationPipeline(\n      Object.assign(omitComponentData(model, validData), componentData),\n      {\n        contentType: model,\n      }\n    );\n    let entity = await db.query(uid).create({\n      ...query,\n      data: entityData,\n    });\n\n    // TODO: do all of this in a transaction to avoid a race condition where entity is created then deleted before we do findOne again\n    // TODO: upload the files then set the links in the entity like with compo to avoid making too many queries\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(uid, Object.assign(entityData, entity), files);\n      entity = await this.findOne(uid, entity.id, wrappedParams);\n    }\n\n    entity = await this.wrapResult(entity, { uid, action: 'create' });\n\n    const { ENTRY_CREATE } = ALLOWED_WEBHOOK_EVENTS;\n    await this.emitEvent(uid, ENTRY_CREATE, entity);\n\n    return entity;\n  },\n\n  async update(uid, entityId, opts) {\n    const wrappedParams = await this.wrapParams<\n      EntityService.Params.Pick<typeof uid, 'data:partial' | 'files' | 'fields' | 'populate'>\n    >(opts, {\n      uid,\n      action: 'update',\n    });\n    const { data, files } = wrappedParams;\n\n    const model = strapi.getModel(uid);\n\n    const entityToUpdate = await db.query(uid).findOne({ where: { id: entityId } });\n\n    if (!entityToUpdate) {\n      return null;\n    }\n\n    const isDraft = contentTypesUtils.isDraft(entityToUpdate, model);\n\n    const validData = await entityValidator.validateEntityUpdate(\n      model,\n      data,\n      {\n        isDraft,\n      },\n      entityToUpdate\n    );\n\n    const query = transformParamsToQuery(uid, pickSelectionParams(wrappedParams));\n\n    // TODO: wrap in transaction\n    const componentData = await updateComponents(uid, entityToUpdate, validData);\n    const entityData = updatePipeline(\n      Object.assign(omitComponentData(model, validData), componentData),\n      { contentType: model }\n    );\n\n    let entity = await db.query(uid).update({\n      ...query,\n      where: { id: entityId },\n      data: entityData,\n    });\n\n    // TODO: upload the files then set the links in the entity like with compo to avoid making too many queries\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(uid, Object.assign(entityData, entity), files);\n      entity = await this.findOne(uid, entity.id, wrappedParams);\n    }\n\n    entity = await this.wrapResult(entity, { uid, action: 'update' });\n\n    const { ENTRY_UPDATE } = ALLOWED_WEBHOOK_EVENTS;\n    await this.emitEvent(uid, ENTRY_UPDATE, entity);\n\n    return entity;\n  },\n\n  async delete(uid, entityId, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'delete' });\n\n    // select / populate\n    const query = transformParamsToQuery(uid, pickSelectionParams(wrappedParams));\n\n    let entityToDelete = await db.query(uid).findOne({\n      ...query,\n      where: { id: entityId },\n    });\n\n    if (!entityToDelete) {\n      return null;\n    }\n\n    const componentsToDelete = await getComponents(uid, entityToDelete);\n\n    await db.query(uid).delete({ where: { id: entityToDelete.id } });\n    await deleteComponents(uid, componentsToDelete as any, { loadComponents: false });\n\n    entityToDelete = await this.wrapResult(entityToDelete, { uid, action: 'delete' });\n\n    const { ENTRY_DELETE } = ALLOWED_WEBHOOK_EVENTS;\n    await this.emitEvent(uid, ENTRY_DELETE, entityToDelete);\n\n    return entityToDelete;\n  },\n\n  async clone(uid, cloneId, opts) {\n    const wrappedParams = await this.wrapParams<\n      EntityService.Params.Pick<typeof uid, 'data' | 'files' | 'fields' | 'populate'>\n    >(opts, { uid, action: 'clone' });\n    const { data, files } = wrappedParams;\n\n    if (!data) {\n      throw new Error('cannot clone');\n    }\n\n    const model = strapi.getModel(uid);\n\n    const entityToClone = await db.query(uid).findOne({ where: { id: cloneId } });\n\n    if (!entityToClone) {\n      return null;\n    }\n    const isDraft = contentTypesUtils.isDraft(entityToClone, model);\n\n    const validData = await entityValidator.validateEntityUpdate(\n      model,\n      // Omit the id, the cloned entity id will be generated by the database\n      _.omit(data, ['id']) as Partial<typeof data>,\n      { isDraft },\n      entityToClone\n    );\n    const query = transformParamsToQuery(uid, pickSelectionParams(wrappedParams));\n\n    // TODO: wrap into transaction\n    const componentData = await cloneComponents(uid, entityToClone, validData);\n\n    const entityData = creationPipeline(\n      Object.assign(omitComponentData(model, validData), componentData),\n      {\n        contentType: model,\n      }\n    );\n\n    let entity = await db.query(uid).clone(cloneId, {\n      ...query,\n      data: entityData,\n    });\n\n    // TODO: upload the files then set the links in the entity like with compo to avoid making too many queries\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(uid, Object.assign(entityData, entity), files);\n      entity = await this.findOne(uid, entity.id, wrappedParams);\n    }\n\n    const { ENTRY_CREATE } = ALLOWED_WEBHOOK_EVENTS;\n    await this.emitEvent(uid, ENTRY_CREATE, entity);\n\n    return entity;\n  },\n  // FIXME: used only for the CM to be removed\n  async deleteMany(uid, opts) {\n    const wrappedParams = await this.wrapParams(opts, { uid, action: 'delete' });\n\n    // select / populate\n    const query = transformParamsToQuery(uid, wrappedParams);\n\n    let entitiesToDelete = await db.query(uid).findMany(query);\n\n    if (!entitiesToDelete.length) {\n      return { count: 0 };\n    }\n\n    const componentsToDelete = await Promise.all(\n      entitiesToDelete.map((entityToDelete) => getComponents(uid, entityToDelete))\n    );\n\n    const deletedEntities = await db.query(uid).deleteMany(query);\n    await Promise.all(\n      componentsToDelete.map((compos) =>\n        deleteComponents(uid, compos as any, { loadComponents: false })\n      )\n    );\n\n    entitiesToDelete = await this.wrapResult(entitiesToDelete, { uid, action: 'delete' });\n\n    // Trigger webhooks. One for each entity\n    const { ENTRY_DELETE } = ALLOWED_WEBHOOK_EVENTS;\n    await Promise.all(entitiesToDelete.map((entity) => this.emitEvent(uid, ENTRY_DELETE, entity)));\n\n    return deletedEntities;\n  },\n\n  async load(uid, entity, field, params) {\n    if (!_.isString(field)) {\n      throw new Error(`Invalid load. Expected \"${field}\" to be a string`);\n    }\n\n    const loadedEntity = await db\n      .query(uid)\n      .load(entity, field, transformLoadParamsToQuery(uid, field, params ?? {}));\n\n    return this.wrapResult(loadedEntity, { uid, field, action: 'load' });\n  },\n\n  async loadPages(uid, entity, field, params, pagination = {}) {\n    if (!_.isString(field)) {\n      throw new Error(`Invalid load. Expected \"${field}\" to be a string`);\n    }\n\n    const { attributes } = strapi.getModel(uid);\n    const attribute = attributes[field];\n\n    if (!relationUtils.isAnyToMany(attribute)) {\n      throw new Error(`Invalid load. Expected \"${field}\" to be an anyToMany relational attribute`);\n    }\n\n    const query = transformLoadParamsToQuery(uid, field, params ?? {}, pagination);\n\n    const loadedPage = await db.query(uid).loadPages(entity, field, query);\n\n    return {\n      ...loadedPage,\n      results: await this.wrapResult(loadedPage.results, { uid, field, action: 'load' }),\n    };\n  },\n});\n\nexport default (ctx: {\n  strapi: Strapi;\n  db: Database;\n  eventHub: EventHub;\n  entityValidator: EntityValidator;\n}): Decoratable<EntityService.EntityService> => {\n  Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value]) => {\n    ctx.strapi.webhookStore?.addAllowedEvent(key, value);\n  });\n\n  const implementation = createDefaultImplementation(ctx);\n\n  const service = {\n    implementation,\n    decorate<T extends object>(decorator: (current: typeof implementation) => T) {\n      if (typeof decorator !== 'function') {\n        throw new Error(`Decorator must be a function, received ${typeof decorator}`);\n      }\n\n      this.implementation = { ...this.implementation, ...decorator(this.implementation) };\n      return this;\n    },\n  };\n\n  const delegator = delegate(service, 'implementation');\n\n  // delegate every method in implementation\n  Object.keys(service.implementation).forEach((key) => delegator.method(key));\n\n  // wrap methods to handle Database Errors\n  service.decorate((oldService: EntityService.EntityService) => {\n    const newService = _.mapValues(\n      oldService,\n      (method, methodName: keyof EntityService.EntityService) =>\n        async function (this: EntityService.EntityService, ...args: []) {\n          try {\n            return await (oldService[methodName] as Utils.Function.AnyPromise).call(this, ...args);\n          } catch (error) {\n            if (\n              databaseErrorsToTransform.some(\n                (errorToTransform) => error instanceof errorToTransform\n              )\n            ) {\n              if (error instanceof Error) {\n                throw new errors.ValidationError(error.message);\n              }\n\n              throw error;\n            }\n            throw error;\n          }\n        }\n    );\n\n    return newService;\n  });\n\n  return service as unknown as Decoratable<EntityService.EntityService>;\n};\n"],"names":["databaseErrors","uploadFiles","contentTypesUtils","relationUtils","errors"],"mappings":"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"}