{"version":3,"file":"upload-files.mjs","sources":["../../../src/services/utils/upload-files.ts"],"sourcesContent":["import _ from 'lodash';\nimport type { Attribute, Common, Schema } from '@strapi/types';\n\nexport type UploadFile = (\n  uid: Common.UID.Schema,\n  entity: Record<string, unknown>,\n  files: Record<string, unknown>\n) => Promise<void>;\n\n/**\n * Upload files and link them to an entity\n */\nconst uploadFile: UploadFile = async (uid, entity, files) => {\n  const modelDef = strapi.getModel(uid);\n\n  if (!_.has(strapi.plugins, 'upload')) {\n    return;\n  }\n\n  const uploadService = strapi.plugin('upload').service('upload');\n\n  const findModelFromUploadPath = (path: string[]) => {\n    if (path.length === 0) {\n      return uid;\n    }\n\n    const currentPath = [];\n    let tmpModel: Schema.ContentType | Schema.Component = modelDef;\n    let modelUID = uid;\n\n    for (let i = 0; i < path.length; i += 1) {\n      if (!tmpModel) {\n        return {};\n      }\n\n      const part = path[i];\n      const attr: Attribute.Any = tmpModel.attributes[part];\n\n      currentPath.push(part);\n\n      // ignore array indexes => handled in the dynamic zone section\n      if (_.isFinite(_.toNumber(path[i]))) {\n        continue;\n      }\n\n      if (!attr) return {};\n\n      if (attr.type === 'component') {\n        modelUID = attr.component;\n        tmpModel = strapi.components[attr.component];\n      } else if (attr.type === 'dynamiczone') {\n        const entryIdx = path[i + 1]; // get component index\n        const value = _.get(entity, [...currentPath, entryIdx]);\n\n        if (!value) return {};\n\n        modelUID = value.__component; // get component type\n        tmpModel = strapi.components[modelUID as Common.UID.Component];\n      } else if (attr.type === 'relation') {\n        if (!('target' in attr)) {\n          return {};\n        }\n\n        modelUID = attr.target;\n        tmpModel = strapi.getModel(modelUID);\n      } else {\n        return;\n      }\n    }\n\n    return modelUID;\n  };\n\n  const doUpload = async (key: string, files: unknown) => {\n    const parts = key.split('.');\n    const [path, field] = [_.initial(parts), _.last(parts)];\n\n    const modelUID = findModelFromUploadPath(path);\n\n    if (modelUID) {\n      const id = _.get(entity, path.concat('id'));\n      return uploadService.uploadToEntity({ id, model: modelUID, field }, files);\n    }\n  };\n\n  await Promise.all(Object.keys(files).map((key) => doUpload(key, files[key])));\n};\n\nexport default uploadFile;\n"],"names":["files"],"mappings":";AAYA,MAAM,aAAyB,OAAO,KAAK,QAAQ,UAAU;AACrD,QAAA,WAAW,OAAO,SAAS,GAAG;AAEpC,MAAI,CAAC,EAAE,IAAI,OAAO,SAAS,QAAQ,GAAG;AACpC;AAAA,EACF;AAEA,QAAM,gBAAgB,OAAO,OAAO,QAAQ,EAAE,QAAQ,QAAQ;AAExD,QAAA,0BAA0B,CAAC,SAAmB;AAC9C,QAAA,KAAK,WAAW,GAAG;AACd,aAAA;AAAA,IACT;AAEA,UAAM,cAAc,CAAA;AACpB,QAAI,WAAkD;AACtD,QAAI,WAAW;AAEf,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACvC,UAAI,CAAC,UAAU;AACb,eAAO;MACT;AAEM,YAAA,OAAO,KAAK,CAAC;AACb,YAAA,OAAsB,SAAS,WAAW,IAAI;AAEpD,kBAAY,KAAK,IAAI;AAGjB,UAAA,EAAE,SAAS,EAAE,SAAS,KAAK,CAAC,CAAC,CAAC,GAAG;AACnC;AAAA,MACF;AAEA,UAAI,CAAC;AAAM,eAAO;AAEd,UAAA,KAAK,SAAS,aAAa;AAC7B,mBAAW,KAAK;AACL,mBAAA,OAAO,WAAW,KAAK,SAAS;AAAA,MAAA,WAClC,KAAK,SAAS,eAAe;AAChC,cAAA,WAAW,KAAK,IAAI,CAAC;AACrB,cAAA,QAAQ,EAAE,IAAI,QAAQ,CAAC,GAAG,aAAa,QAAQ,CAAC;AAEtD,YAAI,CAAC;AAAO,iBAAO;AAEnB,mBAAW,MAAM;AACN,mBAAA,OAAO,WAAW,QAAgC;AAAA,MAAA,WACpD,KAAK,SAAS,YAAY;AAC/B,YAAA,EAAE,YAAY,OAAO;AACvB,iBAAO;QACT;AAEA,mBAAW,KAAK;AACL,mBAAA,OAAO,SAAS,QAAQ;AAAA,MAAA,OAC9B;AACL;AAAA,MACF;AAAA,IACF;AAEO,WAAA;AAAA,EAAA;AAGH,QAAA,WAAW,OAAO,KAAaA,WAAmB;AAChD,UAAA,QAAQ,IAAI,MAAM,GAAG;AAC3B,UAAM,CAAC,MAAM,KAAK,IAAI,CAAC,EAAE,QAAQ,KAAK,GAAG,EAAE,KAAK,KAAK,CAAC;AAEhD,UAAA,WAAW,wBAAwB,IAAI;AAE7C,QAAI,UAAU;AACZ,YAAM,KAAK,EAAE,IAAI,QAAQ,KAAK,OAAO,IAAI,CAAC;AACnC,aAAA,cAAc,eAAe,EAAE,IAAI,OAAO,UAAU,SAASA,MAAK;AAAA,IAC3E;AAAA,EAAA;AAGF,QAAM,QAAQ,IAAI,OAAO,KAAK,KAAK,EAAE,IAAI,CAAC,QAAQ,SAAS,KAAK,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9E;"}