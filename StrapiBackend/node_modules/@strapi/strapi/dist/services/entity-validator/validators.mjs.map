{"version":3,"file":"validators.mjs","sources":["../../../src/services/entity-validator/validators.ts"],"sourcesContent":["import _ from 'lodash';\nimport strapiUtils from '@strapi/utils';\nimport type { Attribute, Schema } from '@strapi/types';\nimport blocksValidator from './blocks-validator';\n\nconst { yup } = strapiUtils;\n\ninterface ValidatorMetas<TAttribute extends Attribute.Any> {\n  attr: TAttribute;\n  model: Schema.ContentType;\n  updatedAttribute: { name: string; value: unknown };\n  entity: Record<string, unknown> | null;\n}\n\ninterface ValidatorOptions {\n  isDraft: boolean;\n}\n\n/* Validator utils */\n\n/**\n * Adds minLength validator\n */\nconst addMinLengthValidator = (\n  validator: strapiUtils.yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Attribute.String\n      | Attribute.Text\n      | Attribute.RichText\n      | Attribute.Password\n      | Attribute.Email\n      | Attribute.UID;\n  },\n  { isDraft }: { isDraft: boolean }\n) => {\n  return attr.minLength && _.isInteger(attr.minLength) && !isDraft\n    ? validator.min(attr.minLength)\n    : validator;\n};\n\n/**\n * Adds maxLength validator\n * @returns {StringSchema}\n */\nconst addMaxLengthValidator = (\n  validator: strapiUtils.yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Attribute.String\n      | Attribute.Text\n      | Attribute.RichText\n      | Attribute.Password\n      | Attribute.Email\n      | Attribute.UID;\n  }\n) => {\n  return attr.maxLength && _.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;\n};\n\n/**\n * Adds min integer validator\n * @returns {NumberSchema}\n */\nconst addMinIntegerValidator = (\n  validator: strapiUtils.yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Attribute.Integer | Attribute.BigInteger;\n  }\n) => (_.isNumber(attr.min) ? validator.min(_.toInteger(attr.min)) : validator);\n\n/**\n * Adds max integer validator\n */\nconst addMaxIntegerValidator = (\n  validator: strapiUtils.yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Attribute.Integer | Attribute.BigInteger;\n  }\n) => (_.isNumber(attr.max) ? validator.max(_.toInteger(attr.max)) : validator);\n\n/**\n * Adds min float/decimal validator\n */\nconst addMinFloatValidator = (\n  validator: strapiUtils.yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Attribute.Decimal | Attribute.Float;\n  }\n) => (_.isNumber(attr.min) ? validator.min(attr.min) : validator);\n\n/**\n * Adds max float/decimal validator\n */\nconst addMaxFloatValidator = (\n  validator: strapiUtils.yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Attribute.Decimal | Attribute.Float;\n  }\n) => (_.isNumber(attr.max) ? validator.max(attr.max) : validator);\n\n/**\n * Adds regex validator\n */\nconst addStringRegexValidator = (\n  validator: strapiUtils.yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Attribute.String\n      | Attribute.Text\n      | Attribute.RichText\n      | Attribute.Password\n      | Attribute.Email\n      | Attribute.UID;\n  }\n) => {\n  return 'regex' in attr && !_.isUndefined(attr.regex)\n    ? validator.matches(new RegExp(attr.regex), { excludeEmptyString: !attr.required })\n    : validator;\n};\n\n/**\n * Adds unique validator\n */\nconst addUniqueValidator = <T extends strapiUtils.yup.AnySchema>(\n  validator: T,\n  { attr, model, updatedAttribute, entity }: ValidatorMetas<Attribute.Any & Attribute.UniqueOption>\n): T => {\n  if (attr.type !== 'uid' && !attr.unique) {\n    return validator;\n  }\n\n  return validator.test('unique', 'This attribute must be unique', async (value) => {\n    /**\n     * If the attribute value is `null` we want to skip the unique validation.\n     * Otherwise it'll only accept a single `null` entry in the database.\n     */\n    if (_.isNil(updatedAttribute.value)) {\n      return true;\n    }\n\n    /**\n     * If the attribute is unchanged we skip the unique verification. This will\n     * prevent the validator to be triggered in case the user activated the\n     * unique constraint after already creating multiple entries with\n     * the same attribute value for that field.\n     */\n    if (entity && updatedAttribute.value === entity[updatedAttribute.name]) {\n      return true;\n    }\n\n    const whereParams = entity\n      ? { $and: [{ [updatedAttribute.name]: value }, { $not: { id: entity.id } }] }\n      : { [updatedAttribute.name]: value };\n\n    const record = await strapi.query(model.uid).findOne({\n      select: ['id'],\n      where: whereParams,\n    });\n\n    return !record;\n  });\n};\n\n/* Type validators */\n\nconst stringValidator = (\n  metas: ValidatorMetas<\n    | Attribute.String\n    | Attribute.Text\n    | Attribute.RichText\n    | Attribute.Password\n    | Attribute.Email\n    | Attribute.UID\n  >,\n  options: ValidatorOptions\n) => {\n  let schema = yup.string().transform((val, originalVal) => originalVal);\n\n  schema = addMinLengthValidator(schema, metas, options);\n  schema = addMaxLengthValidator(schema, metas);\n  schema = addStringRegexValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas);\n\n  return schema;\n};\n\nconst emailValidator = (metas: ValidatorMetas<Attribute.Email>, options: ValidatorOptions) => {\n  const schema = stringValidator(metas, options);\n  return schema.email().min(1, '${path} cannot be empty');\n};\n\nconst uidValidator = (metas: ValidatorMetas<Attribute.UID>, options: ValidatorOptions) => {\n  const schema = stringValidator(metas, options);\n\n  return schema.matches(/^[A-Za-z0-9-_.~]*$/);\n};\n\nconst enumerationValidator = ({ attr }: { attr: Attribute.Enumeration }) => {\n  return yup\n    .string()\n    .oneOf((Array.isArray(attr.enum) ? attr.enum : [attr.enum]).concat(null as any));\n};\n\nconst integerValidator = (metas: ValidatorMetas<Attribute.Integer | Attribute.BigInteger>) => {\n  let schema = yup.number().integer();\n\n  schema = addMinIntegerValidator(schema, metas);\n  schema = addMaxIntegerValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas);\n\n  return schema;\n};\n\nconst floatValidator = (metas: ValidatorMetas<Attribute.Decimal | Attribute.Float>) => {\n  let schema = yup.number();\n  schema = addMinFloatValidator(schema, metas);\n  schema = addMaxFloatValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas);\n\n  return schema;\n};\n\nconst bigintegerValidator = (metas: ValidatorMetas<Attribute.BigInteger>) => {\n  const schema = yup.mixed();\n  return addUniqueValidator(schema, metas);\n};\n\nconst datesValidator = (\n  metas: ValidatorMetas<Attribute.Date | Attribute.DateTime | Attribute.Time | Attribute.Timestamp>\n) => {\n  const schema = yup.mixed();\n  return addUniqueValidator(schema, metas);\n};\n\nexport default {\n  string: stringValidator,\n  text: stringValidator,\n  richtext: stringValidator,\n  password: stringValidator,\n  email: emailValidator,\n  enumeration: enumerationValidator,\n  boolean: () => yup.boolean(),\n  uid: uidValidator,\n  json: () => yup.mixed(),\n  integer: integerValidator,\n  biginteger: bigintegerValidator,\n  float: floatValidator,\n  decimal: floatValidator,\n  date: datesValidator,\n  time: datesValidator,\n  datetime: datesValidator,\n  timestamp: datesValidator,\n  blocks: blocksValidator,\n};\n"],"names":[],"mappings":"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"}