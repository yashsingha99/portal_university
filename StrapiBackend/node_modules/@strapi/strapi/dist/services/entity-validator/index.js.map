{"version":3,"file":"index.js","sources":["../../../src/services/entity-validator/index.ts"],"sourcesContent":["/**\n * Entity validator\n * Module that will validate input data for entity creation or edition\n */\n\nimport { uniqBy, castArray, isNil, isArray, mergeWith } from 'lodash';\nimport { has, prop, isObject, isEmpty } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport { EntityValidator, Common, Schema, Attribute, Shared, EntityService } from '@strapi/types';\nimport validators from './validators';\n\ntype CreateOrUpdate = 'creation' | 'update';\n\nconst { yup, validateYupSchema } = strapiUtils;\nconst { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;\nconst { ValidationError } = strapiUtils.errors;\n\ntype Entity = {\n  id: ID;\n  [key: string]: unknown;\n} | null;\n\ntype ID = { id: string | number };\n\ntype RelationSource = string | number | ID;\n\ninterface ValidatorMeta<TAttribute = Attribute.Any> {\n  attr: TAttribute;\n  updatedAttribute: { name: string; value: any };\n}\n\ninterface ValidatorContext {\n  isDraft: boolean;\n}\n\ninterface AttributeValidatorMetas {\n  attr: Attribute.Any;\n  updatedAttribute: { name: string; value: unknown };\n  model: Schema.ContentType | Schema.Component;\n  entity?: Entity;\n}\n\ninterface ModelValidatorMetas {\n  model: Schema.ContentType | Schema.Component;\n  data: Record<string, unknown>;\n  entity?: Entity;\n}\n\nconst isInteger = (value: unknown): value is number => Number.isInteger(value);\n\nconst addMinMax = <\n  T extends {\n    min(value: number): T;\n    max(value: number): T;\n  }\n>(\n  validator: T,\n  { attr, updatedAttribute }: ValidatorMeta<Attribute.Any & Attribute.MinMaxOption<string | number>>\n): T => {\n  let nextValidator: T = validator;\n\n  if (\n    isInteger(attr.min) &&\n    (('required' in attr && attr.required) ||\n      (Array.isArray(updatedAttribute.value) && updatedAttribute.value.length > 0))\n  ) {\n    nextValidator = nextValidator.min(attr.min);\n  }\n  if (isInteger(attr.max)) {\n    nextValidator = nextValidator.max(attr.max);\n  }\n  return nextValidator;\n};\n\nconst addRequiredValidation = (createOrUpdate: CreateOrUpdate) => {\n  return <T extends strapiUtils.yup.AnySchema>(\n    validator: T,\n    { attr: { required } }: ValidatorMeta<Partial<Attribute.Any & Attribute.RequiredOption>>\n  ): T => {\n    let nextValidator = validator;\n\n    if (required) {\n      if (createOrUpdate === 'creation') {\n        nextValidator = nextValidator.notNil();\n      } else if (createOrUpdate === 'update') {\n        nextValidator = nextValidator.notNull();\n      }\n    } else {\n      nextValidator = nextValidator.nullable();\n    }\n    return nextValidator;\n  };\n};\n\nconst addDefault = (createOrUpdate: CreateOrUpdate) => {\n  return (\n    validator: strapiUtils.yup.BaseSchema,\n    { attr }: ValidatorMeta<Attribute.Any & Attribute.DefaultOption<unknown>>\n  ) => {\n    let nextValidator = validator;\n\n    if (createOrUpdate === 'creation') {\n      if (\n        ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&\n        !attr.required\n      ) {\n        nextValidator = nextValidator.default([]);\n      } else {\n        nextValidator = nextValidator.default(attr.default);\n      }\n    } else {\n      nextValidator = nextValidator.default(undefined);\n    }\n\n    return nextValidator;\n  };\n};\n\nconst preventCast = (validator: strapiUtils.yup.AnySchema) =>\n  validator.transform((val, originalVal) => originalVal);\n\nconst createComponentValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  (\n    { attr, updatedAttribute }: ValidatorMeta<Attribute.Component<Common.UID.Component, boolean>>,\n    { isDraft }: ValidatorContext\n  ) => {\n    const model = strapi.getModel(attr.component);\n    if (!model) {\n      throw new Error('Validation failed: Model not found');\n    }\n\n    if (attr?.repeatable) {\n      // FIXME: yup v1\n\n      let validator = yup\n        .array()\n        .of(\n          yup.lazy((item) =>\n            createModelValidator(createOrUpdate)({ model, data: item }, { isDraft }).notNull()\n          ) as any\n        );\n\n      validator = addRequiredValidation(createOrUpdate)(validator, {\n        attr: { required: true },\n        updatedAttribute,\n      });\n\n      validator = addMinMax(validator, { attr, updatedAttribute });\n\n      return validator;\n    }\n\n    // FIXME: v4 was broken\n    let validator = createModelValidator(createOrUpdate)(\n      { model, data: updatedAttribute.value },\n      { isDraft }\n    );\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !isDraft && attr.required },\n      updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createDzValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  ({ attr, updatedAttribute }: ValidatorMeta, { isDraft }: ValidatorContext) => {\n    let validator;\n\n    validator = yup.array().of(\n      yup.lazy((item) => {\n        const model = strapi.getModel(prop('__component', item));\n        const schema = yup\n          .object()\n          .shape({\n            __component: yup.string().required().oneOf(Object.keys(strapi.components)),\n          })\n          .notNull();\n\n        return model\n          ? schema.concat(createModelValidator(createOrUpdate)({ model, data: item }, { isDraft }))\n          : schema;\n      }) as any // FIXME: yup v1\n    );\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: true },\n      updatedAttribute,\n    });\n\n    validator = addMinMax(validator, { attr, updatedAttribute });\n\n    return validator;\n  };\n\nconst createRelationValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  (\n    { attr, updatedAttribute }: ValidatorMeta<Attribute.Relation>,\n    { isDraft }: ValidatorContext\n  ) => {\n    let validator;\n\n    if (Array.isArray(updatedAttribute.value)) {\n      validator = yup.array().of(yup.mixed());\n    } else {\n      validator = yup.mixed();\n    }\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !isDraft && attr.required },\n      updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createScalarAttributeValidator =\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMeta, options: ValidatorContext) => {\n    let validator;\n\n    if (has(metas.attr.type, validators)) {\n      validator = (validators as any)[metas.attr.type](metas, options);\n    } else {\n      // No validators specified - fall back to mixed\n      validator = yup.mixed();\n    }\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !options.isDraft && metas.attr.required },\n      updatedAttribute: metas.updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createAttributeValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  (metas: AttributeValidatorMetas, options: ValidatorContext) => {\n    let validator = yup.mixed();\n\n    if (isMediaAttribute(metas.attr)) {\n      validator = yup.mixed();\n    } else if (isScalarAttribute(metas.attr)) {\n      validator = createScalarAttributeValidator(createOrUpdate)(metas, options);\n    } else {\n      if (metas.attr.type === 'component') {\n        validator = createComponentValidator(createOrUpdate)(\n          { attr: metas.attr, updatedAttribute: metas.updatedAttribute },\n          options\n        );\n      } else if (metas.attr.type === 'dynamiczone') {\n        validator = createDzValidator(createOrUpdate)(metas, options);\n      } else if (metas.attr.type === 'relation') {\n        validator = createRelationValidator(createOrUpdate)(\n          {\n            attr: metas.attr,\n            updatedAttribute: metas.updatedAttribute,\n          },\n          options\n        );\n      }\n\n      validator = preventCast(validator);\n    }\n\n    validator = addDefault(createOrUpdate)(validator, metas);\n\n    return validator;\n  };\n\nconst createModelValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  ({ model, data, entity }: ModelValidatorMetas, options: ValidatorContext) => {\n    const writableAttributes = model ? getWritableAttributes(model as any) : [];\n\n    const schema = writableAttributes.reduce((validators, attributeName) => {\n      const metas = {\n        attr: model.attributes[attributeName],\n        updatedAttribute: { name: attributeName, value: prop(attributeName, data) },\n        model,\n        entity,\n      };\n\n      const validator = createAttributeValidator(createOrUpdate)(metas, options);\n\n      validators[attributeName] = validator;\n\n      return validators;\n    }, {} as Record<string, strapiUtils.yup.BaseSchema>);\n\n    return yup.object().shape(schema);\n  };\n\nconst createValidateEntity = (createOrUpdate: CreateOrUpdate) => {\n  return async <\n    TUID extends Common.UID.ContentType,\n    TData extends EntityService.Params.Data.Input<TUID>\n  >(\n    model: Shared.ContentTypes[TUID],\n    data: TData | Partial<TData> | undefined,\n    options?: { isDraft?: boolean },\n    entity?: Entity\n  ): Promise<TData> => {\n    if (!isObject(data)) {\n      const { displayName } = model.info;\n\n      throw new ValidationError(\n        `Invalid payload submitted for the ${createOrUpdate} of an entity of type ${displayName}. Expected an object, but got ${typeof data}`\n      );\n    }\n\n    const validator = createModelValidator(createOrUpdate)(\n      { model, data, entity },\n      { isDraft: options?.isDraft ?? false }\n    )\n      .test('relations-test', 'check that all relations exist', async function (data) {\n        try {\n          await checkRelationsExist(buildRelationsStore({ uid: model.uid, data }));\n        } catch (e) {\n          return this.createError({\n            path: this.path,\n            message: (e instanceof ValidationError && e.message) || 'Invalid relations',\n          });\n        }\n        return true;\n      })\n      .required();\n\n    return validateYupSchema(validator, {\n      strict: false,\n      abortEarly: false,\n    })(data);\n  };\n};\n\n/**\n * Builds an object containing all the media and relations being associated with an entity\n */\nconst buildRelationsStore = <TUID extends Common.UID.ContentType | Common.UID.Component>({\n  uid,\n  data,\n}: {\n  uid: TUID;\n  data: Record<string, unknown> | null;\n}): Record<string, ID[]> => {\n  if (!uid) {\n    throw new ValidationError(`Cannot build relations store: \"uid\" is undefined`);\n  }\n\n  if (isEmpty(data)) {\n    return {};\n  }\n\n  const currentModel = strapi.getModel(uid);\n\n  return Object.keys(currentModel.attributes).reduce((result, attributeName: string) => {\n    const attribute = currentModel.attributes[attributeName];\n    const value = data[attributeName];\n\n    if (isNil(value)) {\n      return result;\n    }\n\n    switch (attribute.type) {\n      case 'relation':\n      case 'media': {\n        if (\n          attribute.type === 'relation' &&\n          (attribute.relation === 'morphToMany' || attribute.relation === 'morphToOne')\n        ) {\n          // TODO: handle polymorphic relations\n          break;\n        }\n\n        const target =\n          // eslint-disable-next-line no-nested-ternary\n          attribute.type === 'media' ? 'plugin::upload.file' : attribute.target;\n        // As there are multiple formats supported for associating relations\n        // with an entity, the value here can be an: array, object or number.\n        let source: RelationSource[];\n        if (Array.isArray(value)) {\n          source = value;\n        } else if (isObject(value)) {\n          if ('connect' in value && !isNil(value.connect)) {\n            source = value.connect as RelationSource[];\n          } else if ('set' in value && !isNil(value.set)) {\n            source = value.set as RelationSource[];\n          } else {\n            source = [];\n          }\n        } else {\n          source = castArray(value as RelationSource);\n        }\n        const idArray = source.map((v) => ({\n          id: typeof v === 'object' ? v.id : v,\n        }));\n\n        // Update the relationStore to keep track of all associations being made\n        // with relations and media.\n        result[target] = result[target] || [];\n        result[target].push(...idArray);\n        break;\n      }\n      case 'component': {\n        return castArray(value).reduce((relationsStore, componentValue) => {\n          if (!attribute.component) {\n            throw new ValidationError(\n              `Cannot build relations store from component, component identifier is undefined`\n            );\n          }\n\n          return mergeWith(\n            relationsStore,\n            buildRelationsStore({\n              uid: attribute.component,\n              data: componentValue as Record<string, unknown>,\n            }),\n            (objValue, srcValue) => {\n              if (isArray(objValue)) {\n                return objValue.concat(srcValue);\n              }\n            }\n          );\n        }, result) as Record<string, ID[]>;\n      }\n      case 'dynamiczone': {\n        return castArray(value).reduce((relationsStore, dzValue) => {\n          const value = dzValue as Record<string, unknown>;\n          if (!value.__component) {\n            throw new ValidationError(\n              `Cannot build relations store from dynamiczone, component identifier is undefined`\n            );\n          }\n\n          return mergeWith(\n            relationsStore,\n            buildRelationsStore({\n              uid: value.__component as Common.UID.Component,\n              data: value,\n            }),\n            (objValue, srcValue) => {\n              if (isArray(objValue)) {\n                return objValue.concat(srcValue);\n              }\n            }\n          );\n        }, result) as Record<string, ID[]>;\n      }\n      default:\n        break;\n    }\n\n    return result;\n  }, {} as Record<string, ID[]>);\n};\n\n/**\n * Iterate through the relations store and validates that every relation or media\n * mentioned exists\n */\nconst checkRelationsExist = async (relationsStore: Record<string, ID[]> = {}) => {\n  const promises = [];\n\n  for (const [key, value] of Object.entries(relationsStore)) {\n    const evaluate = async () => {\n      const uniqueValues = uniqBy(value, `id`);\n      const count = await strapi.query(key as Common.UID.Schema).count({\n        where: {\n          id: {\n            $in: uniqueValues.map((v) => v.id),\n          },\n        },\n      });\n\n      if (count !== uniqueValues.length) {\n        throw new ValidationError(\n          `${\n            uniqueValues.length - count\n          } relation(s) of type ${key} associated with this entity do not exist`\n        );\n      }\n    };\n    promises.push(evaluate());\n  }\n\n  return Promise.all(promises);\n};\n\nconst entityValidator: EntityValidator = {\n  validateEntityCreation: createValidateEntity('creation'),\n  validateEntityUpdate: createValidateEntity('update'),\n};\n\nexport default entityValidator;\n"],"names":["strapiUtils","validator","prop","has","validators","isObject","data","isEmpty","isNil","castArray","mergeWith","isArray","value","uniqBy"],"mappings":"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"}