{"version":3,"file":"content-types.js","sources":["../../../src/core/registries/content-types.ts"],"sourcesContent":["import { pickBy, has } from 'lodash/fp';\nimport type { Common, Schema } from '@strapi/types';\nimport { createContentType, ContentTypeDefinition } from '../domain/content-type';\nimport { addNamespace, hasNamespace } from '../utils';\n\ntype ContentTypesInput = Record<string, ContentTypeDefinition>;\ntype ContentTypeExtendFn = (contentType: Schema.ContentType) => Schema.ContentType;\n\nconst validateKeySameToSingularName = (contentTypes: ContentTypesInput) => {\n  for (const ctName of Object.keys(contentTypes)) {\n    const contentType = contentTypes[ctName];\n\n    if (ctName !== contentType.schema.info.singularName) {\n      throw new Error(\n        `The key of the content-type should be the same as its singularName. Found ${ctName} and ${contentType.schema.info.singularName}.`\n      );\n    }\n  }\n};\n\nconst contentTypesRegistry = () => {\n  const contentTypes: Record<string, Schema.ContentType> = {};\n\n  return {\n    /**\n     * Returns this list of registered contentTypes uids\n     */\n    keys() {\n      return Object.keys(contentTypes);\n    },\n\n    /**\n     * Returns the instance of a contentType. Instantiate the contentType if not already done\n     */\n    get(uid: Common.UID.ContentType) {\n      return contentTypes[uid];\n    },\n\n    /**\n     * Returns a map with all the contentTypes in a namespace\n     */\n    getAll(namespace: string) {\n      return pickBy((_, uid) => hasNamespace(uid, namespace))(contentTypes);\n    },\n\n    /**\n     * Registers a contentType\n     */\n    set(uid: Common.UID.ContentType, contentType: Schema.ContentType) {\n      contentTypes[uid] = contentType;\n      return this;\n    },\n\n    /**\n     * Registers a map of contentTypes for a specific namespace\n     */\n    add(namespace: string, newContentTypes: ContentTypesInput) {\n      validateKeySameToSingularName(newContentTypes);\n\n      for (const rawCtName of Object.keys(newContentTypes)) {\n        const uid = addNamespace(rawCtName, namespace);\n\n        if (has(uid, contentTypes)) {\n          throw new Error(`Content-type ${uid} has already been registered.`);\n        }\n\n        contentTypes[uid] = createContentType(uid, newContentTypes[rawCtName]);\n      }\n    },\n\n    /**\n     * Wraps a contentType to extend it\n     */\n    extend(ctUID: Common.UID.ContentType, extendFn: ContentTypeExtendFn) {\n      const currentContentType = this.get(ctUID);\n\n      if (!currentContentType) {\n        throw new Error(`Content-Type ${ctUID} doesn't exist`);\n      }\n\n      const newContentType = extendFn(currentContentType);\n      contentTypes[ctUID] = newContentType;\n\n      return this;\n    },\n  };\n};\n\nexport default contentTypesRegistry;\n"],"names":["pickBy","_","hasNamespace","addNamespace","has","createContentType"],"mappings":";;;;AAQA,MAAM,gCAAgC,CAAC,iBAAoC;AACzE,aAAW,UAAU,OAAO,KAAK,YAAY,GAAG;AACxC,UAAA,cAAc,aAAa,MAAM;AAEvC,QAAI,WAAW,YAAY,OAAO,KAAK,cAAc;AACnD,YAAM,IAAI;AAAA,QACR,6EAA6E,MAAM,QAAQ,YAAY,OAAO,KAAK,YAAY;AAAA,MAAA;AAAA,IAEnI;AAAA,EACF;AACF;AAEA,MAAM,uBAAuB,MAAM;AACjC,QAAM,eAAmD,CAAA;AAElD,SAAA;AAAA;AAAA;AAAA;AAAA,IAIL,OAAO;AACE,aAAA,OAAO,KAAK,YAAY;AAAA,IACjC;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,KAA6B;AAC/B,aAAO,aAAa,GAAG;AAAA,IACzB;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,WAAmB;AACjB,aAAAA,EAAA,OAAO,CAACC,IAAG,QAAQC,MAAAA,aAAa,KAAK,SAAS,CAAC,EAAE,YAAY;AAAA,IACtE;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,KAA6B,aAAiC;AAChE,mBAAa,GAAG,IAAI;AACb,aAAA;AAAA,IACT;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,WAAmB,iBAAoC;AACzD,oCAA8B,eAAe;AAE7C,iBAAW,aAAa,OAAO,KAAK,eAAe,GAAG;AAC9C,cAAA,MAAMC,MAAAA,aAAa,WAAW,SAAS;AAEzC,YAAAC,EAAA,IAAI,KAAK,YAAY,GAAG;AAC1B,gBAAM,IAAI,MAAM,gBAAgB,GAAG,+BAA+B;AAAA,QACpE;AAEA,qBAAa,GAAG,IAAIC,MAAA,kBAAkB,KAAK,gBAAgB,SAAS,CAAC;AAAA,MACvE;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,OAA+B,UAA+B;AAC7D,YAAA,qBAAqB,KAAK,IAAI,KAAK;AAEzC,UAAI,CAAC,oBAAoB;AACvB,cAAM,IAAI,MAAM,gBAAgB,KAAK,gBAAgB;AAAA,MACvD;AAEM,YAAA,iBAAiB,SAAS,kBAAkB;AAClD,mBAAa,KAAK,IAAI;AAEf,aAAA;AAAA,IACT;AAAA,EAAA;AAEJ;;"}