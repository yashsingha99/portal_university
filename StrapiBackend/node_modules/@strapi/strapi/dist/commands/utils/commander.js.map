{"version":3,"file":"commander.js","sources":["../../../src/commands/utils/commander.ts"],"sourcesContent":["/**\n * This file includes hooks to use for commander.hook and argParsers for commander.argParser\n */\n\nimport inquirer from 'inquirer';\nimport { Command, InvalidOptionArgumentError, Option } from 'commander';\nimport chalk from 'chalk';\nimport { isNaN } from 'lodash/fp';\nimport { exitWith } from './helpers';\n\n/**\n * argParser: Parse a comma-delimited string as an array\n */\nconst parseList = (value: string) => {\n  try {\n    return value.split(',').map((item) => item.trim()); // trim shouldn't be necessary but might help catch unexpected whitespace characters\n  } catch (e) {\n    exitWith(1, `Unrecognized input: ${value}`);\n  }\n\n  return [];\n};\n\n/**\n * Returns an argParser that returns a list\n */\nconst getParseListWithChoices = (choices: string[], errorMessage = 'Invalid options:') => {\n  return (value: string) => {\n    const list = parseList(value);\n    const invalid = list.filter((item) => {\n      return !choices.includes(item);\n    });\n\n    if (invalid.length > 0) {\n      exitWith(1, `${errorMessage}: ${invalid.join(',')}`);\n    }\n\n    return list;\n  };\n};\n\n/**\n * argParser: Parse a string as an integer\n */\nconst parseInteger = (value: string) => {\n  // parseInt takes a string and a radix\n  const parsedValue = parseInt(value, 10);\n  if (isNaN(parsedValue)) {\n    throw new InvalidOptionArgumentError(`Not an integer: ${value}`);\n  }\n  return parsedValue;\n};\n\n/**\n * argParser: Parse a string as a URL object\n */\nconst parseURL = (value: string) => {\n  try {\n    const url = new URL(value);\n    if (!url.host) {\n      throw new InvalidOptionArgumentError(`Could not parse url ${value}`);\n    }\n\n    return url;\n  } catch (e) {\n    throw new InvalidOptionArgumentError(`Could not parse url ${value}`);\n  }\n};\n\n/**\n * hook: if encrypt==true and key not provided, prompt for it\n */\nconst promptEncryptionKey = async (thisCommand: Command) => {\n  const opts = thisCommand.opts();\n\n  if (!opts.encrypt && opts.key) {\n    return exitWith(1, 'Key may not be present unless encryption is used');\n  }\n\n  // if encrypt==true but we have no key, prompt for it\n  if (opts.encrypt && !(opts.key && opts.key.length > 0)) {\n    try {\n      const answers = await inquirer.prompt([\n        {\n          type: 'password',\n          message: 'Please enter an encryption key',\n          name: 'key',\n          validate(key) {\n            if (key.length > 0) return true;\n\n            return 'Key must be present when using the encrypt option';\n          },\n        },\n      ]);\n      opts.key = answers.key;\n    } catch (e) {\n      return exitWith(1, 'Failed to get encryption key');\n    }\n    if (!opts.key) {\n      return exitWith(1, 'Failed to get encryption key');\n    }\n  }\n};\n\n/**\n * hook: require a confirmation message to be accepted unless forceOption (-f,--force) is used\n */\nconst getCommanderConfirmMessage = (\n  message: string,\n  { failMessage }: { failMessage?: string } = {}\n) => {\n  return async (command: Command) => {\n    const confirmed = await confirmMessage(message, { force: command.opts().force });\n    if (!confirmed) {\n      exitWith(1, failMessage);\n    }\n  };\n};\n\nconst confirmMessage = async (message: string, { force }: { force?: boolean } = {}) => {\n  // if we have a force option, respond yes\n  if (force === true) {\n    // attempt to mimic the inquirer prompt exactly\n    console.log(`${chalk.green('?')} ${chalk.bold(message)} ${chalk.cyan('Yes')}`);\n    return true;\n  }\n\n  const answers = await inquirer.prompt([\n    {\n      type: 'confirm',\n      message,\n      name: `confirm`,\n      default: false,\n    },\n  ]);\n\n  return answers.confirm;\n};\n\nconst forceOption = new Option(\n  '--force',\n  `Automatically answer \"yes\" to all prompts, including potentially destructive requests, and run non-interactively.`\n);\n\nexport {\n  getParseListWithChoices,\n  parseList,\n  parseURL,\n  parseInteger,\n  promptEncryptionKey,\n  getCommanderConfirmMessage,\n  confirmMessage,\n  forceOption,\n};\n"],"names":["Option"],"mappings":";;;;;;;AA2IA,MAAM,cAAc,IAAIA,UAAA;AAAA,EACtB;AAAA,EACA;AACF;;"}