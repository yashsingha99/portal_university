{"version":3,"file":"pkg.js","sources":["../../../src/commands/utils/pkg.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport os from 'os';\nimport pkgUp from 'pkg-up';\nimport * as yup from 'yup';\nimport chalk from 'chalk';\nimport { Logger } from './logger';\n\ninterface Export {\n  types?: string;\n  source: string;\n  module?: string;\n  import?: string;\n  require?: string;\n  default: string;\n}\n\nconst packageJsonSchema = yup.object({\n  name: yup.string().required(),\n  exports: yup.lazy((value) =>\n    yup\n      .object(\n        typeof value === 'object'\n          ? Object.entries(value).reduce((acc, [key, value]) => {\n              if (typeof value === 'object') {\n                acc[key] = yup\n                  .object({\n                    types: yup.string().optional(),\n                    source: yup.string().required(),\n                    module: yup.string().optional(),\n                    import: yup.string().required(),\n                    require: yup.string().required(),\n                    default: yup.string().required(),\n                  })\n                  .noUnknown(true);\n              } else {\n                acc[key] = yup\n                  .string()\n                  .matches(/^\\.\\/.*\\.json$/)\n                  .required();\n              }\n\n              return acc;\n            }, {} as Record<string, yup.SchemaOf<string> | yup.SchemaOf<Export>>)\n          : undefined\n      )\n      .optional()\n  ),\n});\n\n/**\n * @description being a task to load the package.json starting from the current working directory\n * using a shallow find for the package.json  and `fs` to read the file. If no package.json is found,\n * the process will throw with an appropriate error message.\n */\nconst loadPkg = async ({ cwd, logger }: { cwd: string; logger: Logger }): Promise<object> => {\n  const pkgPath = await pkgUp({ cwd });\n\n  if (!pkgPath) {\n    throw new Error('Could not find a package.json in the current directory');\n  }\n\n  const buffer = await fs.readFile(pkgPath);\n\n  const pkg = JSON.parse(buffer.toString());\n\n  logger.debug('Loaded package.json:', os.EOL, pkg);\n\n  return pkg;\n};\n\ntype PackageJson = yup.Asserts<typeof packageJsonSchema>;\n\n/**\n * @description validate the package.json against a standardised schema using `yup`.\n * If the validation fails, the process will throw with an appropriate error message.\n */\nconst validatePkg = async ({ pkg }: { pkg: object }): Promise<PackageJson> => {\n  try {\n    const validatedPkg = await packageJsonSchema.validate(pkg, {\n      strict: true,\n    });\n\n    return validatedPkg;\n  } catch (err) {\n    if (err instanceof yup.ValidationError) {\n      switch (err.type) {\n        case 'required':\n          if (err.path) {\n            throw new Error(\n              `'${err.path}' in 'package.json' is required as type '${chalk.magenta(\n                yup.reach(packageJsonSchema, err.path).type\n              )}'`\n            );\n          }\n          break;\n        /**\n         * This will only be thrown if there are keys in the export map\n         * that we don't expect so we can therefore make some assumptions\n         */\n        case 'noUnknown':\n          if (err.path && err.params && 'unknown' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' contains the unknown key ${chalk.magenta(\n                err.params.unknown\n              )}, for compatability only the following keys are allowed: ${chalk.magenta(\n                \"['types', 'source', 'import', 'require', 'default']\"\n              )}`\n            );\n          }\n          break;\n        default:\n          if (err.path && err.params && 'type' in err.params && 'value' in err.params) {\n            throw new Error(\n              `'${err.path}' in 'package.json' must be of type '${chalk.magenta(\n                err.params.type\n              )}' (recieved '${chalk.magenta(typeof err.params.value)}')`\n            );\n          }\n      }\n    }\n\n    throw err;\n  }\n};\n\nexport type { PackageJson, Export };\nexport { loadPkg, validatePkg };\n"],"names":["yup","value","pkgUp","fs","os","chalk"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,MAAM,oBAAoBA,eAAI,OAAO;AAAA,EACnC,MAAMA,eAAI,OAAO,EAAE,SAAS;AAAA,EAC5B,SAASA,eAAI;AAAA,IAAK,CAAC,UACjBA,eACG;AAAA,MACC,OAAO,UAAU,WACb,OAAO,QAAQ,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAKC,MAAK,MAAM;AAC9C,YAAA,OAAOA,WAAU,UAAU;AACzB,cAAA,GAAG,IAAID,eACR,OAAO;AAAA,YACN,OAAOA,eAAI,OAAO,EAAE,SAAS;AAAA,YAC7B,QAAQA,eAAI,OAAO,EAAE,SAAS;AAAA,YAC9B,QAAQA,eAAI,OAAO,EAAE,SAAS;AAAA,YAC9B,QAAQA,eAAI,OAAO,EAAE,SAAS;AAAA,YAC9B,SAASA,eAAI,OAAO,EAAE,SAAS;AAAA,YAC/B,SAASA,eAAI,OAAO,EAAE,SAAS;AAAA,UAAA,CAChC,EACA,UAAU,IAAI;AAAA,QAAA,OACZ;AACD,cAAA,GAAG,IAAIA,eACR,SACA,QAAQ,gBAAgB,EACxB;QACL;AAEO,eAAA;AAAA,MAAA,GACN,CAAA,CAAiE,IACpE;AAAA,MAEL,SAAS;AAAA,EACd;AACF,CAAC;AAOD,MAAM,UAAU,OAAO,EAAE,KAAK,aAA+D;AAC3F,QAAM,UAAU,MAAME,eAAAA,QAAM,EAAE,IAAK,CAAA;AAEnC,MAAI,CAAC,SAAS;AACN,UAAA,IAAI,MAAM,wDAAwD;AAAA,EAC1E;AAEA,QAAM,SAAS,MAAMC,YAAAA,QAAG,SAAS,OAAO;AAExC,QAAM,MAAM,KAAK,MAAM,OAAO,SAAU,CAAA;AAExC,SAAO,MAAM,wBAAwBC,YAAG,QAAA,KAAK,GAAG;AAEzC,SAAA;AACT;AAQA,MAAM,cAAc,OAAO,EAAE,UAAiD;AACxE,MAAA;AACF,UAAM,eAAe,MAAM,kBAAkB,SAAS,KAAK;AAAA,MACzD,QAAQ;AAAA,IAAA,CACT;AAEM,WAAA;AAAA,WACA,KAAK;AACR,QAAA,eAAeJ,eAAI,iBAAiB;AACtC,cAAQ,IAAI,MAAM;AAAA,QAChB,KAAK;AACH,cAAI,IAAI,MAAM;AACZ,kBAAM,IAAI;AAAA,cACR,IAAI,IAAI,IAAI,4CAA4CK,eAAM,QAAA;AAAA,gBAC5DL,eAAI,MAAM,mBAAmB,IAAI,IAAI,EAAE;AAAA,cACxC,CAAA;AAAA,YAAA;AAAA,UAEL;AACA;AAAA,QAKF,KAAK;AACH,cAAI,IAAI,QAAQ,IAAI,UAAU,aAAa,IAAI,QAAQ;AACrD,kBAAM,IAAI;AAAA,cACR,IAAI,IAAI,IAAI,gDAAgDK,eAAM,QAAA;AAAA,gBAChE,IAAI,OAAO;AAAA,cAAA,CACZ,4DAA4DA,eAAAA,QAAM;AAAA,gBACjE;AAAA,cAAA,CACD;AAAA,YAAA;AAAA,UAEL;AACA;AAAA,QACF;AACM,cAAA,IAAI,QAAQ,IAAI,UAAU,UAAU,IAAI,UAAU,WAAW,IAAI,QAAQ;AAC3E,kBAAM,IAAI;AAAA,cACR,IAAI,IAAI,IAAI,wCAAwCA,eAAM,QAAA;AAAA,gBACxD,IAAI,OAAO;AAAA,cAAA,CACZ,gBAAgBA,eAAM,QAAA,QAAQ,OAAO,IAAI,OAAO,KAAK,CAAC;AAAA,YAAA;AAAA,UAE3D;AAAA,MACJ;AAAA,IACF;AAEM,UAAA;AAAA,EACR;AACF;;;"}