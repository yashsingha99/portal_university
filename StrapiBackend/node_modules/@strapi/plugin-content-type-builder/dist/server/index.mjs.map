{"version":3,"file":"index.mjs","sources":["../../server/src/config.ts","../../server/src/bootstrap.ts","../../server/src/utils/attributes.ts","../../server/src/services/schema-builder/schema-handler.ts","../../server/src/services/schema-builder/component-builder.ts","../../server/src/services/constants.ts","../../server/src/services/schema-builder/content-type-builder.ts","../../server/src/services/schema-builder/index.ts","../../server/src/services/content-types.ts","../../server/src/services/components.ts","../../server/src/services/component-categories.ts","../../server/src/services/builder.ts","../../server/src/services/api-handler.ts","../../server/src/services/index.ts","../../server/src/utils/index.ts","../../server/src/controllers/builder.ts","../../server/src/controllers/validation/common.ts","../../server/src/controllers/validation/component-category.ts","../../server/src/controllers/component-categories.ts","../../server/src/controllers/validation/types.ts","../../server/src/controllers/validation/relations.ts","../../server/src/controllers/validation/model-schema.ts","../../server/src/utils/typeguards.ts","../../server/src/controllers/validation/data-transform.ts","../../server/src/controllers/validation/component.ts","../../server/src/controllers/components.ts","../../server/src/controllers/validation/content-type.ts","../../server/src/controllers/content-types.ts","../../server/src/controllers/index.ts","../../server/src/routes/admin.ts","../../server/src/routes/content-api.ts","../../server/src/routes/index.ts","../../server/src/index.ts"],"sourcesContent":["export default {\n  default: {},\n  validator() {},\n};\n","import type { LoadedStrapi } from '@strapi/types';\n\nexport default async ({ strapi }: { strapi: LoadedStrapi }) => {\n  const actions = [\n    {\n      section: 'plugins',\n      displayName: 'Read',\n      uid: 'read',\n      pluginName: 'content-type-builder',\n    },\n  ];\n\n  await strapi.admin.services.permission.actionProvider.registerMany(actions);\n};\n","import _ from 'lodash';\nimport utils, { errors } from '@strapi/utils';\nimport type { Attribute, Schema } from '@strapi/types';\n\nconst { ApplicationError } = errors;\n\nexport const hasComponent = (model: Schema.Schema) => {\n  const compoKeys = Object.keys(model.attributes || {}).filter((key) => {\n    return model.attributes[key].type === 'component';\n  });\n\n  return compoKeys.length > 0;\n};\n\nexport const isConfigurable = (attribute: Attribute.Any) => _.get(attribute, 'configurable', true);\n\nexport const isRelation = (attribute: Attribute.Any) => attribute.type === 'relation';\n\n/**\n * Formats a component's attributes\n */\nexport const formatAttributes = (model: any) => {\n  const { getVisibleAttributes } = utils.contentTypes;\n\n  // only get attributes that can be seen in the CTB\n  return getVisibleAttributes(model).reduce((acc: any, key) => {\n    acc[key] = formatAttribute(model.attributes[key]);\n    return acc;\n  }, {});\n};\n\n/**\n * Formats a component attribute\n */\nexport const formatAttribute = (attribute: Attribute.Any & Record<string, any>) => {\n  const { configurable, required, autoPopulate, pluginOptions } = attribute;\n\n  if (attribute.type === 'media') {\n    return {\n      type: 'media',\n      multiple: !!attribute.multiple,\n      required: !!required,\n      configurable: configurable === false ? false : undefined,\n      private: !!attribute.private,\n      allowedTypes: attribute.allowedTypes,\n      pluginOptions,\n    };\n  }\n\n  if (attribute.type === 'relation') {\n    return {\n      ...attribute,\n      type: 'relation',\n      target: attribute.target,\n      targetAttribute: attribute.inversedBy || attribute.mappedBy || null,\n      configurable: configurable === false ? false : undefined,\n      private: !!attribute.private,\n      pluginOptions,\n      // TODO: remove\n      autoPopulate,\n    };\n  }\n\n  return attribute;\n};\n\n// TODO: move to schema builder\nexport const replaceTemporaryUIDs = (uidMap: any) => (schema: any) => {\n  return {\n    ...schema,\n    attributes: Object.keys(schema.attributes).reduce((acc: any, key) => {\n      const attr = schema.attributes[key];\n      if (attr.type === 'component') {\n        if (_.has(uidMap, attr.component)) {\n          acc[key] = {\n            ...attr,\n            component: uidMap[attr.component],\n          };\n\n          return acc;\n        }\n\n        if (!_.has(strapi.components, attr.component)) {\n          throw new ApplicationError('component.notFound');\n        }\n      }\n\n      if (\n        attr.type === 'dynamiczone' &&\n        _.intersection(attr.components, Object.keys(uidMap)).length > 0\n      ) {\n        acc[key] = {\n          ...attr,\n          components: attr.components.map((value: any) => {\n            if (_.has(uidMap, value)) return uidMap[value];\n\n            if (!_.has(strapi.components, value)) {\n              throw new ApplicationError('component.notFound');\n            }\n\n            return value;\n          }),\n        };\n\n        return acc;\n      }\n\n      acc[key] = attr;\n      return acc;\n    }, {}),\n  };\n};\n","import path from 'path';\nimport type { UID, Schema } from '@strapi/types';\nimport fse from 'fs-extra';\nimport _ from 'lodash';\n\nimport { isConfigurable } from '../../utils/attributes';\n\nexport type Infos = {\n  category?: string;\n  modelName?: string;\n  plugin?: string;\n  uid?: UID.ContentType;\n  dir: string;\n  filename: string;\n  schema?: Schema.ContentType;\n};\n\nexport default function createSchemaHandler(infos: Infos) {\n  const { category, modelName, plugin, uid, dir, filename, schema } = infos;\n\n  const initialState = {\n    modelName,\n    plugin,\n    category,\n    uid,\n    dir,\n    filename,\n    schema:\n      schema ||\n      ({\n        info: {},\n        options: {},\n        attributes: {},\n      } as Schema.ContentType),\n  };\n\n  const state = _.cloneDeep(initialState);\n\n  // always keep it the same to rollback\n  Object.freeze(initialState.schema);\n\n  let modified = false;\n  let deleted = false;\n\n  return {\n    get modelName() {\n      return initialState.modelName;\n    },\n\n    get plugin() {\n      return initialState.plugin;\n    },\n\n    get category() {\n      return initialState.category;\n    },\n\n    get kind() {\n      return _.get(state.schema, 'kind', 'collectionType');\n    },\n\n    get uid() {\n      return state.uid;\n    },\n\n    get writable() {\n      return _.get(state, 'plugin') !== 'admin';\n    },\n\n    setUID(val: UID.ContentType) {\n      modified = true;\n\n      state.uid = val;\n      return this;\n    },\n\n    setDir(val: string) {\n      modified = true;\n\n      state.dir = val;\n      return this;\n    },\n\n    get schema() {\n      return _.cloneDeep(state.schema);\n    },\n\n    setSchema(val: Schema.ContentType) {\n      modified = true;\n\n      state.schema = _.cloneDeep(val);\n      return this;\n    },\n\n    // get a particular path inside the schema\n    get(path: string[]) {\n      return _.get(state.schema, path);\n    },\n\n    // set a particular path inside the schema\n    set(path: string[] | string, val: unknown) {\n      if (!state.schema) return this;\n\n      modified = true;\n\n      const value = _.defaultTo(val, _.get(state.schema, path));\n      _.set(state.schema, path, value);\n\n      return this;\n    },\n\n    // delete a particular path inside the schema\n    unset(path: string[]) {\n      modified = true;\n\n      _.unset(state.schema, path);\n\n      return this;\n    },\n\n    delete() {\n      deleted = true;\n      return this;\n    },\n\n    getAttribute(key: string) {\n      return this.get(['attributes', key]);\n    },\n\n    setAttribute(key: string, attribute: any) {\n      return this.set(['attributes', key], attribute);\n    },\n\n    deleteAttribute(key: string) {\n      return this.unset(['attributes', key]);\n    },\n\n    setAttributes(newAttributes: Schema.Attributes) {\n      if (!this.schema) return this;\n\n      // delete old configurable attributes\n      for (const key in this.schema.attributes) {\n        if (isConfigurable((this.schema.attributes as any)[key])) {\n          this.deleteAttribute(key);\n        }\n      }\n\n      // set new Attributes\n      for (const key of Object.keys(newAttributes)) {\n        this.setAttribute(key, newAttributes[key as keyof Schema.Attributes]);\n      }\n\n      return this;\n    },\n\n    removeContentType(uid: UID.ContentType) {\n      if (!state.schema) return this;\n\n      const attributes = state.schema.attributes as Record<string, any>;\n\n      Object.keys(attributes).forEach((key) => {\n        const attribute = attributes[key];\n\n        if (attribute.target === uid) {\n          this.deleteAttribute(key);\n        }\n      });\n\n      return this;\n    },\n\n    // utils\n    removeComponent(uid: UID.Component) {\n      if (!state.schema) return this;\n\n      const attributes = state.schema.attributes as Record<string, any>;\n\n      Object.keys(attributes).forEach((key) => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.deleteAttribute(key);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attributes[key].components.filter(\n            (val: string) => val !== uid\n          );\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    updateComponent(uid: UID.Component, newUID: UID.Component) {\n      if (!state.schema) return this;\n\n      const attributes = state.schema.attributes as Record<string, any>;\n\n      Object.keys(attributes).forEach((key) => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.set(['attributes', key, 'component'], newUID);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attr.components.map((val: string) =>\n            val === uid ? newUID : val\n          );\n\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    // save the schema to disk\n    async flush() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      if (deleted) {\n        await fse.remove(initialPath);\n\n        const list = await fse.readdir(initialState.dir);\n        if (list.length === 0) {\n          await fse.remove(initialState.dir);\n        }\n\n        return;\n      }\n\n      if (modified) {\n        if (!state.schema) return Promise.resolve();\n\n        await fse.ensureFile(filePath);\n\n        await fse.writeJSON(\n          filePath,\n          {\n            kind: state.schema.kind,\n            collectionName: state.schema.collectionName,\n            info: state.schema.info,\n            options: state.schema.options,\n            pluginOptions: state.schema.pluginOptions,\n            attributes: state.schema.attributes,\n            config: (state.schema as any).config,\n          },\n          { spaces: 2 }\n        );\n\n        // remove from oldPath\n        if (initialPath !== filePath) {\n          await fse.remove(initialPath);\n\n          const list = await fse.readdir(initialState.dir);\n          if (list.length === 0) {\n            await fse.remove(initialState.dir);\n          }\n        }\n\n        return;\n      }\n\n      return Promise.resolve();\n    },\n\n    // reset the schema to its initial value\n    async rollback() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      // it was a creation so it needs to be deleted\n      if (!initialState.uid) {\n        await fse.remove(filePath);\n\n        const list = await fse.readdir(state.dir);\n        if (list.length === 0) {\n          await fse.remove(state.dir);\n        }\n        return;\n      }\n\n      if (modified || deleted) {\n        await fse.ensureFile(initialPath);\n        await fse.writeJSON(initialPath, initialState.schema, { spaces: 2 });\n\n        // remove\n        if (initialPath !== filePath) {\n          await fse.remove(filePath);\n\n          const list = await fse.readdir(state.dir);\n          if (list.length === 0) {\n            await fse.remove(state.dir);\n          }\n        }\n      }\n\n      return Promise.resolve();\n    },\n  };\n}\n","import path from 'path';\nimport type { UID } from '@strapi/types';\nimport _ from 'lodash';\nimport pluralize from 'pluralize';\n\nimport { nameToSlug, nameToCollectionName, errors } from '@strapi/utils';\nimport { isConfigurable } from '../../utils/attributes';\nimport createSchemaHandler from './schema-handler';\n\nconst { ApplicationError } = errors;\n\nexport default function createComponentBuilder() {\n  return {\n    createComponentUID({ category, displayName }: any) {\n      return `${nameToSlug(category)}.${nameToSlug(displayName)}`;\n    },\n\n    createNewComponentUIDMap(components: object[]) {\n      return components.reduce((uidMap: any, component: any) => {\n        uidMap[component.tmpUID] = this.createComponentUID(component);\n        return uidMap;\n      }, {});\n    },\n\n    /**\n     * create a component in the tmpComponent map\n     */\n    createComponent(this: any, infos: any) {\n      const uid = this.createComponentUID(infos);\n\n      if (this.components.has(uid)) {\n        throw new ApplicationError('component.alreadyExists');\n      }\n\n      const handler = createSchemaHandler({\n        dir: path.join(strapi.dirs.app.components, nameToSlug(infos.category)),\n        filename: `${nameToSlug(infos.displayName)}.json`,\n      });\n\n      // TODO: create a utility for this\n      // Duplicate in admin/src/components/FormModal/forms/utils/createCollectionName.ts\n      const collectionName = `components_${nameToCollectionName(\n        infos.category\n      )}_${nameToCollectionName(pluralize(infos.displayName))}`;\n\n      this.components.forEach((compo: any) => {\n        if (compo.schema.collectionName === collectionName) {\n          throw new ApplicationError('component.alreadyExists');\n        }\n      });\n\n      handler\n        .setUID(uid)\n        .set('collectionName', collectionName)\n        .set(['info', 'displayName'], infos.displayName)\n        .set(['info', 'icon'], infos.icon)\n        .set(['info', 'description'], infos.description)\n        .set('pluginOptions', infos.pluginOptions)\n        .set('config', infos.config)\n        .setAttributes(this.convertAttributes(infos.attributes));\n\n      if (this.components.size === 0) {\n        strapi.telemetry.send('didCreateFirstComponent');\n      } else {\n        strapi.telemetry.send('didCreateComponent');\n      }\n\n      this.components.set(uid, handler);\n\n      return handler;\n    },\n\n    /**\n     * create a component in the tmpComponent map\n     */\n    editComponent(this: any, infos: any) {\n      const { uid } = infos;\n\n      if (!this.components.has(uid)) {\n        throw new errors.ApplicationError('component.notFound');\n      }\n\n      const component = this.components.get(uid);\n\n      const [, nameUID] = uid.split('.');\n\n      const newCategory = nameToSlug(infos.category);\n      const newUID = `${newCategory}.${nameUID}`;\n\n      if (newUID !== uid && this.components.has(newUID)) {\n        throw new errors.ApplicationError('component.edit.alreadyExists');\n      }\n\n      const newDir = path.join(strapi.dirs.app.components, newCategory);\n\n      const oldAttributes = component.schema.attributes;\n\n      const newAttributes = _.omitBy(infos.attributes, (attr, key) => {\n        return _.has(oldAttributes, key) && !isConfigurable(oldAttributes[key]);\n      });\n\n      component\n        .setUID(newUID)\n        .setDir(newDir)\n        .set(['info', 'displayName'], infos.displayName)\n        .set(['info', 'icon'], infos.icon)\n        .set(['info', 'description'], infos.description)\n        .set('pluginOptions', infos.pluginOptions)\n        .setAttributes(this.convertAttributes(newAttributes));\n\n      if (newUID !== uid) {\n        this.components.forEach((compo: any) => {\n          compo.updateComponent(uid, newUID);\n        });\n\n        this.contentTypes.forEach((ct: any) => {\n          ct.updateComponent(uid, newUID);\n        });\n      }\n\n      return component;\n    },\n\n    deleteComponent(this: any, uid: UID.Component) {\n      if (!this.components.has(uid)) {\n        throw new errors.ApplicationError('component.notFound');\n      }\n\n      this.components.forEach((compo: any) => {\n        compo.removeComponent(uid);\n      });\n\n      this.contentTypes.forEach((ct: any) => {\n        ct.removeComponent(uid);\n      });\n\n      return this.components.get(uid).delete();\n    },\n  };\n}\n","export const modelTypes = {\n  CONTENT_TYPE: 'CONTENT_TYPE',\n  COMPONENT: 'COMPONENT',\n} as const;\n\nexport const typeKinds = {\n  SINGLE_TYPE: 'singleType',\n  COLLECTION_TYPE: 'collectionType',\n} as const;\n\nexport const DEFAULT_TYPES = [\n  // advanced types\n  'media',\n\n  // scalar types\n  'string',\n  'text',\n  'richtext',\n  'blocks',\n  'json',\n  'enumeration',\n  'password',\n  'email',\n  'integer',\n  'biginteger',\n  'float',\n  'decimal',\n  'date',\n  'time',\n  'datetime',\n  'timestamp',\n  'boolean',\n\n  'relation',\n] as const;\n\nexport const VALID_UID_TARGETS = ['string', 'text'] as const;\n\nexport const FORBIDDEN_ATTRIBUTE_NAMES = ['__component', '__contentType'] as const;\n\nexport const coreUids = {\n  STRAPI_USER: 'admin::user',\n  PREFIX: 'strapi::',\n} as const;\n\nexport const pluginsUids = {\n  UPLOAD_FILE: 'plugin::upload.file',\n} as const;\n","import path from 'path';\nimport _ from 'lodash';\n\nimport { nameToCollectionName, errors } from '@strapi/utils';\nimport type { Attribute, UID } from '@strapi/types';\nimport { isRelation, isConfigurable } from '../../utils/attributes';\nimport { typeKinds } from '../constants';\nimport createSchemaHandler from './schema-handler';\nimport { CreateContentTypeInput } from '../../controllers/validation/content-type';\n\nconst { ApplicationError } = errors;\n\nconst reuseUnsetPreviousProperties = (newAttribute: Attribute.Any, oldAttribute: Attribute.Any) => {\n  _.defaults(\n    newAttribute,\n    _.omit(oldAttribute, [\n      'configurable',\n      'required',\n      'private',\n      'unique',\n      'pluginOptions',\n      'inversedBy',\n      'mappedBy',\n    ])\n  );\n};\n\nexport default function createComponentBuilder() {\n  return {\n    setRelation(this: any, { key, uid, attribute }: any) {\n      if (!_.has(attribute, 'target')) {\n        return;\n      }\n\n      const targetCT = this.contentTypes.get(attribute.target);\n      const targetAttribute = targetCT.getAttribute(attribute.targetAttribute);\n\n      if (!attribute.targetAttribute) {\n        return;\n      }\n\n      targetCT.setAttribute(\n        attribute.targetAttribute,\n        generateRelation({ key, attribute, uid, targetAttribute })\n      );\n    },\n\n    unsetRelation(this: any, attribute: any) {\n      if (!_.has(attribute, 'target')) {\n        return;\n      }\n\n      const targetCT = this.contentTypes.get(attribute.target);\n\n      const targetAttributeName = attribute.inversedBy || attribute.mappedBy;\n      const targetAttribute = targetCT.getAttribute(targetAttributeName);\n\n      if (!targetAttribute) return;\n\n      return targetCT.deleteAttribute(targetAttributeName);\n    },\n\n    /**\n     * Creates a content type in memory to be written to files later on\n     */\n    createContentType(this: any, infos: CreateContentTypeInput) {\n      const uid = createContentTypeUID(infos);\n\n      if (this.contentTypes.has(uid)) {\n        throw new ApplicationError('contentType.alreadyExists');\n      }\n\n      const contentType = createSchemaHandler({\n        modelName: infos.singularName,\n        dir: path.join(\n          strapi.dirs.app.api,\n          infos.singularName,\n          'content-types',\n          infos.singularName\n        ),\n        filename: `schema.json`,\n      });\n\n      this.contentTypes.set(uid, contentType);\n\n      // support self referencing content type relation\n      Object.keys(infos.attributes).forEach((key) => {\n        const { target } = infos.attributes[key];\n        if (target === '__self__') {\n          infos.attributes[key].target = uid;\n        }\n      });\n\n      contentType\n        .setUID(uid)\n        .set('kind', infos.kind || typeKinds.COLLECTION_TYPE)\n        .set('collectionName', infos.collectionName || nameToCollectionName(infos.pluralName))\n        .set('info', {\n          singularName: infos.singularName,\n          pluralName: infos.pluralName,\n          displayName: infos.displayName,\n          description: infos.description,\n        })\n        .set('options', {\n          ...(infos.options ?? {}),\n          draftAndPublish: infos.draftAndPublish || false,\n        })\n        .set('pluginOptions', infos.pluginOptions)\n        .set('config', infos.config)\n        .setAttributes(this.convertAttributes(infos.attributes));\n\n      Object.keys(infos.attributes).forEach((key) => {\n        const attribute = infos.attributes[key];\n\n        if (isRelation(attribute)) {\n          if (['manyToMany', 'oneToOne'].includes(attribute.relation)) {\n            attribute.dominant = true;\n          }\n\n          this.setRelation({\n            key,\n            uid,\n            attribute,\n          });\n        }\n      });\n\n      return contentType;\n    },\n\n    editContentType(this: any, infos: any) {\n      const { uid } = infos;\n\n      if (!this.contentTypes.has(uid)) {\n        throw new ApplicationError('contentType.notFound');\n      }\n\n      const contentType = this.contentTypes.get(uid);\n\n      const oldAttributes = contentType.schema.attributes;\n\n      const newAttributes = _.omitBy(infos.attributes, (attr, key) => {\n        return _.has(oldAttributes, key) && !isConfigurable(oldAttributes[key]);\n      });\n\n      const newKeys = _.difference(Object.keys(newAttributes), Object.keys(oldAttributes));\n      const deletedKeys = _.difference(Object.keys(oldAttributes), Object.keys(newAttributes));\n      const remainingKeys = _.intersection(Object.keys(oldAttributes), Object.keys(newAttributes));\n\n      // remove old relations\n      deletedKeys.forEach((key) => {\n        const attribute = oldAttributes[key];\n\n        const targetAttributeName = attribute.inversedBy || attribute.mappedBy;\n\n        // if the old relation has a target attribute. we need to remove it in the target type\n        if (isConfigurable(attribute) && isRelation(attribute) && !_.isNil(targetAttributeName)) {\n          this.unsetRelation(attribute);\n        }\n      });\n\n      remainingKeys.forEach((key) => {\n        const oldAttribute = oldAttributes[key];\n        const newAttribute = newAttributes[key];\n\n        if (!isRelation(oldAttribute) && isRelation(newAttribute)) {\n          return this.setRelation({\n            key,\n            uid,\n            attribute: newAttributes[key],\n          });\n        }\n\n        if (isRelation(oldAttribute) && !isRelation(newAttribute)) {\n          return this.unsetRelation(oldAttribute);\n        }\n\n        if (isRelation(oldAttribute) && isRelation(newAttribute)) {\n          const oldTargetAttributeName = oldAttribute.inversedBy || oldAttribute.mappedBy;\n\n          const sameRelation = oldAttribute.relation === newAttribute.relation;\n          const targetAttributeHasChanged = oldTargetAttributeName !== newAttribute.targetAttribute;\n\n          if (!sameRelation || targetAttributeHasChanged) {\n            this.unsetRelation(oldAttribute);\n          }\n\n          // keep extra options that were set manually on oldAttribute\n          reuseUnsetPreviousProperties(newAttribute, oldAttribute);\n\n          if (oldAttribute.inversedBy) {\n            newAttribute.dominant = true;\n          } else if (oldAttribute.mappedBy) {\n            newAttribute.dominant = false;\n          }\n\n          return this.setRelation({\n            key,\n            uid,\n            attribute: newAttribute,\n          });\n        }\n      });\n\n      // add new relations\n      newKeys.forEach((key) => {\n        const attribute = newAttributes[key];\n\n        if (isRelation(attribute)) {\n          if (['manyToMany', 'oneToOne'].includes(attribute.relation)) {\n            attribute.dominant = true;\n          }\n\n          this.setRelation({\n            key,\n            uid,\n            attribute,\n          });\n        }\n      });\n\n      contentType\n        .set('kind', infos.kind || contentType.schema.kind)\n        .set(['info', 'displayName'], infos.displayName)\n        .set(['info', 'description'], infos.description)\n        .set('options', {\n          ...(infos.options ?? {}),\n          draftAndPublish: infos.draftAndPublish || false,\n        })\n        .set('pluginOptions', infos.pluginOptions)\n        .setAttributes(this.convertAttributes(newAttributes));\n\n      return contentType;\n    },\n\n    deleteContentType(this: any, uid: string) {\n      if (!this.contentTypes.has(uid)) {\n        throw new ApplicationError('contentType.notFound');\n      }\n\n      this.components.forEach((compo: any) => {\n        compo.removeContentType(uid);\n      });\n\n      this.contentTypes.forEach((ct: any) => {\n        ct.removeContentType(uid);\n      });\n\n      return this.contentTypes.get(uid).delete();\n    },\n  };\n}\n\n/**\n * Returns a uid from a content type infos\n *\n * @param {object} options options\n * @param {string} options.singularName content-type singularName\n * @returns {string} uid\n */\nconst createContentTypeUID = ({ singularName }: { singularName: string }): UID.ContentType =>\n  `api::${singularName}.${singularName}`;\n\nconst generateRelation = ({ key, attribute, uid, targetAttribute = {} }: any) => {\n  const opts: any = {\n    type: 'relation',\n    target: uid,\n    autoPopulate: targetAttribute.autoPopulate,\n    private: targetAttribute.private || undefined,\n    pluginOptions: targetAttribute.pluginOptions || undefined,\n  };\n\n  switch (attribute.relation) {\n    case 'oneToOne': {\n      opts.relation = 'oneToOne';\n\n      if (attribute.dominant) {\n        opts.mappedBy = key;\n      } else {\n        opts.inversedBy = key;\n      }\n      break;\n    }\n    case 'oneToMany': {\n      opts.relation = 'manyToOne';\n      opts.inversedBy = key;\n      break;\n    }\n    case 'manyToOne': {\n      opts.relation = 'oneToMany';\n      opts.mappedBy = key;\n      break;\n    }\n    case 'manyToMany': {\n      opts.relation = 'manyToMany';\n\n      if (attribute.dominant) {\n        opts.mappedBy = key;\n      } else {\n        opts.inversedBy = key;\n      }\n\n      break;\n    }\n    default:\n  }\n\n  // we do this just to make sure we have the same key order when writing to files\n  const { type, relation, target, ...restOptions } = opts;\n\n  return {\n    type,\n    relation,\n    target,\n    ...restOptions,\n  };\n};\n","import { join } from 'path';\nimport _ from 'lodash';\n\nimport { errors } from '@strapi/utils';\nimport createSchemaHandler from './schema-handler';\nimport createComponentBuilder from './component-builder';\nimport createContentTypeBuilder from './content-type-builder';\n\n/**\n * Creates a content type schema builder instance\n */\nexport default function createBuilder() {\n  const components = Object.values(strapi.components).map((componentInput) => ({\n    category: componentInput.category,\n    modelName: componentInput.modelName,\n    plugin: componentInput.modelName,\n    uid: componentInput.uid,\n    filename: componentInput.__filename__,\n    dir: join(strapi.dirs.app.components, componentInput.category),\n    schema: componentInput.__schema__,\n    config: componentInput.config,\n  }));\n\n  const contentTypes = Object.values(strapi.contentTypes).map((contentTypeInput) => {\n    const dir = contentTypeInput.plugin\n      ? join(\n          strapi.dirs.app.extensions,\n          contentTypeInput.plugin,\n          'content-types',\n          contentTypeInput.info.singularName\n        )\n      : join(\n          strapi.dirs.app.api,\n          contentTypeInput.apiName,\n          'content-types',\n          contentTypeInput.info.singularName\n        );\n\n    return {\n      modelName: contentTypeInput.modelName,\n      plugin: contentTypeInput.plugin,\n      uid: contentTypeInput.uid,\n      filename: 'schema.json',\n      dir,\n      schema: contentTypeInput.__schema__,\n      config: contentTypeInput.config,\n    };\n  });\n\n  return createSchemaBuilder({\n    components,\n    contentTypes,\n  });\n}\n\ntype SchemaBuilderOptions = {\n  components: any;\n  contentTypes: any;\n};\n\nfunction createSchemaBuilder({ components, contentTypes }: SchemaBuilderOptions) {\n  const tmpComponents = new Map();\n  const tmpContentTypes = new Map();\n\n  // init temporary ContentTypes\n  Object.keys(contentTypes).forEach((key) => {\n    tmpContentTypes.set(contentTypes[key].uid, createSchemaHandler(contentTypes[key]));\n  });\n\n  // init temporary components\n  Object.keys(components).forEach((key) => {\n    tmpComponents.set(components[key].uid, createSchemaHandler(components[key]));\n  });\n\n  return {\n    get components() {\n      return tmpComponents;\n    },\n    get contentTypes() {\n      return tmpContentTypes;\n    },\n\n    /**\n     * Convert Attributes received from the API to the right syntax\n     */\n    convertAttributes(attributes: any) {\n      return Object.keys(attributes).reduce((acc, key) => {\n        const attribute = attributes[key];\n\n        const { configurable, private: isPrivate } = attribute;\n\n        const baseProperties = {\n          private: isPrivate === true ? true : undefined,\n          configurable: configurable === false ? false : undefined,\n        };\n\n        if (attribute.type === 'relation') {\n          const { target, relation, targetAttribute, dominant, ...restOfProperties } = attribute;\n\n          const attr = {\n            type: 'relation',\n            relation,\n            target,\n            ...restOfProperties,\n            ...baseProperties,\n          };\n\n          acc[key] = attr;\n\n          if (target && !this.contentTypes.has(target)) {\n            throw new errors.ApplicationError(`target: ${target} does not exist`);\n          }\n\n          if (_.isNil(targetAttribute)) {\n            return acc;\n          }\n\n          if (['oneToOne', 'manyToMany'].includes(relation) && dominant === true) {\n            attr.inversedBy = targetAttribute;\n          } else if (['oneToOne', 'manyToMany'].includes(relation) && dominant === false) {\n            attr.mappedBy = targetAttribute;\n          } else if (['oneToOne', 'manyToOne', 'manyToMany'].includes(relation)) {\n            attr.inversedBy = targetAttribute;\n          } else if (['oneToMany'].includes(relation)) {\n            attr.mappedBy = targetAttribute;\n          }\n\n          return acc;\n        }\n\n        acc[key] = {\n          ...attribute,\n          ...baseProperties,\n        };\n\n        return acc;\n      }, {} as Record<string, unknown>);\n    },\n\n    ...createComponentBuilder(),\n    ...createContentTypeBuilder(),\n\n    /**\n     * Write all type to files\n     */\n    writeFiles() {\n      const schemas = [\n        ...Array.from(tmpComponents.values()),\n        ...Array.from(tmpContentTypes.values()),\n      ];\n\n      return Promise.all(schemas.map((schema) => schema.flush()))\n        .catch((error) => {\n          strapi.log.error('Error writing schema files');\n          strapi.log.error(error);\n          return this.rollback();\n        })\n        .catch((error) => {\n          strapi.log.error(\n            'Error rolling back schema files. You might need to fix your files manually'\n          );\n          strapi.log.error(error);\n\n          throw new errors.ApplicationError('Invalid schema edition');\n        });\n    },\n\n    /**\n     * rollback all files\n     */\n    rollback() {\n      return Promise.all(\n        [...Array.from(tmpComponents.values()), ...Array.from(tmpContentTypes.values())].map(\n          (schema) => schema.rollback()\n        )\n      );\n    },\n  };\n}\n","import _ from 'lodash';\nimport { getOr } from 'lodash/fp';\nimport { contentTypes as contentTypesUtils, errors } from '@strapi/utils';\nimport type { Common, Schema } from '@strapi/types';\nimport { formatAttributes, replaceTemporaryUIDs } from '../utils/attributes';\nimport createBuilder from './schema-builder';\nimport { coreUids, pluginsUids } from './constants';\n\nconst { ApplicationError } = errors;\n\nexport const isContentTypeVisible = (model: Schema.ContentType) =>\n  getOr(true, 'pluginOptions.content-type-builder.visible', model) === true;\n\nexport const getRestrictRelationsTo = (contentType: Schema.ContentType) => {\n  const { uid } = contentType;\n  if (uid === coreUids.STRAPI_USER) {\n    // TODO: replace with an obj { relation: 'x', bidirectional: true|false }\n    return ['oneWay', 'manyWay'];\n  }\n\n  if (\n    uid.startsWith(coreUids.PREFIX) ||\n    uid === pluginsUids.UPLOAD_FILE ||\n    !isContentTypeVisible(contentType)\n  ) {\n    return [];\n  }\n\n  return null;\n};\n\n/**\n * Format a contentType info to be used by the front-end\n */\nexport const formatContentType = (contentType: any) => {\n  const { uid, kind, modelName, plugin, collectionName, info } = contentType;\n\n  return {\n    uid,\n    plugin,\n    apiID: modelName,\n    schema: {\n      ...contentTypesUtils.getOptions(contentType),\n      displayName: info.displayName,\n      singularName: info.singularName,\n      pluralName: info.pluralName,\n      description: _.get(info, 'description', ''),\n      pluginOptions: contentType.pluginOptions,\n      kind: kind || 'collectionType',\n      collectionName,\n      attributes: formatAttributes(contentType),\n      visible: isContentTypeVisible(contentType),\n      restrictRelationsTo: getRestrictRelationsTo(contentType),\n    },\n  };\n};\n\nexport const createContentTypes = async (contentTypes: any[]) => {\n  const builder = createBuilder();\n  const createdContentTypes = [];\n\n  for (const contentType of contentTypes) {\n    createdContentTypes.push(await createContentType(contentType, { defaultBuilder: builder }));\n  }\n\n  await builder.writeFiles();\n\n  return createdContentTypes;\n};\n\ntype CreateContentTypeOptions = {\n  defaultBuilder?: any; // TODO\n};\n\n/**\n * Creates a content type and handle the nested components sent with it\n */\nexport const createContentType = async (\n  { contentType, components }: any,\n  options: CreateContentTypeOptions = {}\n) => {\n  const builder = options.defaultBuilder || createBuilder();\n  const uidMap = builder.createNewComponentUIDMap(components || []);\n\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newContentType = builder.createContentType(replaceTmpUIDs(contentType));\n\n  // allow components to target the new contentType\n  const targetContentType = (infos: any) => {\n    Object.keys(infos.attributes).forEach((key) => {\n      const { target } = infos.attributes[key];\n      if (target === '__contentType__') {\n        infos.attributes[key].target = newContentType.uid;\n      }\n    });\n\n    return infos;\n  };\n\n  components?.forEach((component: any) => {\n    const options = replaceTmpUIDs(targetContentType(component));\n\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(options);\n    }\n\n    return builder.editComponent(options);\n  });\n\n  // generate api skeleton\n  await generateAPI({\n    displayName: contentType!.displayName || contentType!.info.displayName,\n    singularName: contentType!.singularName,\n    pluralName: contentType!.pluralName,\n    kind: contentType!.kind,\n  });\n\n  if (!options.defaultBuilder) {\n    await builder.writeFiles();\n  }\n\n  strapi.eventHub.emit('content-type.create', { contentType: newContentType });\n\n  return newContentType;\n};\n\n/**\n * Generate an API skeleton\n */\nexport const generateAPI = ({\n  singularName,\n  kind = 'collectionType',\n  pluralName,\n  displayName,\n}: any) => {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const strapiGenerators = require('@strapi/generators');\n  return strapiGenerators.generate(\n    'content-type',\n    {\n      kind,\n      singularName,\n      id: singularName,\n      pluralName,\n      displayName,\n      destination: 'new',\n      bootstrapApi: true,\n      attributes: [],\n    },\n    { dir: strapi.dirs.app.root }\n  );\n};\n\n/**\n * Edits a contentType and handle the nested contentTypes sent with it\n */\nexport const editContentType = async (\n  uid: Common.UID.ContentType,\n  { contentType, components = [] }: any\n) => {\n  const builder = createBuilder();\n\n  const previousSchema = builder.contentTypes.get(uid).schema;\n  const previousKind = previousSchema.kind;\n  const newKind = contentType.kind || previousKind;\n\n  // Restore non-visible attributes from previous schema\n  const previousAttributes = previousSchema.attributes;\n  const prevNonVisibleAttributes = contentTypesUtils\n    .getNonVisibleAttributes(previousSchema)\n    .reduce((acc, key) => {\n      if (key in previousAttributes) {\n        acc[key] = previousAttributes[key];\n      }\n\n      return acc;\n    }, {} as any);\n  contentType.attributes = _.merge(prevNonVisibleAttributes, contentType.attributes);\n\n  if (newKind !== previousKind && newKind === 'singleType') {\n    const entryCount = await strapi.query(uid).count();\n    if (entryCount > 1) {\n      throw new ApplicationError(\n        'You cannot convert a collectionType to a singleType when having multiple entries in DB'\n      );\n    }\n  }\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedContentType = builder.editContentType({\n    uid,\n    ...replaceTmpUIDs(contentType),\n  });\n\n  components.forEach((component: any) => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  if (newKind !== previousKind) {\n    const apiHandler = strapi.plugin('content-type-builder').service('api-handler');\n    await apiHandler.backup(uid);\n\n    try {\n      await apiHandler.clear(uid);\n\n      // generate new api skeleton\n      await generateAPI({\n        displayName: updatedContentType.schema.info.displayName,\n        singularName: updatedContentType.schema.info.singularName,\n        pluralName: updatedContentType.schema.info.pluralName,\n        kind: updatedContentType.schema.kind,\n      });\n\n      await builder.writeFiles();\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n\n    return updatedContentType;\n  }\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('content-type.update', { contentType: updatedContentType });\n\n  return updatedContentType;\n};\n\nexport const deleteContentTypes = async (uids: Common.UID.ContentType[]) => {\n  const builder = createBuilder();\n  const apiHandler = strapi.plugin('content-type-builder').service('api-handler');\n\n  for (const uid of uids) {\n    await deleteContentType(uid, builder);\n  }\n\n  await builder.writeFiles();\n  for (const uid of uids) {\n    try {\n      await apiHandler.clear(uid);\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n  }\n};\n\n/**\n * Deletes a content type and the api files related to it\n */\nexport const deleteContentType = async (\n  uid: Common.UID.ContentType,\n  defaultBuilder: any = undefined\n) => {\n  const builder = defaultBuilder || createBuilder();\n  // make a backup\n  const apiHandler = strapi.plugin('content-type-builder').service('api-handler');\n  await apiHandler.backup(uid);\n\n  const contentType = builder.deleteContentType(uid);\n\n  if (!defaultBuilder) {\n    try {\n      await builder.writeFiles();\n      await apiHandler.clear(uid);\n    } catch (error) {\n      await apiHandler.rollback(uid);\n    }\n  }\n\n  strapi.eventHub.emit('content-type.delete', { contentType });\n\n  return contentType;\n};\n","import type { UID, Schema } from '@strapi/types';\nimport { get, has } from 'lodash';\n\nimport { formatAttributes, replaceTemporaryUIDs } from '../utils/attributes';\nimport createBuilder from './schema-builder';\n\n/**\n * Formats a component attributes\n */\nexport const formatComponent = (component: any) => {\n  const { uid, modelName, connection, collectionName, info, category } = component;\n\n  return {\n    uid,\n    category,\n    apiId: modelName,\n    schema: {\n      displayName: get(info, 'displayName'),\n      description: get(info, 'description', ''),\n      icon: get(info, 'icon'),\n      connection,\n      collectionName,\n      pluginOptions: component.pluginOptions,\n      attributes: formatAttributes(component),\n    },\n  };\n};\n\n/**\n * Creates a component and handle the nested components sent with it\n */\nexport const createComponent = async ({ component, components = [] }: any) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newComponent = builder.createComponent(replaceTmpUIDs(component));\n\n  components.forEach((component: any) => {\n    if (!has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('component.create', { component: newComponent });\n\n  return newComponent;\n};\n\ntype ComponentToCreate = {\n  component: Schema.Component;\n  components?: Schema.Component[];\n};\n\nexport const editComponent = async (\n  uid: UID.Component,\n  { component, components = [] }: ComponentToCreate\n) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedComponent = builder.editComponent({\n    uid,\n    ...replaceTmpUIDs(component),\n  });\n\n  components.forEach((component) => {\n    if (!has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('component.update', { component: updatedComponent });\n\n  return updatedComponent;\n};\n\nexport const deleteComponent = async (uid: UID.Component) => {\n  const builder = createBuilder();\n\n  const deletedComponent = builder.deleteComponent(uid);\n\n  await builder.writeFiles();\n\n  strapi.eventHub.emit('component.delete', { component: deletedComponent });\n\n  return deletedComponent;\n};\n","import { join } from 'path';\nimport { nameToSlug, errors } from '@strapi/utils';\nimport type { Schema } from '@strapi/types';\nimport createBuilder from './schema-builder';\n\ntype Infos = {\n  name: string;\n};\n\ninterface WorkingComponent extends Schema.Component {\n  setUID: (uid: string) => WorkingComponent;\n  setDir: (dir: string) => WorkingComponent;\n  updateComponent: (oldUID: string, newUID: string) => void;\n}\n\n/**\n * Edit a category name and move components to the write folder\n */\nexport const editCategory = async (name: string, infos: Infos) => {\n  const newName = nameToSlug(infos.name);\n\n  // don't do anything the name doesn't change\n  if (name === newName) return;\n\n  if (!categoryExists(name)) {\n    throw new errors.ApplicationError('category not found');\n  }\n\n  if (categoryExists(newName)) {\n    throw new errors.ApplicationError('Name already taken');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach((component: WorkingComponent) => {\n    const oldUID = component.uid;\n    const newUID = `${newName}.${component.modelName}`;\n\n    // only edit the components in this specific category\n    if (component.category !== name) return;\n\n    component.setUID(newUID).setDir(join(strapi.dirs.app.components, newName));\n\n    builder.components.forEach((compo: WorkingComponent) => {\n      compo.updateComponent(oldUID, newUID);\n    });\n\n    builder.contentTypes.forEach((ct: WorkingComponent) => {\n      ct.updateComponent(oldUID, newUID);\n    });\n  });\n\n  await builder.writeFiles();\n\n  return newName;\n};\n\n/**\n * Deletes a category and its components\n */\nexport const deleteCategory = async (name: string) => {\n  if (!categoryExists(name)) {\n    throw new errors.ApplicationError('category not found');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach((component) => {\n    if (component.category === name) {\n      builder.deleteComponent(component.uid);\n    }\n  });\n\n  await builder.writeFiles();\n};\n\n/**\n * Checks if a category exists\n */\nconst categoryExists = (name: string) => {\n  const matchingIndex = Object.values(strapi.components).findIndex(\n    (component) => component.category === name\n  );\n\n  return matchingIndex > -1;\n};\n","export const getReservedNames = () => {\n  return {\n    // use kebab case everywhere since singularName and pluralName are validated that way\n    models: [\n      'boolean',\n      'date',\n      'date-time',\n      'time',\n      'upload',\n      'then', // https://github.com/strapi/strapi/issues/15557\n      'rest', // https://github.com/strapi/strapi/issues/13643\n    ],\n    // attributes are compared with snake_case(name), so only snake_case is needed here and camelCase + UPPER_CASE matches will still be caught\n    attributes: [\n      // TODO V5: these need to come from a centralized place so we don't break things accidentally in the future\n      'id',\n      'created_at',\n      'updated_at',\n      'published_at',\n      'created_by_id',\n      'updated_by_id',\n\n      // TODO v5: restricting 'locale' would be a breaking change in v4 but we will need it if this is not resolved: https://github.com/strapi/strapi/issues/10181\n\n      // not actually breaking but we'll leave it to avoid confusion\n      'created_by',\n      'updated_by',\n    ],\n  };\n  // strapi.db.getReservedNames();\n};\n","import * as path from 'path';\nimport * as fse from 'fs-extra';\nimport type { UID } from '@strapi/types';\n\n/**\n * Deletes the API folder of a contentType\n */\nexport async function clear(uid: UID.ContentType) {\n  // TODO double check if this is the correct way to get the apiName\n  const { apiName, modelName } = strapi.contentTypes[uid] as any;\n\n  const apiFolder = path.join(strapi.dirs.app.api, apiName);\n\n  await recursiveRemoveFiles(apiFolder, createDeleteApiFunction(modelName));\n  await deleteBackup(uid);\n}\n\n/**\n * Backups the API folder of a contentType\n * @param {string} uid content type uid\n */\nexport async function backup(uid: UID.ContentType) {\n  const { apiName } = strapi.contentTypes[uid] as any;\n\n  const apiFolder = path.join(strapi.dirs.app.api, apiName);\n  const backupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);\n\n  // backup the api folder\n  await fse.copy(apiFolder, backupFolder);\n}\n\n/**\n * Deletes an API backup folder\n */\nasync function deleteBackup(uid: UID.ContentType) {\n  const { apiName } = strapi.contentTypes[uid] as any;\n\n  const backupFolder = path.join(strapi.dirs.app.api, '.backup');\n  const apiBackupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);\n\n  await fse.remove(apiBackupFolder);\n\n  const list = await fse.readdir(backupFolder);\n  if (list.length === 0) {\n    await fse.remove(backupFolder);\n  }\n}\n\n/**\n * Rollbacks the API folder of a contentType\n */\nexport async function rollback(uid: UID.ContentType) {\n  const { apiName } = strapi.contentTypes[uid] as any;\n\n  const apiFolder = path.join(strapi.dirs.app.api, apiName);\n  const backupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);\n\n  try {\n    await fse.access(backupFolder);\n  } catch {\n    throw new Error('Cannot rollback api that was not backed up');\n  }\n\n  await fse.remove(apiFolder);\n  await fse.copy(backupFolder, apiFolder);\n  await deleteBackup(uid);\n}\n\n/**\n * Creates a delete function to clear an api folder\n */\nconst createDeleteApiFunction = (baseName: string) => {\n  /**\n   * Delets a file in an api.\n   * Will only update routes.json instead of deleting it if other routes are present\n   */\n  return async (filePath: string) => {\n    const fileName = path.basename(filePath, path.extname(filePath));\n\n    const isSchemaFile = filePath.endsWith(`${baseName}/schema.json`);\n    if (fileName === baseName || isSchemaFile) {\n      return fse.remove(filePath);\n    }\n  };\n};\n\n/**\n * Deletes a folder recursively using a delete function\n * @param {string} folder folder to delete\n */\nconst recursiveRemoveFiles = async (folder: string, deleteFn: (file: string) => unknown) => {\n  const filesName = await fse.readdir(folder);\n\n  for (const fileName of filesName) {\n    const filePath = path.join(folder, fileName);\n\n    const stat = await fse.stat(filePath);\n\n    if (stat.isDirectory()) {\n      await recursiveRemoveFiles(filePath, deleteFn);\n    } else {\n      await deleteFn(filePath);\n    }\n  }\n\n  const files = await fse.readdir(folder);\n  if (files.length === 0) {\n    await fse.remove(folder);\n  }\n};\n","import * as contentTypes from './content-types';\nimport * as components from './components';\nimport * as componentCategories from './component-categories';\nimport * as builder from './builder';\nimport * as apiHandler from './api-handler';\n\nexport default {\n  'content-types': contentTypes,\n  components,\n  'component-categories': componentCategories,\n  builder,\n  'api-handler': apiHandler,\n};\n","import type * as components from '../services/components';\nimport type * as builder from '../services/builder';\nimport type * as contentTypes from '../services/content-types';\nimport type * as componentCategories from '../services/component-categories';\nimport type * as apiHandler from '../services/api-handler';\n\ntype S = {\n  'content-types': typeof contentTypes;\n  components: typeof components;\n  'component-categories': typeof componentCategories;\n  builder: typeof builder;\n  'api-handler': typeof apiHandler;\n};\n\nexport function getService<T extends keyof S>(\n  name: T\n): S[T] extends (...args: any[]) => any ? ReturnType<S[T]> : S[T] {\n  return strapi.plugin('content-type-builder').service(name);\n}\n","import type { Context } from 'koa';\nimport { getService } from '../utils';\n\nexport default {\n  getReservedNames(ctx: Context) {\n    ctx.body = getService('builder').getReservedNames();\n  },\n};\n","/* eslint-disable no-template-curly-in-string */\nimport { yup, startsWithANumber } from '@strapi/utils';\nimport _ from 'lodash';\nimport { TestConfig } from 'yup';\n\nexport const validators = {\n  required: yup.boolean(),\n  unique: yup.boolean(),\n  minLength: yup.number().integer().positive(),\n  maxLength: yup.number().integer().positive(),\n};\n\nexport const NAME_REGEX = /^[A-Za-z][_0-9A-Za-z]*$/;\nexport const COLLECTION_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;\nexport const CATEGORY_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;\nexport const ICON_REGEX = /^[A-Za-z0-9][-A-Za-z0-9]*$/;\nexport const UID_REGEX = /^[A-Za-z0-9-_.~]*$/;\n\nexport type CommonTestConfig = TestConfig<unknown | undefined, Record<string, unknown>>;\n\nexport const isValidName: CommonTestConfig = {\n  name: 'isValidName',\n  message: `\\${path} must match the following regex: ${NAME_REGEX}`,\n  test: (val: unknown) => val === '' || NAME_REGEX.test(val as string),\n};\n\nexport const isValidIcon: CommonTestConfig = {\n  name: 'isValidIcon',\n  message: `\\${path} is not a valid icon name. Make sure your icon name starts with an alphanumeric character and only includes alphanumeric characters or dashes.`,\n  test: (val) => val === '' || ICON_REGEX.test(val as string),\n};\n\nexport const isValidUID: CommonTestConfig = {\n  name: 'isValidUID',\n  message: `\\${path} must match the following regex: ${UID_REGEX}`,\n  test: (val) => val === '' || UID_REGEX.test(val as string),\n};\n\nexport const isValidCategoryName: CommonTestConfig = {\n  name: 'isValidCategoryName',\n  message: `\\${path} must match the following regex: ${CATEGORY_NAME_REGEX}`,\n  test: (val) => val === '' || CATEGORY_NAME_REGEX.test(val as string),\n};\n\nexport const isValidCollectionName: CommonTestConfig = {\n  name: 'isValidCollectionName',\n  message: `\\${path} must match the following regex: ${COLLECTION_NAME_REGEX}`,\n  test: (val) => val === '' || COLLECTION_NAME_REGEX.test(val as string),\n};\n\nexport const isValidKey = (key: string): CommonTestConfig => ({\n  name: 'isValidKey',\n  message: `Attribute name '${key}' must match the following regex: ${NAME_REGEX}`,\n  test: () => NAME_REGEX.test(key),\n});\n\nexport const isValidEnum: CommonTestConfig = {\n  name: 'isValidEnum',\n  message: '${path} should not start with number',\n  test: (val) => val === '' || !startsWithANumber(val as string),\n};\n\nexport const areEnumValuesUnique: CommonTestConfig = {\n  name: 'areEnumValuesUnique',\n  message: '${path} cannot contain duplicate values',\n  test(values) {\n    const filtered = [...new Set(values as string[])];\n\n    return filtered.length === (values as string[]).length;\n  },\n};\n\nexport const isValidRegExpPattern: CommonTestConfig = {\n  name: 'isValidRegExpPattern',\n  message: '${path} must be a valid RexExp pattern string',\n  test: (val) => val === '' || !!new RegExp(val as string),\n};\n\nexport const isValidDefaultJSON: CommonTestConfig = {\n  name: 'isValidDefaultJSON',\n  message: '${path} is not a valid JSON',\n  test(val) {\n    if (val === undefined) {\n      return true;\n    }\n\n    if (_.isNumber(val) || _.isNull(val) || _.isObject(val) || _.isArray(val)) {\n      return true;\n    }\n\n    try {\n      JSON.parse(val as string);\n\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\nimport { isValidCategoryName } from './common';\n\nconst componentCategorySchema = yup\n  .object({\n    name: yup.string().min(3).test(isValidCategoryName).required('name.required'),\n  })\n  .noUnknown();\n\nexport default validateYupSchema(componentCategorySchema);\n","import type { Context } from 'koa';\nimport { getService } from '../utils';\nimport validateComponentCategory from './validation/component-category';\n\nexport default {\n  async editCategory(ctx: Context) {\n    const { body } = ctx.request;\n\n    try {\n      await validateComponentCategory(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService = getService('component-categories');\n\n    const newName = await componentCategoryService.editCategory(name, body);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name: newName });\n  },\n\n  async deleteCategory(ctx: Context) {\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService = getService('component-categories');\n\n    await componentCategoryService.deleteCategory(name);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name });\n  },\n};\n","import _ from 'lodash';\nimport { yup } from '@strapi/utils';\n\nimport type { TestContext } from 'yup';\nimport type { Attribute, Common, Schema } from '@strapi/types';\n\nimport { hasComponent } from '../../utils/attributes';\nimport { modelTypes, VALID_UID_TARGETS } from '../../services/constants';\nimport {\n  validators,\n  areEnumValuesUnique,\n  isValidDefaultJSON,\n  isValidName,\n  isValidEnum,\n  isValidUID,\n  isValidRegExpPattern,\n} from './common';\n\nexport type GetTypeValidatorOptions = {\n  types: ReadonlyArray<string>;\n  attributes?: Schema.Attributes;\n  modelType?: (typeof modelTypes)[keyof typeof modelTypes];\n};\n\nconst maxLengthIsGreaterThanOrEqualToMinLength = {\n  name: 'isGreaterThanMin',\n  message: 'maxLength must be greater or equal to minLength',\n  test(this: TestContext, value: unknown) {\n    const { minLength } = this.parent;\n    return !(!_.isUndefined(minLength) && !_.isUndefined(value) && (value as number) < minLength);\n  },\n};\n\nexport const getTypeValidator = (\n  attribute: Attribute.Any,\n  { types, modelType, attributes }: GetTypeValidatorOptions\n) => {\n  return yup.object({\n    type: yup\n      .string()\n      .oneOf([...types])\n      .required(),\n    configurable: yup.boolean().nullable(),\n    private: yup.boolean().nullable(),\n    pluginOptions: yup.object(),\n    ...getTypeShape(attribute, { modelType, attributes }),\n  } as any);\n};\n\nconst getTypeShape = (attribute: Attribute.Any, { modelType, attributes }: any = {}) => {\n  switch (attribute.type) {\n    /**\n     * complex types\n     */\n\n    case 'media': {\n      return {\n        multiple: yup.boolean(),\n        required: validators.required,\n        allowedTypes: yup\n          .array()\n          .of(yup.string().oneOf(['images', 'videos', 'files', 'audios']))\n          .min(1),\n      };\n    }\n\n    case 'uid': {\n      return {\n        required: validators.required,\n        targetField: yup\n          .string()\n          .oneOf(\n            Object.keys(attributes!).filter((key) =>\n              VALID_UID_TARGETS.includes(_.get(attributes![key] as any, 'type'))\n            )\n          )\n          .nullable(),\n        default: yup\n          .string()\n          .test(\n            'isValidDefaultUID',\n            'cannot define a default UID if the targetField is set',\n            function (value) {\n              const { targetField } = this.parent;\n              return !!(_.isNil(targetField) || _.isNil(value));\n            }\n          )\n          .test(isValidUID),\n        minLength: validators.minLength,\n        maxLength: validators.maxLength.max(256).test(maxLengthIsGreaterThanOrEqualToMinLength),\n        options: yup.object().shape({\n          separator: yup.string(),\n          lowercase: yup.boolean(),\n          decamelize: yup.boolean(),\n          customReplacements: yup.array().of(yup.array().of(yup.string()).min(2).max(2)),\n          preserveLeadingUnderscore: yup.boolean(),\n        }),\n      };\n    }\n\n    /**\n     * scalar types\n     */\n    case 'string':\n    case 'text': {\n      return {\n        default: yup.string(),\n        required: validators.required,\n        unique: validators.unique,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n        regex: yup.string().test(isValidRegExpPattern),\n      };\n    }\n    case 'richtext': {\n      return {\n        default: yup.string(),\n        required: validators.required,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n      };\n    }\n    case 'blocks': {\n      return {\n        required: validators.required,\n      };\n    }\n    case 'json': {\n      return {\n        default: yup.mixed().test(isValidDefaultJSON),\n        required: validators.required,\n      };\n    }\n    case 'enumeration': {\n      return {\n        enum: yup\n          .array()\n          .of(yup.string().test(isValidEnum).required())\n          .min(1)\n          .test(areEnumValuesUnique)\n          .required(),\n        default: yup.string().when('enum', (enumVal) => yup.string().oneOf(enumVal)),\n        enumName: yup.string().test(isValidName),\n        required: validators.required,\n      };\n    }\n    case 'password': {\n      return {\n        required: validators.required,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n      };\n    }\n    case 'email': {\n      return {\n        default: yup.string().email(),\n        required: validators.required,\n        unique: validators.unique,\n        minLength: validators.minLength,\n        maxLength: validators.maxLength,\n      };\n    }\n    case 'integer': {\n      return {\n        default: yup.number().integer(),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.number().integer(),\n        max: yup.number().integer(),\n      };\n    }\n    case 'biginteger': {\n      return {\n        default: yup.string().nullable().matches(/^\\d*$/),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.string().nullable().matches(/^\\d*$/),\n        max: yup.string().nullable().matches(/^\\d*$/),\n      };\n    }\n    case 'float': {\n      return {\n        default: yup.number(),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n    case 'decimal': {\n      return {\n        default: yup.number(),\n        required: validators.required,\n        unique: validators.unique,\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n    case 'time':\n    case 'datetime':\n    case 'date': {\n      return {\n        default: yup.string(),\n        required: validators.required,\n        unique: validators.unique,\n      };\n    }\n    case 'boolean': {\n      return {\n        default: yup.boolean(),\n        required: validators.required,\n      };\n    }\n\n    case 'component': {\n      return {\n        required: validators.required,\n        repeatable: yup.boolean(),\n        component: yup\n          .string()\n          .test({\n            name: 'Check max component nesting is 1 lvl',\n            test(compoUID: unknown) {\n              const targetCompo = strapi.components[compoUID as Common.UID.Component];\n              if (!targetCompo) return true; // ignore this error as it will fail beforehand\n\n              if (modelType === modelTypes.COMPONENT && hasComponent(targetCompo)) {\n                return this.createError({\n                  path: this.path,\n                  message: `${targetCompo.modelName} already is a nested component. You cannot have more than one level of nesting inside your components.`,\n                });\n              }\n              return true;\n            },\n          })\n          .required(),\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n\n    case 'dynamiczone': {\n      return {\n        required: validators.required,\n        components: yup\n          .array()\n          .of(yup.string().required())\n          .test('isArray', '${path} must be an array', (value) => Array.isArray(value))\n          .min(1),\n        min: yup.number(),\n        max: yup.number(),\n      };\n    }\n\n    default: {\n      return {};\n    }\n  }\n};\n","import { isUndefined } from 'lodash/fp';\nimport { yup } from '@strapi/utils';\nimport type { TestContext, TestFunction } from 'yup';\nimport type { Attribute } from '@strapi/types';\nimport { typeKinds, coreUids } from '../../services/constants';\nimport { isValidName } from './common';\n\nconst STRAPI_USER_RELATIONS = ['oneToOne', 'oneToMany'];\n\nconst isValidRelation = (validNatures: ReadonlyArray<string>): TestFunction<string | undefined> =>\n  function (this: TestContext, value) {\n    // NOTE: In case of an undefined value, delegate the check to .required()\n    if (value === undefined) {\n      return true;\n    }\n\n    if (this.parent.target === coreUids.STRAPI_USER) {\n      if (!validNatures.includes(value) || !isUndefined(this.parent.targetAttribute)) {\n        return this.createError({\n          path: this.path,\n          message: `must be one of the following values: ${STRAPI_USER_RELATIONS.join(', ')}`,\n        });\n      }\n    }\n\n    return validNatures.includes(value)\n      ? true\n      : this.createError({\n          path: this.path,\n          message: `must be one of the following values: ${validNatures.join(', ')}`,\n        });\n  };\n\nexport const getRelationValidator = (\n  attribute: Attribute.Relation,\n  allowedRelations: ReadonlyArray<string>\n) => {\n  const contentTypesUIDs = Object.keys(strapi.contentTypes)\n    .filter((key) => strapi.contentTypes[key as any].kind === typeKinds.COLLECTION_TYPE)\n    .filter((key) => !key.startsWith(coreUids.PREFIX) || key === coreUids.STRAPI_USER)\n    .concat(['__self__', '__contentType__']);\n\n  const base = {\n    type: yup.string().oneOf(['relation']).required(),\n    relation: yup.string().test('isValidRelation', isValidRelation(allowedRelations)).required(),\n    configurable: yup.boolean().nullable(),\n    private: yup.boolean().nullable(),\n    pluginOptions: yup.object(),\n  };\n\n  switch (attribute.relation) {\n    case 'oneToOne':\n    case 'oneToMany':\n    case 'manyToOne':\n    case 'manyToMany':\n    case 'morphOne':\n    case 'morphMany': {\n      return yup.object({\n        ...base,\n        target: yup.string().oneOf(contentTypesUIDs).required(),\n        targetAttribute: yup.string().test(isValidName).nullable(),\n      });\n    }\n    case 'morphToOne':\n    case 'morphToMany':\n    default: {\n      return yup.object({ ...base });\n    }\n  }\n};\n","import { yup } from '@strapi/utils';\nimport _ from 'lodash';\nimport { snakeCase } from 'lodash/fp';\nimport { modelTypes, FORBIDDEN_ATTRIBUTE_NAMES, typeKinds } from '../../services/constants';\nimport { getService } from '../../utils';\nimport { isValidKey, isValidCollectionName } from './common';\nimport { getTypeValidator } from './types';\nimport { getRelationValidator } from './relations';\n\ntype ModelTypeInput = (typeof modelTypes)[keyof typeof modelTypes];\n\ntype CreateAttributesInput = {\n  types: ReadonlyArray<string>;\n  relations: ReadonlyArray<string>;\n  modelType?: ModelTypeInput;\n};\n\nexport const createSchema = (\n  types: CreateAttributesInput['types'],\n  relations: CreateAttributesInput['relations'],\n  { modelType }: { modelType?: ModelTypeInput } = {}\n) => {\n  const shape = {\n    description: yup.string(),\n    draftAndPublish: yup.boolean(),\n    options: yup.object(),\n    pluginOptions: yup.object(),\n    collectionName: yup.string().nullable().test(isValidCollectionName),\n    attributes: createAttributesValidator({ types, relations, modelType }),\n    reviewWorkflows: yup.boolean(),\n  } as any;\n\n  if (modelType === modelTypes.CONTENT_TYPE) {\n    shape.kind = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]).nullable();\n  }\n\n  return yup.object(shape).noUnknown();\n};\n\nconst createAttributesValidator = ({ types, modelType, relations }: CreateAttributesInput) => {\n  return yup.lazy((attributes) => {\n    return yup\n      .object()\n      .shape(\n        _.mapValues(attributes, (attribute, key) => {\n          if (isForbiddenKey(key)) {\n            return forbiddenValidator();\n          }\n\n          if (isConflictingKey(key, attributes)) {\n            return conflictingKeysValidator(key);\n          }\n\n          if (attribute.type === 'relation') {\n            return getRelationValidator(attribute, relations).test(isValidKey(key));\n          }\n\n          if (_.has(attribute, 'type')) {\n            return getTypeValidator(attribute, { types, modelType, attributes }).test(\n              isValidKey(key)\n            );\n          }\n\n          return typeOrRelationValidator;\n        })\n      )\n      .required('attributes.required');\n  });\n};\n\nconst isConflictingKey = (key: string, attributes: Record<string, any>) => {\n  const snakeCaseKey = snakeCase(key);\n\n  return Object.keys(attributes).some((existingKey) => {\n    if (existingKey === key) return false; // don't compare against itself\n    return snakeCase(existingKey) === snakeCaseKey;\n  });\n};\n\nconst isForbiddenKey = (key: string) => {\n  const snakeCaseKey = snakeCase(key);\n  const reservedNames = [\n    ...FORBIDDEN_ATTRIBUTE_NAMES,\n    ...getService('builder').getReservedNames().attributes,\n  ];\n\n  return reservedNames.some((reserved) => {\n    return snakeCase(reserved) === snakeCaseKey;\n  });\n};\n\nconst forbiddenValidator = () => {\n  const reservedNames = [\n    ...FORBIDDEN_ATTRIBUTE_NAMES,\n    ...getService('builder').getReservedNames().attributes,\n  ];\n\n  return yup.mixed().test({\n    name: 'forbiddenKeys',\n    message: `Attribute keys cannot be one of ${reservedNames.join(', ')}`,\n    test: () => false,\n  });\n};\n\nconst conflictingKeysValidator = (key: string) => {\n  return yup.mixed().test({\n    name: 'conflictingKeys',\n    message: `Attribute ${key} conflicts with an existing key`,\n    test: () => false,\n  });\n};\n\nconst typeOrRelationValidator = yup.object().test({\n  name: 'mustHaveTypeOrTarget',\n  message: 'Attribute must have either a type or a target',\n  test: () => false,\n});\n","import type { Attribute } from '@strapi/types';\n\nexport const hasDefaultAttribute = (\n  attribute: Attribute.Any\n): attribute is Attribute.Any & Attribute.DefaultOption<unknown> => {\n  return 'default' in attribute;\n};\n","import type { Schema } from '@strapi/types';\nimport _ from 'lodash';\nimport { hasDefaultAttribute } from '../../utils/typeguards';\n\nexport const removeEmptyDefaults = (\n  data: Partial<Schema.ContentType> | Partial<Schema.Component> | undefined\n) => {\n  const { attributes } = data || {};\n\n  Object.keys(attributes!).forEach((attributeName) => {\n    const attribute = attributes![attributeName];\n\n    if (hasDefaultAttribute(attribute) && attribute.default === '') {\n      attribute.default = undefined;\n    }\n  });\n};\n\nexport const removeDeletedUIDTargetFields = (data: Schema.ContentType) => {\n  if (_.has(data, 'attributes')) {\n    Object.values(data.attributes).forEach((attribute) => {\n      if (\n        attribute.type === 'uid' &&\n        !_.isUndefined(attribute.targetField) &&\n        !_.has(data.attributes, attribute.targetField)\n      ) {\n        attribute.targetField = undefined;\n      }\n    });\n  }\n};\n","import _ from 'lodash';\nimport { yup, validateYupSchema } from '@strapi/utils';\n\nimport type { Attribute } from '@strapi/types';\nimport { modelTypes, DEFAULT_TYPES } from '../../services/constants';\nimport { isValidCategoryName, isValidIcon } from './common';\nimport { createSchema } from './model-schema';\nimport { removeEmptyDefaults } from './data-transform';\n\nexport const VALID_RELATIONS = ['oneToOne', 'oneToMany'];\nexport const VALID_TYPES = [...DEFAULT_TYPES, 'component', 'customField'];\n\nexport const componentSchema = createSchema(VALID_TYPES, VALID_RELATIONS, {\n  modelType: modelTypes.COMPONENT,\n})\n  .shape({\n    displayName: yup.string().min(1).required('displayName.required'),\n    icon: yup.string().nullable().test(isValidIcon),\n    category: yup.string().nullable().test(isValidCategoryName).required('category.required'),\n  })\n  .required()\n  .noUnknown();\n\nexport const nestedComponentSchema = yup.array().of(\n  componentSchema\n    .shape({\n      uid: yup.string(),\n      tmpUID: yup.string(),\n    })\n    .test({\n      name: 'mustHaveUIDOrTmpUID',\n      message: 'Component must have a uid or a tmpUID',\n      test(attr: unknown) {\n        if (_.has(attr, 'uid') && _.has(attr, 'tmpUID')) return false;\n        if (!_.has(attr, 'uid') && !_.has(attr, 'tmpUID')) return false;\n        return true;\n      },\n    })\n    .required()\n    .noUnknown()\n);\n\nexport const componentInputSchema = yup\n  .object({\n    component: componentSchema,\n    components: nestedComponentSchema,\n  })\n  .noUnknown();\n\nexport const validateComponentInput = validateYupSchema(componentInputSchema);\n\nconst updateComponentInputSchema = yup\n  .object({\n    component: componentSchema,\n    components: nestedComponentSchema,\n  })\n  .noUnknown();\n\nexport const validateUpdateComponentInput = (data: {\n  component?: Attribute.Component;\n  components?: Attribute.Component[];\n}) => {\n  if (_.has(data, 'component') && data.component) {\n    removeEmptyDefaults(data.component);\n  }\n\n  if (_.has(data, 'components') && Array.isArray(data.components)) {\n    data.components.forEach((data) => {\n      if (_.has(data, 'uid')) {\n        removeEmptyDefaults(data);\n      }\n    });\n  }\n\n  return validateYupSchema(updateComponentInputSchema)(data);\n};\n","import _ from 'lodash';\nimport type { Context } from 'koa';\nimport type { Common } from '@strapi/types';\nimport { getService } from '../utils';\nimport { validateComponentInput, validateUpdateComponentInput } from './validation/component';\n\n/**\n * Components controller\n */\n\nexport default {\n  /**\n   * GET /components handler\n   * Returns a list of available components\n   * @param {Object} ctx - koa context\n   */\n  async getComponents(ctx: Context) {\n    const componentService = getService('components');\n\n    const data = Object.keys(strapi.components).map((uid) => {\n      return componentService.formatComponent(strapi.components[uid as Common.UID.Component]);\n    });\n\n    ctx.send({ data });\n  },\n\n  /**\n   * GET /components/:uid\n   * Returns a specific component\n   * @param {Object} ctx - koa context\n   */\n  async getComponent(ctx: Context) {\n    const { uid } = ctx.params;\n\n    const component = strapi.components[uid];\n\n    if (!component) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    const componentService = getService('components');\n\n    ctx.send({ data: componentService.formatComponent(component) });\n  },\n\n  /**\n   * POST /components\n   * Creates a component and returns its infos\n   * @param {Object} ctx - koa context\n   */\n  async createComponent(ctx: Context) {\n    const { body } = ctx.request;\n\n    try {\n      await validateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService = getService('components');\n\n      const component = await componentService.createComponent({\n        component: body.component,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);\n    }\n  },\n\n  /**\n   * PUT /components/:uid\n   * Updates a component and return its infos\n   * @param {Object} ctx - koa context - enhanced koa context\n   */\n  async updateComponent(ctx: Context) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService = getService('components');\n\n      const component = (await componentService.editComponent(uid, {\n        component: body.component,\n        components: body.components,\n      })) as any;\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n\n      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);\n    }\n  },\n\n  /**\n   * DELETE /components/:uid\n   * Deletes a components and returns its old infos\n   * @param {Object} ctx - koa context\n   */\n  async deleteComponent(ctx: Context) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService = getService('components');\n\n      const component = await componentService.deleteComponent(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);\n    }\n  },\n};\n","/* eslint-disable no-template-curly-in-string */ // yup templates need to be in this format\n\nimport { flatMap, getOr, has, snakeCase } from 'lodash/fp';\nimport { yup, validateYupSchema } from '@strapi/utils';\n\nimport type { Schema, UID } from '@strapi/types';\nimport { getService } from '../../utils';\nimport { modelTypes, DEFAULT_TYPES, typeKinds } from '../../services/constants';\nimport { createSchema } from './model-schema';\nimport { removeEmptyDefaults, removeDeletedUIDTargetFields } from './data-transform';\nimport { nestedComponentSchema } from './component';\n\n// Input flattens some fields of the \"info\" into the root type\nexport type CreateContentTypeInput = {\n  contentType?: Partial<Schema.ContentType> & Partial<Schema.ContentTypeInfo>;\n  components?: Array<Partial<Schema.Component> & Partial<Schema.Info> & { tmpUID?: UID.Component }>;\n  singularName: Schema.ContentTypeInfo['singularName'];\n  attributes: Schema.Attributes & Record<string, any>;\n  kind: Schema.ContentTypeKind;\n  collectionName?: Schema.CollectionType['collectionName'];\n  pluralName: Schema.ContentTypeInfo['pluralName'];\n  displayName: Schema.ContentTypeInfo['displayName'];\n  description: Schema.ContentTypeInfo['description'];\n  options?: Schema.Options;\n  draftAndPublish?: Schema.Options['draftAndPublish'];\n  pluginOptions?: Schema.ContentType['pluginOptions'];\n  config?: object;\n};\n\n/**\n * Allowed relation per type kind\n */\nconst VALID_RELATIONS = {\n  [typeKinds.SINGLE_TYPE]: [\n    'oneToOne',\n    'oneToMany',\n    'morphOne',\n    'morphMany',\n    'morphToOne',\n    'morphToMany',\n  ],\n  [typeKinds.COLLECTION_TYPE]: [\n    'oneToOne',\n    'oneToMany',\n    'manyToOne',\n    'manyToMany',\n    'morphOne',\n    'morphMany',\n    'morphToOne',\n    'morphToMany',\n  ],\n} as const;\n\n/**\n * Allowed types\n */\nconst VALID_TYPES = [...DEFAULT_TYPES, 'uid', 'component', 'dynamiczone', 'customField'];\n\n/**\n * Returns a yup schema to validate a content type payload\n */\nconst createContentTypeSchema = (data: CreateContentTypeInput, { isEdition = false } = {}) => {\n  const kind: keyof typeof VALID_RELATIONS = getOr(\n    typeKinds.COLLECTION_TYPE,\n    'contentType.kind',\n    data\n  );\n  const contentTypeSchema = createSchema(VALID_TYPES, VALID_RELATIONS[kind] || [], {\n    modelType: modelTypes.CONTENT_TYPE,\n  })\n    .shape({\n      displayName: yup.string().min(1).required(),\n      singularName: yup\n        .string()\n        .min(1)\n        .test(nameIsAvailable(isEdition))\n        .test(forbiddenContentTypeNameValidator())\n        .isKebabCase()\n        .required(),\n      pluralName: yup\n        .string()\n        .min(1)\n        .test(nameIsAvailable(isEdition))\n        .test(nameIsNotExistingCollectionName(isEdition)) // TODO: v5: require singularName to not match a collection name\n        .test(forbiddenContentTypeNameValidator())\n        .isKebabCase()\n        .required(),\n    })\n    .test(\n      'singularName-not-equal-pluralName',\n      '${path}: singularName and pluralName should be different',\n      (value) => value.singularName !== value.pluralName\n    );\n\n  return yup\n    .object({\n      // FIXME .noUnknown(false) will strip off the unwanted properties without throwing an error\n      // Why not having .noUnknown() ? Because we want to be able to add options relatable to EE features\n      // without having any reference to them in CE.\n      // Why not handle an \"options\" object in the content-type ? The admin panel needs lots of rework\n      // to be able to send this options object instead of top-level attributes.\n      // @nathan-pichon 20/02/2023\n      contentType: contentTypeSchema.required().noUnknown(false),\n      components: nestedComponentSchema,\n    })\n    .noUnknown();\n};\n\n/**\n * Validator for content type creation\n */\nexport const validateContentTypeInput = (data: CreateContentTypeInput) => {\n  return validateYupSchema(createContentTypeSchema(data))(data);\n};\n\n/**\n * Validator for content type edition\n */\nexport const validateUpdateContentTypeInput = (data: CreateContentTypeInput) => {\n  if (has('contentType', data)) {\n    removeEmptyDefaults(data.contentType);\n    removeDeletedUIDTargetFields(data.contentType as Schema.ContentType);\n  }\n\n  if (has('components', data) && Array.isArray(data.components)) {\n    data.components.forEach((comp) => {\n      if (has('uid', comp)) {\n        removeEmptyDefaults(comp as Schema.Component);\n      }\n    });\n  }\n\n  return validateYupSchema(createContentTypeSchema(data, { isEdition: true }))(data);\n};\n\nconst forbiddenContentTypeNameValidator = () => {\n  const reservedNames = getService('builder').getReservedNames().models;\n\n  return {\n    name: 'forbiddenContentTypeName',\n    message: `Content Type name cannot be one of ${reservedNames.join(', ')}`,\n    test(value: unknown) {\n      if (typeof value !== 'string') {\n        return true;\n      }\n      // compare snake case to check the actual column names that will be used in the database\n      return reservedNames.every((reservedName) => snakeCase(reservedName) !== snakeCase(value));\n    },\n  };\n};\n\nconst nameIsAvailable = (isEdition: boolean) => {\n  // TODO TS: if strapi.contentTypes (ie, ContentTypes) works as an ArrayLike and is used like this, we may want to ensure it is typed so that it can be without using as\n  const usedNames = flatMap((ct: Schema.ContentType) => {\n    return [ct.info?.singularName, ct.info?.pluralName];\n  })(strapi.contentTypes as any);\n\n  return {\n    name: 'nameAlreadyUsed',\n    message: 'contentType: name `${value}` is already being used by another content type.',\n    test(value: unknown) {\n      // don't check on edition\n      if (isEdition) return true;\n\n      // ignore if not a string (will be caught in another validator)\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      // compare snake case to check the actual column names that will be used in the database\n      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));\n    },\n  };\n};\n\nconst nameIsNotExistingCollectionName = (isEdition: boolean) => {\n  const usedNames = Object.keys(strapi.contentTypes).map(\n    (key) => strapi.contentTypes[key as UID.ContentType].collectionName\n  ) as string[];\n\n  return {\n    name: 'nameAlreadyUsed',\n    message: 'contentType: name `${value}` is already being used by another content type.',\n    test(value: unknown) {\n      // don't check on edition\n      if (isEdition) return true;\n\n      // ignore if not a string (will be caught in another validator)\n      if (typeof value !== 'string') {\n        return true;\n      }\n\n      // compare snake case to check the actual column names that will be used in the database\n      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));\n    },\n  };\n};\n\n/**\n * Validates type kind\n */\nconst kindSchema = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]);\n\nexport const validateKind = validateYupSchema(kindSchema);\n","import _ from 'lodash';\nimport type { Context } from 'koa';\nimport 'koa-bodyparser';\n\nimport { contentTypes } from '@strapi/utils';\nimport type { UID } from '@strapi/types';\nimport { getService } from '../utils';\nimport {\n  validateContentTypeInput,\n  validateUpdateContentTypeInput,\n  validateKind,\n} from './validation/content-type';\n\nconst { hasDraftAndPublish } = contentTypes;\n\nexport default {\n  async getContentTypes(ctx: Context) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypeService = getService('content-types');\n\n    const contentTypes = Object.keys(strapi.contentTypes)\n      .filter(\n        (uid) =>\n          !kind ||\n          _.get(strapi.contentTypes[uid as UID.ContentType], 'kind', 'collectionType') === kind\n      )\n      .map((uid) =>\n        contentTypeService.formatContentType(strapi.contentTypes[uid as UID.ContentType])\n      );\n\n    ctx.send({\n      data: contentTypes,\n    });\n  },\n\n  getContentType(ctx: Context) {\n    const { uid } = ctx.params;\n\n    const contentType = strapi.contentTypes[uid];\n\n    if (!contentType) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    const contentTypeService = getService('content-types');\n\n    ctx.send({ data: contentTypeService.formatContentType(contentType) });\n  },\n\n  async createContentType(ctx: Context) {\n    const { body } = ctx.request;\n\n    try {\n      await validateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = getService('content-types');\n\n      const contentType = await contentTypeService.createContentType({\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      const metricsPayload = {\n        eventProperties: {\n          kind: contentType.kind,\n          hasDraftAndPublish: hasDraftAndPublish(contentType.schema),\n        },\n      };\n\n      if (_.isEmpty(strapi.api)) {\n        await strapi.telemetry.send('didCreateFirstContentType', metricsPayload);\n      } else {\n        await strapi.telemetry.send('didCreateContentType', metricsPayload);\n      }\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: contentType.uid } }, 201);\n    } catch (err) {\n      strapi.log.error(err);\n      await strapi.telemetry.send('didNotCreateContentType', {\n        eventProperties: { error: (err as Error).message || err },\n      });\n      ctx.send({ error: (err as Error).message || 'Unknown error' }, 400);\n    }\n  },\n\n  async updateContentType(ctx: Context) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = getService('content-types');\n\n      const component = await contentTypeService.editContentType(uid, {\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as Error)?.message || 'Unknown error' }, 400);\n    }\n  },\n\n  async deleteContentType(ctx: Context) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = getService('content-types');\n\n      const component = await contentTypeService.deleteContentType(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: (error as Error)?.message || 'Unknown error' }, 400);\n    }\n  },\n};\n","import builder from './builder';\nimport componentCategories from './component-categories';\nimport components from './components';\nimport contentTypes from './content-types';\n\nconst exportObject = {\n  builder,\n  'component-categories': componentCategories,\n  components,\n  'content-types': contentTypes,\n};\n\nexport default exportObject;\n","export default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      path: '/reserved-names',\n      handler: 'builder.getReservedNames',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types',\n      handler: 'content-types.getContentTypes',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-types/:uid',\n      handler: 'content-types.getContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/content-types',\n      handler: 'content-types.createContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/content-types/:uid',\n      handler: 'content-types.updateContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/content-types/:uid',\n      handler: 'content-types.deleteContentType',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/components',\n      handler: 'components.getComponents',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/components/:uid',\n      handler: 'components.getComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/components',\n      handler: 'components.createComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/components/:uid',\n      handler: 'components.updateComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/components/:uid',\n      handler: 'components.deleteComponent',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/component-categories/:name',\n      handler: 'component-categories.editCategory',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/component-categories/:name',\n      handler: 'component-categories.deleteCategory',\n      config: {\n        policies: [\n          {\n            name: 'admin::hasPermissions',\n            config: { actions: ['plugin::content-type-builder.read'] },\n          },\n        ],\n      },\n    },\n  ],\n};\n","export default {\n  type: 'content-api',\n  routes: [\n    {\n      method: 'GET',\n      path: '/content-types',\n      handler: 'content-types.getContentTypes',\n    },\n    {\n      method: 'GET',\n      path: '/content-types/:uid',\n      handler: 'content-types.getContentType',\n    },\n    {\n      method: 'GET',\n      path: '/components',\n      handler: 'components.getComponents',\n    },\n    {\n      method: 'GET',\n      path: '/components/:uid',\n      handler: 'components.getComponent',\n    },\n  ],\n};\n","import admin from './admin';\nimport contentApi from './content-api';\n\nexport default {\n  admin,\n  'content-api': contentApi,\n};\n","// eslint-disable-next-line import/no-extraneous-dependencies\nimport '@strapi/types';\n\nimport config from './config';\nimport bootstrap from './bootstrap';\nimport services from './services';\nimport controllers from './controllers';\nimport routes from './routes';\n\nexport default () => ({\n  config,\n  bootstrap,\n  services,\n  controllers,\n  routes,\n});\n"],"names":["strapi","ApplicationError","path","uid","fse","createComponentBuilder","components","contentTypes","createContentTypeBuilder","contentTypesUtils","builder","options","apiHandler","component","componentCategories","VALID_RELATIONS","VALID_TYPES","data","has","controllers"],"mappings":"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"}