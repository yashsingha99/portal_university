{"version":3,"file":"index.mjs","sources":["../../../server/src/routes/serve-admin-panel.ts","../../../server/src/utils/index.js","../../../server/src/strategies/admin.ts","../../../server/src/services/constants.ts","../../../server/src/strategies/api-token.ts","../../../server/src/register.ts","../../../ee/server/src/migrations/audit-logs-table.ts","../../../ee/server/src/constants/workflows.ts","../../../ee/server/src/migrations/review-workflows-stages-color.ts","../../../ee/server/src/utils/index.ts","../../../ee/server/src/migrations/review-workflows-stages-roles.ts","../../../ee/server/src/migrations/review-workflows-workflow-name.ts","../../../ee/server/src/migrations/review-workflows-content-types.ts","../../../ee/server/src/utils/persisted-tables.ts","../../../ee/server/src/migrations/review-workflows-stage-attribute.ts","../../../ee/server/src/utils/review-workflows.ts","../../../ee/server/src/migrations/review-workflows-deleted-ct-in-workflows.ts","../../../ee/server/src/services/audit-logs.ts","../../../ee/server/src/middlewares/review-workflows.ts","../../../ee/server/src/register.ts","../../../ee/server/src/content-types/workflow/index.ts","../../../ee/server/src/content-types/workflow-stage/index.ts","../../../ee/server/src/content-types/index.ts","../../../server/src/config/admin-actions.ts","../../../server/src/config/admin-conditions.ts","../../../server/src/bootstrap.ts","../../../ee/server/src/config/admin-actions.ts","../../../ee/server/src/bootstrap.ts","../../../server/src/destroy.ts","../../../ee/server/src/destroy.ts","../../../ee/server/src/routes/utils.ts","../../../ee/server/src/routes/sso.ts","../../../ee/server/src/routes/license-limit.ts","../../../ee/server/src/routes/audit-logs.ts","../../../ee/server/src/routes/review-workflows.ts","../../../ee/server/src/routes/index.ts","../../../ee/server/src/utils/sso-lock.ts","../../../ee/server/src/services/auth.ts","../../../server/src/services/passport/local-strategy.ts","../../../server/src/services/passport.ts","../../../ee/server/src/services/passport/provider-registry.ts","../../../ee/server/src/services/passport/sso.ts","../../../ee/server/src/services/passport.ts","../../../ee/server/src/services/role.ts","../../../server/src/domain/user.ts","../../../ee/server/src/services/user.ts","../../../ee/server/src/services/metrics.ts","../../../ee/server/src/services/seat-enforcement.ts","../../../ee/server/src/services/review-workflows/workflows/content-types.ts","../../../ee/server/src/services/review-workflows/workflows/index.ts","../../../ee/server/src/services/review-workflows/stages.ts","../../../ee/server/src/services/review-workflows/stage-permissions.ts","../../../ee/server/src/services/review-workflows/assignees.ts","../../../ee/server/src/constants/webhookEvents.ts","../../../ee/server/src/services/review-workflows/review-workflows.ts","../../../ee/server/src/services/review-workflows/validation.ts","../../../ee/server/src/services/review-workflows/entity-service-decorator.ts","../../../ee/server/src/services/review-workflows/metrics/index.ts","../../../ee/server/src/services/review-workflows/metrics/weekly-metrics.ts","../../../ee/server/src/services/index.ts","../../../ee/server/src/validation/authentication.ts","../../../ee/server/src/controllers/authentication-utils/constants.ts","../../../ee/server/src/controllers/authentication-utils/utils.ts","../../../ee/server/src/controllers/authentication-utils/middlewares.ts","../../../ee/server/src/controllers/authentication.ts","../../../ee/server/src/validation/role.ts","../../../ee/server/src/controllers/role.ts","../../../server/src/domain/action/index.ts","../../../server/src/validation/common-functions/check-fields-are-correctly-nested.ts","../../../server/src/validation/common-functions/check-fields-dont-have-duplicates.ts","../../../server/src/validation/common-validators.ts","../../../server/src/validation/user.ts","../../../ee/server/src/validation/user.ts","../../../ee/server/src/controllers/user.ts","../../../ee/server/src/validation/audit-logs.ts","../../../ee/server/src/controllers/audit-logs.ts","../../../ee/server/src/controllers/admin.ts","../../../ee/server/src/validation/review-workflows.ts","../../../ee/server/src/controllers/workflows/index.ts","../../../ee/server/src/controllers/workflows/stages/index.ts","../../../ee/server/src/controllers/workflows/assignees/index.ts","../../../ee/server/src/controllers/index.ts"],"sourcesContent":["import type { Context, Next } from 'koa';\nimport { resolve, join, extname, basename } from 'path';\nimport fse from 'fs-extra';\nimport koaStatic from 'koa-static';\nimport type { Strapi } from '@strapi/types';\n\nconst registerAdminPanelRoute = ({ strapi }: { strapi: Strapi }) => {\n  let buildDir = resolve(strapi.dirs.dist.root, 'build');\n\n  if (!fse.pathExistsSync(buildDir)) {\n    buildDir = resolve(__dirname, '../../build');\n  }\n\n  const serveAdminMiddleware = async (ctx: Context, next: Next) => {\n    await next();\n\n    if (ctx.method !== 'HEAD' && ctx.method !== 'GET') {\n      return;\n    }\n\n    if (ctx.body != null || ctx.status !== 404) {\n      return;\n    }\n\n    ctx.type = 'html';\n    ctx.body = fse.createReadStream(join(buildDir, 'index.html'));\n  };\n\n  strapi.server.routes([\n    {\n      method: 'GET',\n      path: `${strapi.config.admin.path}/:path*`,\n      handler: [\n        serveAdminMiddleware,\n        serveStatic(buildDir, {\n          maxage: 31536000,\n          defer: false,\n          index: 'index.html',\n          setHeaders(res: any, path: any) {\n            const ext = extname(path);\n            // publicly cache static files to avoid unnecessary network & disk access\n            if (ext !== '.html') {\n              res.setHeader('cache-control', 'public, max-age=31536000, immutable');\n            }\n          },\n        }),\n      ],\n      config: { auth: false },\n    },\n  ]);\n};\n\n// serveStatic is not supposed to be used to serve a folder that have sub-folders\nconst serveStatic = (filesDir: any, koaStaticOptions = {}) => {\n  const serve = koaStatic(filesDir, koaStaticOptions);\n\n  return async (ctx: Context, next: Next) => {\n    const prev = ctx.path;\n    const newPath = basename(ctx.path);\n\n    ctx.path = newPath;\n    await serve(ctx, async () => {\n      ctx.path = prev;\n      await next();\n      ctx.path = newPath;\n    });\n    ctx.path = prev;\n  };\n};\n\nexport default registerAdminPanelRoute;\n","import '@strapi/types';\n\nconst getService = (name) => {\n  return strapi.service(`admin::${name}`);\n};\n\nexport { getService };\n","import type { Context } from 'koa';\nimport { getService } from '../utils';\n\n/** @type {import('.').AuthenticateFunction} */\nexport const authenticate = async (ctx: Context) => {\n  const { authorization } = ctx.request.header;\n\n  if (!authorization) {\n    return { authenticated: false };\n  }\n\n  const parts = authorization.split(/\\s+/);\n\n  if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {\n    return { authenticated: false };\n  }\n\n  const token = parts[1];\n  const { payload, isValid } = getService('token').decodeJwtToken(token);\n\n  if (!isValid) {\n    return { authenticated: false };\n  }\n\n  const user = await strapi\n    .query('admin::user')\n    .findOne({ where: { id: payload.id }, populate: ['roles'] });\n\n  if (!user || !(user.isActive === true)) {\n    return { authenticated: false };\n  }\n\n  const userAbility = await getService('permission').engine.generateUserAbility(user);\n\n  // TODO: use the ability from ctx.state.auth instead of\n  // ctx.state.userAbility, and remove the assign below\n  ctx.state.userAbility = userAbility;\n  ctx.state.user = user;\n\n  return {\n    authenticated: true,\n    credentials: user,\n    ability: userAbility,\n  };\n};\n\nexport const name = 'admin';\n\n/** @type {import('.').AuthStrategy} */\nexport default {\n  name,\n  authenticate,\n};\n","const DAY_IN_MS = 24 * 60 * 60 * 1000;\n\nconst constants = {\n  CONTENT_TYPE_SECTION: 'contentTypes',\n  SUPER_ADMIN_CODE: 'strapi-super-admin',\n  EDITOR_CODE: 'strapi-editor',\n  AUTHOR_CODE: 'strapi-author',\n  READ_ACTION: 'plugin::content-manager.explorer.read',\n  CREATE_ACTION: 'plugin::content-manager.explorer.create',\n  UPDATE_ACTION: 'plugin::content-manager.explorer.update',\n  DELETE_ACTION: 'plugin::content-manager.explorer.delete',\n  PUBLISH_ACTION: 'plugin::content-manager.explorer.publish',\n  API_TOKEN_TYPE: {\n    READ_ONLY: 'read-only',\n    FULL_ACCESS: 'full-access',\n    CUSTOM: 'custom',\n  },\n  // The front-end only displays these values\n  API_TOKEN_LIFESPANS: {\n    UNLIMITED: null,\n    DAYS_7: 7 * DAY_IN_MS,\n    DAYS_30: 30 * DAY_IN_MS,\n    DAYS_90: 90 * DAY_IN_MS,\n  },\n  TRANSFER_TOKEN_TYPE: {\n    PUSH: 'push',\n    PULL: 'pull',\n  },\n  TRANSFER_TOKEN_LIFESPANS: {\n    UNLIMITED: null,\n    DAYS_7: 7 * DAY_IN_MS,\n    DAYS_30: 30 * DAY_IN_MS,\n    DAYS_90: 90 * DAY_IN_MS,\n  },\n};\n\nexport default constants;\n","import type { Context } from 'koa';\nimport { castArray, isNil } from 'lodash/fp';\nimport { differenceInHours, parseISO } from 'date-fns';\nimport { errors } from '@strapi/utils';\nimport constants from '../services/constants';\nimport { getService } from '../utils';\nimport '@strapi/types';\n\nconst { UnauthorizedError, ForbiddenError } = errors;\n\nconst isReadScope = (scope: any) => scope.endsWith('find') || scope.endsWith('findOne');\n\nconst extractToken = (ctx: Context) => {\n  if (ctx.request && ctx.request.header && ctx.request.header.authorization) {\n    const parts = ctx.request.header.authorization.split(/\\s+/);\n\n    if (parts[0].toLowerCase() !== 'bearer' || parts.length !== 2) {\n      return null;\n    }\n\n    return parts[1];\n  }\n\n  return null;\n};\n\n/**\n * Authenticate the validity of the token\n */\nexport const authenticate = async (ctx: Context) => {\n  const apiTokenService = getService('api-token');\n  const token = extractToken(ctx);\n\n  if (!token) {\n    return { authenticated: false };\n  }\n\n  // @ts-ignore\n  const apiToken = await apiTokenService.getBy({\n    accessKey: apiTokenService.hash(token),\n  });\n\n  // token not found\n  if (!apiToken) {\n    return { authenticated: false };\n  }\n\n  const currentDate = new Date();\n\n  if (!isNil(apiToken.expiresAt)) {\n    const expirationDate = new Date(apiToken.expiresAt);\n    // token has expired\n    if (expirationDate < currentDate) {\n      return { authenticated: false, error: new UnauthorizedError('Token expired') };\n    }\n  }\n\n  // update lastUsedAt if the token has not been used in the last hour\n  // @ts-ignore\n  const hoursSinceLastUsed = differenceInHours(currentDate, parseISO(apiToken.lastUsedAt));\n  if (hoursSinceLastUsed >= 1) {\n    await strapi.query('admin::api-token').update({\n      where: { id: apiToken.id },\n      data: { lastUsedAt: currentDate },\n    });\n  }\n\n  if (apiToken.type === constants.API_TOKEN_TYPE.CUSTOM) {\n    const ability = await strapi.contentAPI.permissions.engine.generateAbility(\n      apiToken.permissions.map((action: any) => ({ action }))\n    );\n\n    return { authenticated: true, ability, credentials: apiToken };\n  }\n\n  return { authenticated: true, credentials: apiToken };\n};\n\n/**\n * Verify the token has the required abilities for the requested scope\n *\n *  @type {import('.').VerifyFunction}\n */\nexport const verify = (auth: any, config: any) => {\n  const { credentials: apiToken, ability } = auth;\n\n  if (!apiToken) {\n    throw new UnauthorizedError('Token not found');\n  }\n\n  const currentDate = new Date();\n\n  if (!isNil(apiToken.expiresAt)) {\n    const expirationDate = new Date(apiToken.expiresAt);\n    // token has expired\n    if (expirationDate < currentDate) {\n      throw new UnauthorizedError('Token expired');\n    }\n  }\n\n  // Full access\n  if (apiToken.type === constants.API_TOKEN_TYPE.FULL_ACCESS) {\n    return;\n  }\n\n  // Read only\n  if (apiToken.type === constants.API_TOKEN_TYPE.READ_ONLY) {\n    /**\n     * If you don't have `full-access` you can only access `find` and `findOne`\n     * scopes. If the route has no scope, then you can't get access to it.\n     */\n    const scopes = castArray(config.scope);\n\n    if (config.scope && scopes.every(isReadScope)) {\n      return;\n    }\n  }\n\n  // Custom\n  else if (apiToken.type === constants.API_TOKEN_TYPE.CUSTOM) {\n    if (!ability) {\n      throw new ForbiddenError();\n    }\n\n    const scopes = castArray(config.scope);\n\n    const isAllowed = scopes.every((scope) => ability.can(scope));\n\n    if (isAllowed) {\n      return;\n    }\n  }\n\n  throw new ForbiddenError();\n};\n\nexport const name = 'api-token';\n\nexport default {\n  name: 'api-token',\n  authenticate,\n  verify,\n};\n","import { Strapi } from '@strapi/types';\nimport registerAdminPanelRoute from './routes/serve-admin-panel';\nimport adminAuthStrategy from './strategies/admin';\nimport apiTokenAuthStrategy from './strategies/api-token';\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const passportMiddleware = strapi.admin?.services.passport.init();\n\n  strapi.server.api('admin').use(passportMiddleware);\n  strapi.container.get('auth').register('admin', adminAuthStrategy);\n  strapi.container.get('auth').register('content-api', apiTokenAuthStrategy);\n\n  if (strapi.config.serveAdminPanel) {\n    registerAdminPanelRoute({ strapi });\n  }\n};\n","/**\n * Migrate the audit logs table name for users coming from v4.6.0\n */\nasync function migrateAuditLogsTable({ oldContentTypes, contentTypes }: any) {\n  // Check if the audit logs table name was changed\n  const oldName = oldContentTypes?.['admin::audit-log']?.collectionName;\n  const newName = contentTypes['admin::audit-log']?.collectionName;\n  const hasRenamedAuditLogsTable = oldName === 'audit_logs' && newName === 'strapi_audit_logs';\n\n  if (!hasRenamedAuditLogsTable) {\n    return;\n  }\n\n  // Check if the previous audit log tables exist\n  const hasAuditLogsTable = await strapi.db.getSchemaConnection().hasTable('audit_logs');\n  const hasLinkTable = await strapi.db.getSchemaConnection().hasTable('audit_logs_user_links');\n\n  if (!hasAuditLogsTable || !hasLinkTable) {\n    return;\n  }\n\n  // Check if the existing tables match the expected schema\n  const auditLogsColumnInfo = await strapi.db.connection('audit_logs').columnInfo();\n  const linkColumnInfo = await strapi.db.connection('audit_logs_user_links').columnInfo();\n\n  if (\n    !auditLogsColumnInfo.action ||\n    !auditLogsColumnInfo.date ||\n    !auditLogsColumnInfo.payload ||\n    !linkColumnInfo.audit_log_id ||\n    !linkColumnInfo.user_id\n  ) {\n    return;\n  }\n\n  // Do the actual migrations\n  await strapi.db.getSchemaConnection().renameTable('audit_logs', 'strapi_audit_logs');\n  await strapi.db\n    .getSchemaConnection()\n    .renameTable('audit_logs_user_links', 'strapi_audit_logs_user_links');\n}\n\nexport default migrateAuditLogsTable;\n","// TODO concatenate admin + content type singular name\nexport const WORKFLOW_MODEL_UID = 'admin::workflow';\nexport const STAGE_MODEL_UID = 'admin::workflow-stage';\nexport const STAGE_TRANSITION_UID = 'admin::review-workflows.stage.transition';\nexport const STAGE_DEFAULT_COLOR = '#4945FF';\nexport const ENTITY_STAGE_ATTRIBUTE = 'strapi_stage';\nexport const ENTITY_ASSIGNEE_ATTRIBUTE = 'strapi_assignee';\nexport const MAX_WORKFLOWS = 200;\nexport const MAX_STAGES_PER_WORKFLOW = 200;\nexport const ERRORS = {\n  WORKFLOW_WITHOUT_STAGES: 'A workflow must have at least one stage.',\n  WORKFLOWS_LIMIT:\n    'You’ve reached the limit of workflows in your plan. Delete a workflow or contact Sales to enable more workflows.',\n  STAGES_LIMIT:\n    'You’ve reached the limit of stages for this workflow in your plan. Try deleting some stages or contact Sales to enable more stages.',\n  DUPLICATED_STAGE_NAME: 'Stage names must be unique.',\n};\nexport const WORKFLOW_POPULATE = {\n  stages: {\n    populate: {\n      permissions: {\n        fields: ['action', 'actionParameters'],\n        populate: {\n          role: { fields: ['id', 'name'] },\n        },\n      },\n    },\n  },\n};\n","import { STAGE_DEFAULT_COLOR } from '../constants/workflows';\n\nasync function migrateReviewWorkflowStagesColor({ oldContentTypes, contentTypes }: any) {\n  // Look for CT's color attribute\n  const hadColor = !!oldContentTypes?.['admin::workflow-stage']?.attributes?.color;\n  const hasColor = !!contentTypes?.['admin::workflow-stage']?.attributes?.color;\n\n  // Add the default stage color if color attribute was added\n  if (!hadColor && hasColor) {\n    await strapi.query('admin::workflow-stage').updateMany({\n      data: {\n        color: STAGE_DEFAULT_COLOR,\n      },\n    });\n  }\n}\n\nexport default migrateReviewWorkflowStagesColor;\n","import { Strapi } from '@strapi/types';\n\nexport const getService = (\n  name: string,\n  { strapi }: { strapi: Strapi } = { strapi: global.strapi }\n) => {\n  return strapi.service(`admin::${name}`);\n};\n\nexport default {\n  getService,\n};\n","import { STAGE_TRANSITION_UID, STAGE_MODEL_UID } from '../constants/workflows';\nimport { getService } from '../utils';\n\nasync function migrateReviewWorkflowStagesRoles({ oldContentTypes, contentTypes }: any) {\n  const stageUID = 'admin::workflow-stage';\n  const hadRolePermissions = !!oldContentTypes?.[stageUID]?.attributes?.permissions;\n  const hasRolePermissions = !!contentTypes?.[stageUID]?.attributes?.permissions;\n\n  // If the stage content type did not have permissions in the previous version\n  // then we set the permissions of every stage to be every current role in the app.\n  // This ensures consistent behaviour when upgrading to a strapi version with review workflows RBAC.\n  if (!hadRolePermissions && hasRolePermissions) {\n    const roleUID = 'admin::role';\n    strapi.log.info(\n      `Migrating all existing review workflow stages to have RBAC permissions for all ${roleUID}.`\n    );\n\n    const stagePermissionsService = getService('stage-permissions');\n\n    const stages = await strapi.query(stageUID).findMany();\n    const roles = await strapi.query(roleUID).findMany();\n\n    // Collect the permissions to add and group them by stage id.\n    const groupedPermissions = {} as any;\n    roles\n      .map((role) => role.id)\n      .forEach((roleId) => {\n        stages\n          .map((stage) => stage.id)\n          .forEach((stageId) => {\n            if (!groupedPermissions[stageId]) {\n              groupedPermissions[stageId] = [];\n            }\n\n            groupedPermissions[stageId].push({\n              roleId,\n              fromStage: stageId,\n              action: STAGE_TRANSITION_UID,\n            });\n          });\n      });\n\n    for (const [stageId, permissions] of Object.entries(groupedPermissions)) {\n      const numericalStageId = Number(stageId);\n\n      if (Number.isNaN(numericalStageId)) {\n        strapi.log.warn(\n          `Unable to apply ${roleUID} migration for ${stageUID} with id ${stageId}. The stage does not have a numerical id.`\n        );\n        continue;\n      }\n\n      // Register the permissions for this stage\n      const stagePermissions = await stagePermissionsService.registerMany(permissions);\n\n      // Update the stage with its new permissions\n      await strapi.entityService.update(STAGE_MODEL_UID, numericalStageId, {\n        data: {\n          permissions: stagePermissions.flat().map((permission: any) => permission.id),\n        },\n      });\n    }\n  }\n}\n\nexport default migrateReviewWorkflowStagesRoles;\n","import { WORKFLOW_MODEL_UID } from '../constants/workflows';\nimport defaultWorkflow from '../constants/default-workflow.json';\n\n/**\n * Multiple workflows introduced the ability to name a workflow.\n * This migration adds the default workflow name if the name attribute was added.\n */\nasync function migrateReviewWorkflowName({ oldContentTypes, contentTypes }: any) {\n  // Look for RW name attribute\n  const hadName = !!oldContentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.name;\n  const hasName = !!contentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.name;\n\n  // Add the default workflow name if name attribute was added\n  if (!hadName && hasName) {\n    await strapi.query(WORKFLOW_MODEL_UID).updateMany({\n      where: {\n        name: { $null: true },\n      },\n      data: {\n        name: defaultWorkflow.name,\n      },\n    });\n  }\n}\n\nexport default migrateReviewWorkflowName;\n","import { get, keys, pickBy, pipe } from 'lodash/fp';\nimport { WORKFLOW_MODEL_UID } from '../constants/workflows';\n\nasync function migrateWorkflowsContentTypes({ oldContentTypes, contentTypes }: any) {\n  // Look for RW contentTypes attribute\n  const hadContentTypes = !!oldContentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.contentTypes;\n  const hasContentTypes = !!contentTypes?.[WORKFLOW_MODEL_UID]?.attributes?.contentTypes;\n\n  if (!hadContentTypes && hasContentTypes) {\n    // Initialize contentTypes with an empty array and assign only to one\n    // workflow the Content Types which were using Review Workflow before.\n    await strapi.query(WORKFLOW_MODEL_UID).updateMany({ data: { contentTypes: [] } });\n\n    // Find Content Types which were using Review Workflow before\n    const contentTypes = pipe([pickBy(get('options.reviewWorkflows')), keys])(oldContentTypes);\n\n    if (contentTypes.length) {\n      // Update only one workflow with the contentTypes\n      // Before this release there was only one workflow, so this operation is safe.\n      await strapi\n        .query(WORKFLOW_MODEL_UID)\n        .update({ where: { id: { $notNull: true } }, data: { contentTypes } });\n    }\n  }\n}\n\nexport default migrateWorkflowsContentTypes;\n","import { LoadedStrapi } from '@strapi/types';\nimport { differenceWith, isEqual } from 'lodash/fp';\n\ninterface PersistedTable {\n  name: string;\n  dependsOn?: Array<{ name: string }>;\n}\n\n/**\n * Transform table name to the object format\n */\nconst transformTableName = (table: string | PersistedTable) => {\n  if (typeof table === 'string') {\n    return { name: table };\n  }\n  return table;\n};\n\n/**\n * Finds all tables in the database matching the regular expression\n * @param {Object} ctx\n * @param {Strapi} ctx.strapi\n * @param {RegExp} regex\n * @returns {Promise<string[]>}\n */\nexport async function findTables({ strapi }: { strapi: LoadedStrapi }, regex: any) {\n  // @ts-expect-error - getTables is not typed into the schema inspector\n  const tables = await strapi.db.dialect.schemaInspector.getTables();\n  return tables.filter((tableName: string) => regex.test(tableName));\n}\n\n/**\n * Add tables name to the reserved tables in core store\n */\nasync function addPersistTables(\n  { strapi }: { strapi: LoadedStrapi },\n  tableNames: Array<string | PersistedTable>\n) {\n  const persistedTables = await getPersistedTables({ strapi });\n  const tables = tableNames.map(transformTableName);\n\n  // Get new tables to be persisted, remove tables if they already were persisted\n  const notPersistedTableNames = differenceWith(isEqual, tables, persistedTables);\n  // Remove tables that are going to be changed\n  const tablesToPersist = differenceWith(\n    (t1: any, t2: any) => t1.name === t2.name,\n    persistedTables,\n    notPersistedTableNames\n  );\n\n  if (!notPersistedTableNames.length) {\n    return;\n  }\n\n  // @ts-expect-error lodash types\n  tablesToPersist.push(...notPersistedTableNames);\n  await strapi.store.set({\n    type: 'core',\n    key: 'persisted_tables',\n    value: tablesToPersist,\n  });\n}\n\n/**\n * Get all reserved table names from the core store\n * @param {Object} ctx\n * @param {Strapi} ctx.strapi\n * @param {RegExp} regex\n * @returns {Promise<string[]>}\n */\n\nasync function getPersistedTables({ strapi }: { strapi: LoadedStrapi }) {\n  const persistedTables: any = await strapi.store.get({\n    type: 'core',\n    key: 'persisted_tables',\n  });\n\n  return (persistedTables || []).map(transformTableName);\n}\n\n/**\n * Set all reserved table names in the core store\n * @param {Object} ctx\n * @param {Strapi} ctx.strapi\n * @param {Array<string|{ table: string; dependsOn?: Array<{ table: string;}> }>} tableNames\n * @returns {Promise<void>}\n */\nasync function setPersistedTables(\n  { strapi }: { strapi: LoadedStrapi },\n  tableNames: Array<string | PersistedTable>\n) {\n  await strapi.store.set({\n    type: 'core',\n    key: 'persisted_tables',\n    value: tableNames,\n  });\n}\n/**\n * Add all table names that start with a prefix to the reserved tables in\n * core store\n * @param {string} tableNamePrefix\n * @return {Promise<void>}\n */\n\nexport const persistTablesWithPrefix = async (tableNamePrefix: string) => {\n  const tableNameRegex = new RegExp(`^${tableNamePrefix}.*`);\n  const tableNames = await findTables({ strapi }, tableNameRegex);\n\n  await addPersistTables({ strapi }, tableNames);\n};\n\n/**\n * Remove all table names that end with a suffix from the reserved tables in core store\n * @param {string} tableNameSuffix\n * @return {Promise<void>}\n */\nexport const removePersistedTablesWithSuffix = async (tableNameSuffix: string) => {\n  const tableNameRegex = new RegExp(`.*${tableNameSuffix}$`);\n  const persistedTables = await getPersistedTables({ strapi });\n\n  const filteredPersistedTables = persistedTables.filter((table: any) => {\n    return !tableNameRegex.test(table.name);\n  });\n\n  if (filteredPersistedTables.length === persistedTables.length) {\n    return;\n  }\n\n  await setPersistedTables({ strapi }, filteredPersistedTables);\n};\n\n/**\n * Add tables to the reserved tables in core store\n */\nexport const persistTables = async (tables: Array<string | PersistedTable>) => {\n  await addPersistTables({ strapi }, tables);\n};\n\nexport default {\n  persistTablesWithPrefix,\n  removePersistedTablesWithSuffix,\n  persistTables,\n  findTables,\n};\n","import semver from 'semver';\nimport { getOr } from 'lodash/fp';\nimport { mapAsync } from '@strapi/utils';\nimport { STAGE_MODEL_UID } from '../constants/workflows';\nimport { findTables } from '../utils/persisted-tables';\n\nfunction checkVersionThreshold(\n  startVersion: string,\n  currentVersion: string,\n  thresholdVersion: string\n) {\n  return semver.gte(currentVersion, thresholdVersion) && semver.lt(startVersion, thresholdVersion);\n}\n\nasync function migrateStageAttribute({ oldContentTypes, contentTypes }: any) {\n  const getRWVersion = getOr('0.0.0', `${STAGE_MODEL_UID}.options.version`);\n  const oldRWVersion = getRWVersion(oldContentTypes);\n  const currentRWVersion = getRWVersion(contentTypes);\n\n  const migrationNeeded = checkVersionThreshold(oldRWVersion, currentRWVersion, '1.1.0');\n\n  if (migrationNeeded) {\n    const oldAttributeTableName = 'strapi_review_workflows_stage';\n    const newAttributeTableName = 'strapi_stage';\n    const tables = await findTables({ strapi }, new RegExp(oldAttributeTableName));\n\n    await mapAsync(tables, async (tableName: string) => {\n      const newTableName = tableName.replace(oldAttributeTableName, newAttributeTableName);\n      const alreadyHasNextTable = await strapi.db.connection.schema.hasTable(newTableName);\n\n      // The table can be already created but empty. In order to rename the old one, we need to drop the previously created empty one.\n      if (alreadyHasNextTable) {\n        const dataInTable = await strapi.db.connection(newTableName).select().limit(1);\n        if (!dataInTable.length) {\n          await strapi.db.connection.schema.dropTable(newTableName);\n        }\n      }\n\n      try {\n        await strapi.db.connection.schema.renameTable(tableName, newTableName);\n      } catch (e: any) {\n        strapi.log.warn(\n          `An error occurred during the migration of ${tableName} table to ${newTableName}.\\nIf ${newTableName} already exists, migration can't be done automatically.`\n        );\n        strapi.log.warn(e.message);\n      }\n    });\n  }\n}\n\nexport default migrateStageAttribute;\n","import { LoadedStrapi } from '@strapi/types';\nimport { getOr, keys, pickBy, pipe, has, clamp } from 'lodash/fp';\nimport {\n  ENTITY_STAGE_ATTRIBUTE,\n  MAX_WORKFLOWS,\n  MAX_STAGES_PER_WORKFLOW,\n} from '../constants/workflows';\n\nexport const getVisibleContentTypesUID = pipe([\n  // Pick only content-types visible in the content-manager and option is not false\n  pickBy(\n    (value) =>\n      getOr(true, 'pluginOptions.content-manager.visible', value) &&\n      !getOr(false, 'options.noStageAttribute', value)\n  ),\n  // Get UIDs\n  keys,\n]);\n\nexport const hasStageAttribute = has(['attributes', ENTITY_STAGE_ATTRIBUTE]);\n\nexport const getWorkflowContentTypeFilter = (\n  { strapi }: { strapi: LoadedStrapi },\n  contentType: any\n) => {\n  if (strapi.db.dialect.supportsOperator('$jsonSupersetOf')) {\n    return { $jsonSupersetOf: JSON.stringify([contentType]) };\n  }\n  return { $contains: `\"${contentType}\"` };\n};\n\nexport const clampMaxWorkflows = clamp(1, MAX_WORKFLOWS);\nexport const clampMaxStagesPerWorkflow = clamp(1, MAX_STAGES_PER_WORKFLOW);\n\nexport default {\n  clampMaxWorkflows,\n  clampMaxStagesPerWorkflow,\n  getVisibleContentTypesUID,\n  hasStageAttribute,\n  getWorkflowContentTypeFilter,\n};\n","import { difference, keys } from 'lodash/fp';\nimport { mapAsync } from '@strapi/utils';\nimport { WORKFLOW_MODEL_UID } from '../constants/workflows';\nimport { getWorkflowContentTypeFilter } from '../utils/review-workflows';\n\n/**\n * @param {Object} oldContentTypes\n * @param {Object} contentTypes\n * @return {Promise<void>}\n */\nasync function migrateDeletedCTInWorkflows({ oldContentTypes, contentTypes }: any) {\n  const deletedContentTypes = difference(keys(oldContentTypes), keys(contentTypes)) ?? [];\n\n  if (deletedContentTypes.length) {\n    await mapAsync(deletedContentTypes, async (deletedContentTypeUID: unknown) => {\n      const workflow = await strapi.query(WORKFLOW_MODEL_UID).findOne({\n        select: ['id', 'contentTypes'],\n        where: {\n          contentTypes: getWorkflowContentTypeFilter({ strapi }, deletedContentTypeUID),\n        },\n      });\n\n      if (workflow) {\n        await strapi.query(WORKFLOW_MODEL_UID).update({\n          where: { id: workflow.id },\n          data: {\n            contentTypes: workflow.contentTypes.filter(\n              (contentTypeUID: unknown) => contentTypeUID !== deletedContentTypeUID\n            ),\n          },\n        });\n      }\n    });\n  }\n}\n\nexport default migrateDeletedCTInWorkflows;\n","import { LoadedStrapi } from '@strapi/types';\nimport localProvider from '@strapi/provider-audit-logs-local';\nimport { scheduleJob } from 'node-schedule';\nimport EE from '@strapi/strapi/dist/utils/ee';\n\nconst DEFAULT_RETENTION_DAYS = 90;\n\nconst defaultEvents = [\n  'entry.create',\n  'entry.update',\n  'entry.delete',\n  'entry.publish',\n  'entry.unpublish',\n  'media.create',\n  'media.update',\n  'media.delete',\n  'media-folder.create',\n  'media-folder.update',\n  'media-folder.delete',\n  'user.create',\n  'user.update',\n  'user.delete',\n  'admin.auth.success',\n  'admin.logout',\n  'content-type.create',\n  'content-type.update',\n  'content-type.delete',\n  'component.create',\n  'component.update',\n  'component.delete',\n  'role.create',\n  'role.update',\n  'role.delete',\n  'permission.create',\n  'permission.update',\n  'permission.delete',\n];\n\nconst getSanitizedUser = (user: any) => {\n  let displayName = user.email;\n\n  if (user.username) {\n    displayName = user.username;\n  } else if (user.firstname && user.lastname) {\n    displayName = `${user.firstname} ${user.lastname}`;\n  }\n\n  return {\n    id: user.id,\n    email: user.email,\n    displayName,\n  };\n};\n\nconst getEventMap = (defaultEvents: any) => {\n  const getDefaultPayload = (...args: any) => args[0];\n\n  // Use the default payload for all default events\n  return defaultEvents.reduce((acc: any, event: any) => {\n    acc[event] = getDefaultPayload;\n    return acc;\n  }, {} as any);\n};\n\nconst getRetentionDays = (strapi: LoadedStrapi) => {\n  // @ts-expect-error - options is not typed into features\n  const licenseRetentionDays = EE.features.get('audit-logs')?.options.retentionDays;\n  const userRetentionDays = strapi.config.get('admin.auditLogs.retentionDays');\n\n  // For enterprise plans, use 90 days by default, but allow users to override it\n  if (licenseRetentionDays == null) {\n    return userRetentionDays ?? DEFAULT_RETENTION_DAYS;\n  }\n\n  // Allow users to override the license retention days, but not to increase it\n  if (userRetentionDays && userRetentionDays < licenseRetentionDays) {\n    return userRetentionDays;\n  }\n\n  // User didn't provide a retention days value, use the license one\n  return licenseRetentionDays;\n};\n\nconst createAuditLogsService = (strapi: LoadedStrapi) => {\n  // Manage internal service state privately\n  const state = {} as any;\n\n  // NOTE: providers should be able to replace getEventMap to add or remove events\n  const eventMap = getEventMap(defaultEvents);\n\n  const processEvent = (name: string, ...args: any) => {\n    const requestState = strapi.requestContext.get()?.state;\n\n    // Ignore events with auth strategies different from admin\n    const isUsingAdminAuth = requestState?.auth?.strategy.name === 'admin';\n    const user = requestState?.user;\n\n    if (!isUsingAdminAuth || !user) {\n      return null;\n    }\n\n    const getPayload = eventMap[name];\n\n    // Ignore the event if it's not in the map\n    if (!getPayload) {\n      return null;\n    }\n\n    // Ignore some events based on payload\n    const ignoredUids = ['plugin::upload.file', 'plugin::upload.folder'];\n    if (ignoredUids.includes(args[0]?.uid)) {\n      return null;\n    }\n\n    return {\n      action: name,\n      date: new Date().toISOString(),\n      payload: getPayload(...args) || {},\n      userId: user.id,\n    };\n  };\n\n  async function handleEvent(name: string, ...args: any) {\n    const processedEvent = processEvent(name, ...args);\n\n    if (processedEvent) {\n      // This stores the event when after the transaction is committed,\n      // so it's not stored if the transaction is rolled back\n      await strapi.db.transaction(({ onCommit }) => {\n        onCommit(() => state.provider.saveEvent(processedEvent));\n      });\n    }\n  }\n\n  return {\n    async register() {\n      // Handle license being enabled\n      if (!state.eeEnableUnsubscribe) {\n        // @ts-expect-error- update event hub to receive callback argument\n        state.eeEnableUnsubscribe = strapi.eventHub.on('ee.enable', () => {\n          // Recreate the service to use the new license info\n          this.destroy();\n          this.register();\n        });\n      }\n\n      // Handle license being updated\n      if (!state.eeUpdateUnsubscribe) {\n        // @ts-expect-error- update event hub to receive callback argument\n        state.eeUpdateUnsubscribe = strapi.eventHub.on('ee.update', () => {\n          // Recreate the service to use the new license info\n          this.destroy();\n          this.register();\n        });\n      }\n\n      // Handle license being disabled\n      // @ts-expect-error- update event hub to receive callback argument\n      state.eeDisableUnsubscribe = strapi.eventHub.on('ee.disable', () => {\n        // Turn off service when the license gets disabled\n        // Only ee.enable and ee.update listeners remain active to recreate the service\n        this.destroy();\n      });\n\n      // Register the provider now because collections can't be added later at runtime\n      state.provider = await localProvider.register({ strapi });\n\n      // Check current state of license\n      if (!EE.features.isEnabled('audit-logs')) {\n        return this;\n      }\n\n      // Start saving events\n      state.eventHubUnsubscribe = strapi.eventHub.subscribe(handleEvent.bind(this));\n\n      // Manage audit logs auto deletion\n      const retentionDays = getRetentionDays(strapi);\n      state.deleteExpiredJob = scheduleJob('0 0 * * *', () => {\n        const expirationDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);\n        state.provider.deleteExpiredEvents(expirationDate);\n      });\n\n      return this;\n    },\n\n    async findMany(query: unknown) {\n      const { results, pagination } = await state.provider.findMany(query);\n\n      const sanitizedResults = results.map((result: any) => {\n        const { user, ...rest } = result;\n        return {\n          ...rest,\n          user: user ? getSanitizedUser(user) : null,\n        };\n      });\n\n      return {\n        results: sanitizedResults,\n        pagination,\n      };\n    },\n\n    async findOne(id: unknown) {\n      const result = await state.provider.findOne(id);\n\n      if (!result) {\n        return null;\n      }\n\n      const { user, ...rest } = result;\n      return {\n        ...rest,\n        user: user ? getSanitizedUser(user) : null,\n      };\n    },\n\n    unsubscribe() {\n      if (state.eeDisableUnsubscribe) {\n        state.eeDisableUnsubscribe();\n      }\n\n      if (state.eventHubUnsubscribe) {\n        state.eventHubUnsubscribe();\n      }\n\n      if (state.deleteExpiredJob) {\n        state.deleteExpiredJob.cancel();\n      }\n\n      return this;\n    },\n\n    destroy() {\n      return this.unsubscribe();\n    },\n  };\n};\n\nexport default createAuditLogsService;\n","import type { Context } from 'koa';\nimport { Strapi } from '@strapi/types';\nimport { set } from 'lodash/fp';\n\n/**\n * A Strapi middleware function that adds support for review workflows.\n *\n * Why is it needed ?\n * For now, the admin panel cannot have anything but top-level attributes in the content-type for options.\n * But we need the CE part to be agnostics from Review Workflow (which is an EE feature).\n * CE handle the `options` object, that's why we move the reviewWorkflows boolean to the options object.\n *\n * @param {object} strapi - The Strapi instance.\n */\nexport function contentTypeMiddleware(strapi: Strapi) {\n  /**\n   * A middleware function that moves the `reviewWorkflows` attribute from the top level of\n   * the request body to the `options` object within the request body.\n   *\n   * @param {object} ctx - The Koa context object.\n   */\n  const moveReviewWorkflowOption = (ctx: Context) => {\n    // Move reviewWorkflows to options.reviewWorkflows\n    const { reviewWorkflows, ...contentType } = ctx.request.body.contentType;\n\n    if (typeof reviewWorkflows === 'boolean') {\n      ctx.request.body.contentType = set('options.reviewWorkflows', reviewWorkflows, contentType);\n    }\n  };\n  strapi.server.router.use('/content-type-builder/content-types/:uid?', (ctx, next) => {\n    if (ctx.method === 'PUT' || ctx.method === 'POST') {\n      moveReviewWorkflowOption(ctx);\n    }\n    return next();\n  });\n}\n\nexport default {\n  contentTypeMiddleware,\n};\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport EE from '@strapi/strapi/dist/utils/ee';\nimport executeCERegister from '../../../server/src/register';\nimport migrateAuditLogsTable from './migrations/audit-logs-table';\nimport migrateReviewWorkflowStagesColor from './migrations/review-workflows-stages-color';\nimport migrateReviewWorkflowStagesRoles from './migrations/review-workflows-stages-roles';\nimport migrateReviewWorkflowName from './migrations/review-workflows-workflow-name';\nimport migrateWorkflowsContentTypes from './migrations/review-workflows-content-types';\nimport migrateStageAttribute from './migrations/review-workflows-stage-attribute';\nimport migrateDeletedCTInWorkflows from './migrations/review-workflows-deleted-ct-in-workflows';\nimport createAuditLogsService from './services/audit-logs';\nimport reviewWorkflowsMiddlewares from './middlewares/review-workflows';\nimport { getService } from './utils';\n\nexport default async ({ strapi }: { strapi: Strapi }) => {\n  const auditLogsIsEnabled = strapi.config.get('admin.auditLogs.enabled', true);\n\n  if (auditLogsIsEnabled) {\n    strapi.hook('strapi::content-types.beforeSync').register(migrateAuditLogsTable);\n    const auditLogsService = createAuditLogsService(strapi);\n    strapi.container.register('audit-logs', auditLogsService);\n    await auditLogsService.register();\n  }\n  if (EE.features.isEnabled('review-workflows')) {\n    strapi.hook('strapi::content-types.beforeSync').register(migrateStageAttribute);\n    strapi\n      .hook('strapi::content-types.afterSync')\n      .register(migrateReviewWorkflowStagesColor)\n      .register(migrateReviewWorkflowStagesRoles)\n      .register(migrateReviewWorkflowName)\n      .register(migrateWorkflowsContentTypes)\n      .register(migrateDeletedCTInWorkflows);\n    const reviewWorkflowService = getService('review-workflows');\n\n    reviewWorkflowsMiddlewares.contentTypeMiddleware(strapi);\n    await reviewWorkflowService.register(EE.features.get('review-workflows'));\n  }\n  await executeCERegister({ strapi });\n};\n","export default {\n  schema: {\n    collectionName: 'strapi_workflows',\n    info: {\n      name: 'Workflow',\n      description: '',\n      singularName: 'workflow',\n      pluralName: 'workflows',\n      displayName: 'Workflow',\n    },\n    options: {},\n    pluginOptions: {\n      'content-manager': {\n        visible: false,\n      },\n      'content-type-builder': {\n        visible: false,\n      },\n    },\n    attributes: {\n      name: {\n        type: 'string',\n        required: true,\n        unique: true,\n      },\n      stages: {\n        type: 'relation',\n        target: 'admin::workflow-stage',\n        relation: 'oneToMany',\n        mappedBy: 'workflow',\n      },\n      contentTypes: {\n        type: 'json',\n        required: true,\n        default: [],\n      },\n    },\n  },\n};\n","import { STAGE_DEFAULT_COLOR } from '../../constants/workflows';\n\nexport default {\n  schema: {\n    collectionName: 'strapi_workflows_stages',\n    info: {\n      name: 'Workflow Stage',\n      description: '',\n      singularName: 'workflow-stage',\n      pluralName: 'workflow-stages',\n      displayName: 'Stages',\n    },\n    options: {\n      version: '1.1.0',\n    },\n    pluginOptions: {\n      'content-manager': {\n        visible: false,\n      },\n      'content-type-builder': {\n        visible: false,\n      },\n    },\n    attributes: {\n      name: {\n        type: 'string',\n        configurable: false,\n      },\n      color: {\n        type: 'string',\n        configurable: false,\n        default: STAGE_DEFAULT_COLOR,\n      },\n      workflow: {\n        type: 'relation',\n        target: 'admin::workflow',\n        relation: 'manyToOne',\n        inversedBy: 'stages',\n        configurable: false,\n      },\n      permissions: {\n        type: 'relation',\n        target: 'admin::permission',\n        relation: 'manyToMany',\n        configurable: false,\n      },\n    },\n  },\n};\n","import workflow from './workflow';\nimport workflowStage from './workflow-stage';\n\nexport default {\n  workflow,\n  'workflow-stage': workflowStage,\n};\n","export const actions = [\n  {\n    uid: 'marketplace.read',\n    displayName: 'Access the marketplace',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'plugins and marketplace',\n    subCategory: 'marketplace',\n  },\n  {\n    uid: 'webhooks.create',\n    displayName: 'Create',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'webhooks',\n  },\n  {\n    uid: 'webhooks.read',\n    displayName: 'Read',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'webhooks',\n  },\n  {\n    uid: 'webhooks.update',\n    displayName: 'Update',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'webhooks',\n  },\n  {\n    uid: 'webhooks.delete',\n    displayName: 'Delete',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'webhooks',\n  },\n  {\n    uid: 'users.create',\n    displayName: 'Create (invite)',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'users',\n  },\n  {\n    uid: 'users.read',\n    displayName: 'Read',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'users',\n  },\n  {\n    uid: 'users.update',\n    displayName: 'Update',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'users',\n  },\n  {\n    uid: 'users.delete',\n    displayName: 'Delete',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'users',\n  },\n  {\n    uid: 'roles.create',\n    displayName: 'Create',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'roles',\n  },\n  {\n    uid: 'roles.read',\n    displayName: 'Read',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'roles',\n  },\n  {\n    uid: 'roles.update',\n    displayName: 'Update',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'roles',\n  },\n  {\n    uid: 'roles.delete',\n    displayName: 'Delete',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'users and roles',\n    subCategory: 'roles',\n  },\n  {\n    uid: 'api-tokens.access',\n    displayName: 'Access the API tokens settings page',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'api tokens',\n    subCategory: 'api Tokens',\n  },\n  {\n    uid: 'api-tokens.create',\n    displayName: 'Create (generate)',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'api tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'api-tokens.read',\n    displayName: 'Read',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'api tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'api-tokens.update',\n    displayName: 'Update',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'api tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'api-tokens.regenerate',\n    displayName: 'Regenerate',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'api tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'api-tokens.delete',\n    displayName: 'Delete (revoke)',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'api tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'project-settings.update',\n    displayName: 'Update the project level settings',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'project',\n  },\n  {\n    uid: 'project-settings.read',\n    displayName: 'Read the project level settings',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'project',\n  },\n  {\n    uid: 'transfer.tokens.access',\n    displayName: 'Access the transfer tokens settings page',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'transfer tokens',\n    subCategory: 'transfer tokens',\n  },\n  {\n    uid: 'transfer.tokens.create',\n    displayName: 'Create (generate)',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'transfer tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'transfer.tokens.read',\n    displayName: 'Read',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'transfer tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'transfer.tokens.update',\n    displayName: 'Update',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'transfer tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'transfer.tokens.regenerate',\n    displayName: 'Regenerate',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'transfer tokens',\n    subCategory: 'general',\n  },\n  {\n    uid: 'transfer.tokens.delete',\n    displayName: 'Delete (revoke)',\n    pluginName: 'admin',\n    section: 'settings',\n    category: 'transfer tokens',\n    subCategory: 'general',\n  },\n];\n\nexport default {\n  actions,\n};\n","// TODO: TS User and role type\ntype User = any;\ntype Role = any;\n\nexport const conditions = [\n  {\n    displayName: 'Is creator',\n    name: 'is-creator',\n    plugin: 'admin',\n    handler: (user: User) => ({ 'createdBy.id': user.id }),\n  },\n  {\n    displayName: 'Has same role as creator',\n    name: 'has-same-role-as-creator',\n    plugin: 'admin',\n    handler: (user: User) => ({\n      'createdBy.roles': {\n        $elemMatch: {\n          id: {\n            $in: user.roles.map((r: Role) => r.id),\n          },\n        },\n      },\n    }),\n  },\n];\n\nexport default {\n  conditions,\n};\n","import { merge, map, difference, uniq } from 'lodash/fp';\nimport { Strapi } from '@strapi/types';\nimport { pipeAsync } from '@strapi/utils';\nimport { getService } from './utils';\nimport adminActions from './config/admin-actions';\nimport adminConditions from './config/admin-conditions';\n\nconst defaultAdminAuthSettings = {\n  providers: {\n    autoRegister: false,\n    defaultRole: null,\n    ssoLockedRoles: null,\n  },\n};\n\nconst registerPermissionActions = async () => {\n  await getService('permission').actionProvider.registerMany(adminActions.actions);\n};\n\nconst registerAdminConditions = async () => {\n  await getService('permission').conditionProvider.registerMany(adminConditions.conditions);\n};\n\nconst registerModelHooks = () => {\n  const { sendDidChangeInterfaceLanguage } = getService('metrics');\n\n  strapi.db.lifecycles.subscribe({\n    models: ['admin::user'],\n    afterCreate: sendDidChangeInterfaceLanguage,\n    afterDelete: sendDidChangeInterfaceLanguage,\n    afterUpdate({ params }) {\n      if (params.data.preferedLanguage) {\n        sendDidChangeInterfaceLanguage();\n      }\n    },\n  });\n};\n\nconst syncAuthSettings = async () => {\n  const adminStore = await strapi.store({ type: 'core', name: 'admin' });\n  const adminAuthSettings = await adminStore.get({ key: 'auth' });\n  const newAuthSettings = merge(defaultAdminAuthSettings, adminAuthSettings);\n\n  const roleExists = await getService('role').exists({\n    id: newAuthSettings.providers.defaultRole,\n  });\n\n  // Reset the default SSO role if it has been deleted manually\n  if (!roleExists) {\n    newAuthSettings.providers.defaultRole = null;\n  }\n\n  await adminStore.set({ key: 'auth', value: newAuthSettings });\n};\n\nconst syncAPITokensPermissions = async () => {\n  const validPermissions = strapi.contentAPI.permissions.providers.action.keys();\n  const permissionsInDB = await pipeAsync(\n    strapi.query('admin::api-token-permission').findMany,\n    // @ts-expect-error lodash types\n    map('action')\n  )();\n\n  const unknownPermissions = uniq(difference(permissionsInDB, validPermissions));\n\n  if (unknownPermissions.length > 0) {\n    await strapi\n      .query('admin::api-token-permission')\n      .deleteMany({ where: { action: { $in: unknownPermissions } } });\n  }\n};\n\nexport default async ({ strapi }: { strapi: Strapi }) => {\n  await registerAdminConditions();\n  await registerPermissionActions();\n  registerModelHooks();\n\n  const permissionService = getService('permission');\n  const userService = getService('user');\n  const roleService = getService('role');\n  const apiTokenService = getService('api-token');\n  const transferService = getService('transfer');\n  const tokenService = getService('token');\n\n  await roleService.createRolesIfNoneExist();\n  await roleService.resetSuperAdminPermissions();\n  await roleService.displayWarningIfNoSuperAdmin();\n\n  await permissionService.cleanPermissionsInDatabase();\n\n  await userService.displayWarningIfUsersDontHaveRole();\n\n  await syncAuthSettings();\n  await syncAPITokensPermissions();\n\n  getService('metrics').sendUpdateProjectInformation();\n  getService('metrics').startCron(strapi);\n\n  apiTokenService.checkSaltIsDefined();\n  transferService.token.checkSaltIsDefined();\n  tokenService.checkSecretIsDefined();\n};\n","export default {\n  sso: [\n    {\n      uid: 'provider-login.read',\n      displayName: 'Read',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'single sign on',\n      subCategory: 'options',\n    },\n    {\n      uid: 'provider-login.update',\n      displayName: 'Update',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'single sign on',\n      subCategory: 'options',\n    },\n  ],\n  auditLogs: [\n    {\n      uid: 'audit-logs.read',\n      displayName: 'Read',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'audit logs',\n      subCategory: 'options',\n    },\n  ],\n  reviewWorkflows: [\n    {\n      uid: 'review-workflows.create',\n      displayName: 'Create',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'review workflows',\n      subCategory: 'options',\n    },\n    {\n      uid: 'review-workflows.read',\n      displayName: 'Read',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'review workflows',\n      subCategory: 'options',\n    },\n    {\n      uid: 'review-workflows.update',\n      displayName: 'Update',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'review workflows',\n      subCategory: 'options',\n    },\n    {\n      uid: 'review-workflows.delete',\n      displayName: 'Delete',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'review workflows',\n      subCategory: 'options',\n    },\n    {\n      uid: 'review-workflows.stage.transition',\n      displayName: 'Change stage',\n      pluginName: 'admin',\n      section: 'internal',\n    },\n  ],\n};\n","import EE from '@strapi/strapi/dist/utils/ee';\nimport executeCEBootstrap from '../../../server/src/bootstrap';\nimport { getService } from '../../server/src/utils';\nimport actions from './config/admin-actions';\nimport { persistTablesWithPrefix } from './utils/persisted-tables';\n\nexport default async (args: any) => {\n  const { actionProvider } = getService('permission');\n  if (EE.features.isEnabled('sso')) {\n    await actionProvider.registerMany(actions.sso);\n  }\n  if (EE.features.isEnabled('audit-logs')) {\n    await persistTablesWithPrefix('strapi_audit_logs');\n    await actionProvider.registerMany(actions.auditLogs);\n  }\n  if (EE.features.isEnabled('review-workflows')) {\n    await persistTablesWithPrefix('strapi_workflows');\n    const { bootstrap: rwBootstrap } = getService('review-workflows');\n    await rwBootstrap();\n    await actionProvider.registerMany(actions.reviewWorkflows);\n    // Decorate the entity service with review workflow logic\n    const { decorator } = getService('review-workflows-decorator');\n    // @ts-expect-error - add decorator to entity service\n    strapi.entityService.decorate(decorator);\n    await getService('review-workflows-weekly-metrics').registerCron();\n  }\n  await getService('seat-enforcement').seatEnforcementWorkflow();\n  await executeCEBootstrap(args);\n};\n","import { getService } from './utils';\n\nexport default async () => {\n  const { conditionProvider, actionProvider } = getService('permission');\n\n  await conditionProvider.clear();\n  await actionProvider.clear();\n};\n","import { Strapi } from '@strapi/types';\nimport EE from '@strapi/strapi/dist/utils/ee';\nimport executeCEDestroy from '../../../server/src/destroy';\n\nexport default async ({ strapi }: { strapi: Strapi }) => {\n  if (EE.features.isEnabled('audit-logs')) {\n    strapi.container.get('audit-logs').destroy();\n  }\n\n  await executeCEDestroy();\n};\n","import EE from '@strapi/strapi/dist/utils/ee';\nimport { Common } from '@strapi/types';\n\nexport const enableFeatureMiddleware: Common.MiddlewareFactory =\n  (featureName: string) => (ctx, next) => {\n    if (EE.features.isEnabled(featureName)) {\n      return next();\n    }\n\n    ctx.status = 404;\n  };\n\nexport default {\n  enableFeatureMiddleware,\n};\n","import { enableFeatureMiddleware } from './utils';\n\nexport default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      path: '/providers',\n      handler: 'authentication.getProviders',\n      config: {\n        middlewares: [enableFeatureMiddleware('sso')],\n        auth: false,\n      },\n    },\n    {\n      method: 'GET',\n      path: '/connect/:provider',\n      handler: 'authentication.providerLogin',\n      config: {\n        middlewares: [enableFeatureMiddleware('sso')],\n        auth: false,\n      },\n    },\n    {\n      method: 'POST',\n      path: '/connect/:provider',\n      handler: 'authentication.providerLogin',\n      config: {\n        middlewares: [enableFeatureMiddleware('sso')],\n        auth: false,\n      },\n    },\n    {\n      method: 'GET',\n      path: '/providers/options',\n      handler: 'authentication.getProviderLoginOptions',\n      config: {\n        middlewares: [enableFeatureMiddleware('sso')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          { name: 'admin::hasPermissions', config: { actions: ['admin::provider-login.read'] } },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/providers/options',\n      handler: 'authentication.updateProviderLoginOptions',\n      config: {\n        middlewares: [enableFeatureMiddleware('sso')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          { name: 'admin::hasPermissions', config: { actions: ['admin::provider-login.update'] } },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/providers/isSSOLocked',\n      handler: 'user.isSSOLocked',\n      config: {\n        middlewares: [enableFeatureMiddleware('sso')],\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n  ],\n};\n","export default {\n  type: 'admin',\n  routes: [\n    // License limit infos\n    {\n      method: 'GET',\n      path: '/license-limit-information',\n      handler: 'admin.licenseLimitInformation',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: [\n                'admin::users.create',\n                'admin::users.read',\n                'admin::users.update',\n                'admin::users.delete',\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { enableFeatureMiddleware } from './utils';\n\nexport default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'GET',\n      path: '/audit-logs',\n      handler: 'auditLogs.findMany',\n      config: {\n        middlewares: [enableFeatureMiddleware('audit-logs')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::audit-logs.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/audit-logs/:id',\n      handler: 'auditLogs.findOne',\n      config: {\n        middlewares: [enableFeatureMiddleware('audit-logs')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::audit-logs.read'],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { enableFeatureMiddleware } from './utils';\n\nexport default {\n  type: 'admin',\n  routes: [\n    // Review workflow\n    {\n      method: 'POST',\n      path: '/review-workflows/workflows',\n      handler: 'workflows.create',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.create'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/review-workflows/workflows/:id',\n      handler: 'workflows.update',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.update'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/review-workflows/workflows/:id',\n      handler: 'workflows.delete',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.delete'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/review-workflows/workflows',\n      handler: 'workflows.find',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/review-workflows/workflows/:id',\n      handler: 'workflows.findById',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/review-workflows/workflows/:workflow_id/stages',\n      handler: 'stages.find',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/review-workflows/workflows/:workflow_id/stages/:id',\n      handler: 'stages.findById',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::review-workflows.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/content-manager/(collection|single)-types/:model_uid/:id/stage',\n      handler: 'stages.updateEntity',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/content-manager/(collection|single)-types/:model_uid/:id/stages',\n      handler: 'stages.listAvailableStages',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: ['admin::isAuthenticatedAdmin'],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/content-manager/(collection|single)-types/:model_uid/:id/assignee',\n      handler: 'assignees.updateEntity',\n      config: {\n        middlewares: [enableFeatureMiddleware('review-workflows')],\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['admin::users.read', 'admin::review-workflows.read'],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n","import sso from './sso';\nimport licenseLimit from './license-limit';\nimport auditLogs from './audit-logs';\nimport reviewWorkflows from './review-workflows';\n\nexport default {\n  sso,\n  'license-limit': licenseLimit,\n  'audit-logs': auditLogs,\n  'review-workflows': reviewWorkflows,\n};\n","import EE from '@strapi/strapi/dist/utils/ee';\nimport { isEmpty } from 'lodash/fp';\n\nexport const isSsoLocked = async (user: any) => {\n  if (!EE.features.isEnabled('sso')) {\n    return false;\n  }\n\n  if (!user) {\n    throw new Error('Missing user object');\n  }\n\n  // check if any roles are locked\n  const adminStore = await strapi.store({ type: 'core', name: 'admin' });\n  const { providers } = (await adminStore.get({ key: 'auth' })) as any;\n  const lockedRoles = providers.ssoLockedRoles ?? [];\n  if (isEmpty(lockedRoles)) {\n    return false;\n  }\n\n  const roles =\n    // If the roles are pre-loaded for the given user, then use them\n    user.roles ??\n    // Otherwise, try to load the role based on the given user ID\n    (await strapi.query('admin::user').load(user, 'roles', { roles: { fields: ['id'] } })) ??\n    // If the query fails somehow, default to an empty array\n    [];\n\n  // Check if any of the user's roles are in lockedRoles\n  const isLocked = lockedRoles.some((lockedId: string) =>\n    // lockedRoles will be a string to avoid issues with frontend and bigints\n    roles.some((role: any) => lockedId === role.id.toString())\n  );\n\n  return isLocked;\n};\n\nexport default {\n  isSsoLocked,\n};\n","import _ from 'lodash';\nimport { getAbsoluteAdminUrl } from '@strapi/utils';\nimport { errors } from '@strapi/utils';\nimport { getService } from '../utils';\nimport { isSsoLocked } from '../utils/sso-lock';\n\nconst { ApplicationError } = errors;\n/**\n * Send an email to the user if it exists and is not locked to SSO\n * If those conditions are not met, nothing happens\n *\n * @param {Object} param params\n * @param {string} param.email user email for which to reset the password\n */\nconst forgotPassword = async ({ email }: any = {}) => {\n  const user = await strapi.query('admin::user').findOne({ where: { email, isActive: true } });\n\n  if (!user || (await isSsoLocked(user))) {\n    return;\n  }\n\n  const resetPasswordToken = getService('token').createToken();\n  await getService('user').updateById(user.id, { resetPasswordToken });\n\n  // Send an email to the admin.\n  const url = `${getAbsoluteAdminUrl(\n    strapi.config\n  )}/auth/reset-password?code=${resetPasswordToken}`;\n  return strapi\n    .plugin('email')\n    .service('email')\n    .sendTemplatedEmail(\n      {\n        to: user.email,\n        from: strapi.config.get('admin.forgotPassword.from'),\n        replyTo: strapi.config.get('admin.forgotPassword.replyTo'),\n      },\n      strapi.config.get('admin.forgotPassword.emailTemplate'),\n      {\n        url,\n        user: _.pick(user, ['email', 'firstname', 'lastname', 'username']),\n      }\n    )\n    .catch((err: unknown) => {\n      // log error server side but do not disclose it to the user to avoid leaking informations\n      strapi.log.error(err);\n    });\n};\n\n/**\n * Reset a user password\n * @param {Object} param params\n * @param {string} param.resetPasswordToken token generated to request a password reset\n * @param {string} param.password new user password\n */\nconst resetPassword = async ({ resetPasswordToken, password }: any = {}) => {\n  const matchingUser = await strapi\n    .query('admin::user')\n    .findOne({ where: { resetPasswordToken, isActive: true } });\n\n  if (!matchingUser || (await isSsoLocked(matchingUser))) {\n    throw new ApplicationError();\n  }\n\n  return getService('user').updateById(matchingUser.id, {\n    password,\n    resetPasswordToken: null,\n  });\n};\n\nexport default {\n  forgotPassword,\n  resetPassword,\n};\n","import { toLower } from 'lodash/fp';\nimport { Strategy as LocalStrategy } from 'passport-local';\nimport type { Strapi } from '@strapi/types';\nimport { getService } from '../../utils';\n\nconst createLocalStrategy = (strapi: Strapi, middleware?: any) => {\n  return new LocalStrategy(\n    {\n      usernameField: 'email',\n      passwordField: 'password',\n      session: false,\n    },\n    (email: string, password: string, done: any) => {\n      return getService('auth')\n        .checkCredentials({ email: toLower(email), password })\n        .then(async ([error, user, message]) => {\n          if (middleware) {\n            return middleware([error, user, message], done);\n          }\n\n          return done(error, user, message);\n        })\n        .catch((error) => done(error));\n    }\n  );\n};\n\nexport default createLocalStrategy;\n","import passport from 'koa-passport';\nimport type { Strategy } from 'passport-local';\nimport { isFunction } from 'lodash/fp';\n\nimport createLocalStrategy from './passport/local-strategy';\n\nconst authEventsMapper = {\n  onConnectionSuccess: 'admin.auth.success',\n  onConnectionError: 'admin.auth.error',\n};\n\nconst valueIsFunctionType = ([, value]: [any, any]) => isFunction(value);\nconst keyIsValidEventName = ([key]: any) => {\n  return Object.keys(strapi.admin.services.passport.authEventsMapper).includes(key);\n};\n\nconst getPassportStrategies = () => [createLocalStrategy(strapi)] as Strategy[];\n\nconst registerAuthEvents = () => {\n  // @ts-expect-error - TODO: migrate auth service to TS\n  const { events = {} } = strapi.config.get('admin.auth', {});\n  const { authEventsMapper } = strapi.admin.services.passport;\n\n  const eventList = Object.entries(events).filter(keyIsValidEventName).filter(valueIsFunctionType);\n\n  for (const [eventName, handler] of eventList) {\n    // TODO - TS: ensure the handler is an EventHub.Listener\n    strapi.eventHub.on(authEventsMapper[eventName], handler as any);\n  }\n};\n\nconst init = () => {\n  strapi.admin.services.passport\n    .getPassportStrategies()\n    .forEach((strategy: Strategy) => passport.use(strategy));\n\n  registerAuthEvents();\n\n  return passport.initialize();\n};\n\nexport default { init, getPassportStrategies, authEventsMapper };\n","import '@strapi/types';\n\nexport default () => {\n  const registry = new Map();\n\n  Object.assign(registry, {\n    register(provider: unknown) {\n      if (strapi.isLoaded) {\n        throw new Error(`You can't register new provider after the bootstrap`);\n      }\n\n      // TODO\n      // @ts-expect-error check map types\n      this.set(provider.uid, provider);\n    },\n\n    registerMany(providers: unknown[]) {\n      providers.forEach((provider) => {\n        this.register(provider);\n      });\n    },\n\n    getAll(): unknown[] {\n      // TODO\n      // @ts-expect-error check map types\n      return Array.from(this.values());\n    },\n  });\n\n  return registry;\n};\n","import '@strapi/types';\nimport EE from '@strapi/strapi/dist/utils/ee';\nimport passport from '../../../../../server/src/services/passport';\nimport createProviderRegistry from './provider-registry';\n\nexport const providerRegistry = createProviderRegistry();\nconst errorMessage = 'SSO is disabled. Its functionnalities cannot be accessed.';\n\nexport const getStrategyCallbackURL = (providerName: string) => {\n  if (!EE.features.isEnabled('sso')) {\n    throw new Error(errorMessage);\n  }\n\n  return `/admin/connect/${providerName}`;\n};\n\nexport const syncProviderRegistryWithConfig = () => {\n  if (!EE.features.isEnabled('sso')) {\n    throw new Error(errorMessage);\n  }\n\n  const { providers = [] } = strapi.config.get('admin.auth', {}) as any;\n\n  // TODO\n  // @ts-expect-error check map types\n  providerRegistry.registerMany(providers);\n};\n\nexport const SSOAuthEventsMapper = {\n  onSSOAutoRegistration: 'admin.auth.autoRegistration',\n};\n\nexport default {\n  providerRegistry,\n  getStrategyCallbackURL,\n  syncProviderRegistryWithConfig,\n  authEventsMapper: { ...passport.authEventsMapper, ...SSOAuthEventsMapper },\n};\n","import EE from '@strapi/strapi/dist/utils/ee';\n\nimport { errors } from '@strapi/utils';\nimport createLocalStrategy from '../../../../server/src/services/passport/local-strategy';\nimport sso from './passport/sso';\nimport { isSsoLocked } from '../utils/sso-lock';\n\nconst { UnauthorizedError } = errors;\n\nconst localStrategyMiddleware = async ([error, user, message]: any, done: any) => {\n  // if we got a user, we need to check that it's not sso locked\n  if (user && !error && (await isSsoLocked(user))) {\n    return done(\n      new UnauthorizedError('Login not allowed, please contact your administrator', {\n        code: 'LOGIN_NOT_ALLOWED',\n      }),\n      user,\n      message\n    );\n  }\n\n  return done(error, user, message);\n};\n\nconst getPassportStrategies = () => {\n  if (!EE.features.isEnabled('sso')) {\n    return [createLocalStrategy(strapi)];\n  }\n\n  const localStrategy = createLocalStrategy(strapi, localStrategyMiddleware);\n\n  if (!strapi.isLoaded) {\n    sso.syncProviderRegistryWithConfig();\n  }\n\n  // TODO\n  // @ts-expect-error check map types\n  const providers = sso.providerRegistry.getAll();\n  const strategies = providers.map((provider: any) => provider.createStrategy(strapi));\n\n  return [localStrategy, ...strategies];\n};\n\nexport default {\n  getPassportStrategies,\n  ...sso,\n};\n","import { toString } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\n\nconst { ApplicationError } = errors;\n\nconst ssoCheckRolesIdForDeletion = async (ids: any) => {\n  const adminStore = await strapi.store({ type: 'core', name: 'admin' });\n\n  const {\n    providers: { defaultRole },\n  } = (await adminStore.get({ key: 'auth' })) as any;\n\n  for (const roleId of ids) {\n    if (defaultRole && toString(defaultRole) === toString(roleId)) {\n      throw new ApplicationError(\n        'This role is used as the default SSO role. Make sure to change this configuration before deleting the role'\n      );\n    }\n  }\n};\n\nexport default {\n  ssoCheckRolesIdForDeletion,\n};\n","import constants from '../services/constants';\n\nimport type {\n  AdminUser,\n  AdminRole,\n  AdminUserCreationPayload,\n} from '../../../shared/contracts/shared';\n\nconst { SUPER_ADMIN_CODE } = constants;\n\n/**\n * Create a new user model by merging default and specified attributes\n * @param attributes A partial user object\n */\nexport function createUser(attributes: Partial<AdminUserCreationPayload>) {\n  return {\n    roles: [],\n    isActive: false,\n    username: null,\n    ...attributes,\n  };\n}\n\nexport const hasSuperAdminRole = (user: AdminUser) => {\n  return user.roles.filter((role: AdminRole) => role.code === SUPER_ADMIN_CODE).length > 0;\n};\n\nexport const ADMIN_USER_ALLOWED_FIELDS = ['id', 'firstname', 'lastname', 'username'];\n\nexport default {\n  createUser,\n  hasSuperAdminRole,\n  ADMIN_USER_ALLOWED_FIELDS,\n};\n","import _ from 'lodash';\nimport { pipe, map, castArray, toNumber } from 'lodash/fp';\nimport { stringIncludes } from '@strapi/utils';\nimport { errors } from '@strapi/utils';\nimport { hasSuperAdminRole } from '../../../../server/src/domain/user';\nimport constants from '../../../../server/src/services/constants';\nimport { getService } from '../utils';\n\nconst { ValidationError } = errors;\nconst { SUPER_ADMIN_CODE } = constants;\n\n/** Checks if ee disabled users list needs to be updated\n * @param {string} id\n * @param {object} input\n */\nconst updateEEDisabledUsersList = async (id: string, input: any) => {\n  const disabledUsers = await getService('seat-enforcement').getDisabledUserList();\n\n  if (!disabledUsers) {\n    return;\n  }\n\n  const user = disabledUsers.find((user: any) => user.id === Number(id));\n  if (!user) {\n    return;\n  }\n\n  if (user.isActive !== input.isActive) {\n    const newDisabledUsersList = disabledUsers.filter((user: any) => user.id !== Number(id));\n    await strapi.store.set({\n      type: 'ee',\n      key: 'disabled_users',\n      value: newDisabledUsersList,\n    });\n  }\n};\n\nconst castNumberArray = pipe(castArray, map(toNumber));\n\nconst removeFromEEDisabledUsersList = async (ids: unknown) => {\n  let idsToCheck: any;\n  if (typeof ids === 'object') {\n    idsToCheck = castNumberArray(ids);\n  } else {\n    idsToCheck = [Number(ids)];\n  }\n\n  const disabledUsers = await getService('seat-enforcement').getDisabledUserList();\n\n  if (!disabledUsers) {\n    return;\n  }\n\n  const newDisabledUsersList = disabledUsers.filter((user: any) => !idsToCheck.includes(user.id));\n  await strapi.store.set({\n    type: 'ee',\n    key: 'disabled_users',\n    value: newDisabledUsersList,\n  });\n};\n\n/**\n * Update a user in database\n * @param id query params to find the user to update\n * @param attributes A partial user object\n * @returns {Promise<user>}\n */\nconst updateById = async (id: any, attributes: any) => {\n  // Check at least one super admin remains\n  if (_.has(attributes, 'roles')) {\n    const lastAdminUser = await isLastSuperAdminUser(id);\n    const superAdminRole = await getService('role').getSuperAdminWithUsersCount();\n    const willRemoveSuperAdminRole = !stringIncludes(attributes.roles, superAdminRole.id);\n\n    if (lastAdminUser && willRemoveSuperAdminRole) {\n      throw new ValidationError('You must have at least one user with super admin role.');\n    }\n  }\n\n  // cannot disable last super admin\n  if (attributes.isActive === false) {\n    const lastAdminUser = await isLastSuperAdminUser(id);\n    if (lastAdminUser) {\n      throw new ValidationError('You must have at least one user with super admin role.');\n    }\n  }\n\n  // hash password if a new one is sent\n  if (_.has(attributes, 'password')) {\n    const hashedPassword = await getService('auth').hashPassword(attributes.password);\n\n    const updatedUser = await strapi.query('admin::user').update({\n      where: { id },\n      data: {\n        ...attributes,\n        password: hashedPassword,\n      },\n      populate: ['roles'],\n    });\n\n    strapi.eventHub.emit('user.update', { user: sanitizeUser(updatedUser) });\n\n    return updatedUser;\n  }\n\n  const updatedUser = await strapi.query('admin::user').update({\n    where: { id },\n    data: attributes,\n    populate: ['roles'],\n  });\n\n  await updateEEDisabledUsersList(id, attributes);\n\n  if (updatedUser) {\n    strapi.eventHub.emit('user.update', { user: sanitizeUser(updatedUser) });\n  }\n\n  return updatedUser;\n};\n\n/** Delete a user\n * @param id id of the user to delete\n * @returns {Promise<user>}\n */\nconst deleteById = async (id: unknown) => {\n  // Check at least one super admin remains\n  const userToDelete = await strapi.query('admin::user').findOne({\n    where: { id },\n    populate: ['roles'],\n  });\n\n  if (!userToDelete) {\n    return null;\n  }\n\n  if (userToDelete) {\n    if (userToDelete.roles.some((r: any) => r.code === SUPER_ADMIN_CODE)) {\n      const superAdminRole = await getService('role').getSuperAdminWithUsersCount();\n      if (superAdminRole.usersCount === 1) {\n        throw new ValidationError('You must have at least one user with super admin role.');\n      }\n    }\n  }\n\n  const deletedUser = await strapi\n    .query('admin::user')\n    .delete({ where: { id }, populate: ['roles'] });\n\n  await removeFromEEDisabledUsersList(id);\n\n  strapi.eventHub.emit('user.delete', { user: sanitizeUser(deletedUser) });\n\n  return deletedUser;\n};\n\n/** Delete a user\n * @param ids ids of the users to delete\n * @returns {Promise<user>}\n */\nconst deleteByIds = async (ids: any) => {\n  // Check at least one super admin remains\n  const superAdminRole = await getService('role').getSuperAdminWithUsersCount();\n  const nbOfSuperAdminToDelete = await strapi.query('admin::user').count({\n    where: {\n      id: ids,\n      roles: { id: superAdminRole.id },\n    },\n  });\n\n  if (superAdminRole.usersCount === nbOfSuperAdminToDelete) {\n    throw new ValidationError('You must have at least one user with super admin role.');\n  }\n\n  const deletedUsers = [];\n  for (const id of ids) {\n    const deletedUser = await strapi.query('admin::user').delete({\n      where: { id },\n      populate: ['roles'],\n    });\n\n    deletedUsers.push(deletedUser);\n  }\n\n  await removeFromEEDisabledUsersList(ids);\n\n  strapi.eventHub.emit('user.delete', {\n    users: deletedUsers.map((deletedUser) => sanitizeUser(deletedUser)),\n  });\n\n  return deletedUsers;\n};\n\nconst sanitizeUserRoles = (role: unknown) => _.pick(role, ['id', 'name', 'description', 'code']);\n\n/**\n * Check if a user is the last super admin\n * @param {int|string} userId user's id to look for\n */\nconst isLastSuperAdminUser = async (userId: unknown) => {\n  const user = (await findOne(userId)) as any;\n  const superAdminRole = await getService('role').getSuperAdminWithUsersCount();\n\n  return superAdminRole.usersCount === 1 && hasSuperAdminRole(user);\n};\n\n/**\n * Remove private user fields\n * @param {Object} user - user to sanitize\n */\nconst sanitizeUser = (user: any) => {\n  return {\n    ..._.omit(user, ['password', 'resetPasswordToken', 'registrationToken', 'roles']),\n    roles: user.roles && user.roles.map(sanitizeUserRoles),\n  };\n};\n\n/**\n * Find one user\n */\nconst findOne = async (id: any, populate = ['roles']) => {\n  return strapi.entityService.findOne('admin::user', id, { populate });\n};\n\nconst getCurrentActiveUserCount = async () => {\n  return strapi.db.query('admin::user').count({ where: { isActive: true } });\n};\n\nexport default {\n  updateEEDisabledUsersList,\n  removeFromEEDisabledUsersList,\n  getCurrentActiveUserCount,\n  deleteByIds,\n  deleteById,\n  updateById,\n};\n","import { assign } from 'lodash/fp';\nimport type { Strapi } from '@strapi/types';\nimport EE from '@strapi/strapi/dist/utils/ee';\nimport { getService } from '../utils';\n\nconst getSSOProvidersList = async () => {\n  const { providerRegistry } = strapi.admin.services.passport;\n\n  return providerRegistry.getAll().map(({ uid }: { uid: string }) => uid);\n};\n\nconst sendUpdateProjectInformation = async () => {\n  let groupProperties = {};\n\n  const numberOfActiveAdminUsers = await getService('user').count({ isActive: true });\n  const numberOfAdminUsers = await getService('user').count();\n\n  if (EE.features.isEnabled('sso')) {\n    const SSOProviders = await getSSOProvidersList();\n\n    groupProperties = assign(groupProperties, {\n      SSOProviders,\n      isSSOConfigured: SSOProviders.length !== 0,\n    });\n  }\n\n  if (EE.features.isEnabled('cms-content-releases')) {\n    const numberOfContentReleases = await strapi.entityService.count(\n      'plugin::content-releases.release'\n    );\n    const numberOfPublishedContentReleases = await strapi.entityService.count(\n      'plugin::content-releases.release',\n      {\n        filters: { $not: { releasedAt: null } },\n      }\n    );\n\n    groupProperties = assign(groupProperties, {\n      numberOfContentReleases,\n      numberOfPublishedContentReleases,\n    });\n  }\n\n  groupProperties = assign(groupProperties, { numberOfActiveAdminUsers, numberOfAdminUsers });\n\n  strapi.telemetry.send('didUpdateProjectInformation', {\n    groupProperties,\n  });\n};\n\nconst startCron = (strapi: Strapi) => {\n  strapi.cron.add({\n    '0 0 0 * * *': () => sendUpdateProjectInformation(),\n  });\n};\n\nexport default { startCron, getSSOProvidersList, sendUpdateProjectInformation };\n","// eslint-disable-next-line node/no-extraneous-require\nimport ee from '@strapi/strapi/dist/utils/ee';\nimport { take, drop, map, prop, pick, reverse, isNil } from 'lodash/fp';\nimport { getService } from '../utils';\nimport constants from '../../../../server/src/services/constants';\n\nconst { SUPER_ADMIN_CODE } = constants;\n\n/**\n * Keeps the list of users disabled by the seat enforcement service\n */\nconst getDisabledUserList = async () => {\n  return strapi.store.get({ type: 'ee', key: 'disabled_users' });\n};\n\nconst enableMaximumUserCount = async (numberOfUsersToEnable: number) => {\n  const disabledUsers = (await getDisabledUserList()) as any;\n  const orderedDisabledUsers = reverse(disabledUsers);\n\n  const usersToEnable = take(numberOfUsersToEnable, orderedDisabledUsers);\n\n  await strapi.db.query('admin::user').updateMany({\n    where: { id: map(prop('id'), usersToEnable) },\n    data: { isActive: true },\n  });\n\n  const remainingDisabledUsers = drop(numberOfUsersToEnable, orderedDisabledUsers);\n\n  await strapi.store.set({\n    type: 'ee',\n    key: 'disabled_users',\n    value: remainingDisabledUsers,\n  });\n};\n\nconst disableUsersAboveLicenseLimit = async (numberOfUsersToDisable: number) => {\n  const currentlyDisabledUsers: any = (await getDisabledUserList()) ?? [];\n\n  const usersToDisable = [];\n  const nonSuperAdminUsersToDisable = await strapi.db.query('admin::user').findMany({\n    where: {\n      isActive: true,\n      roles: {\n        code: { $ne: SUPER_ADMIN_CODE },\n      },\n    },\n    orderBy: { createdAt: 'DESC' },\n    limit: numberOfUsersToDisable,\n  });\n\n  usersToDisable.push(...nonSuperAdminUsersToDisable);\n\n  if (nonSuperAdminUsersToDisable.length < numberOfUsersToDisable) {\n    const superAdminUsersToDisable = await strapi.db.query('admin::user').findMany({\n      where: {\n        isActive: true,\n        roles: { code: SUPER_ADMIN_CODE },\n      },\n      orderBy: { createdAt: 'DESC' },\n      limit: numberOfUsersToDisable - nonSuperAdminUsersToDisable.length,\n    });\n\n    usersToDisable.push(...superAdminUsersToDisable);\n  }\n\n  await strapi.db.query('admin::user').updateMany({\n    where: { id: map(prop('id'), usersToDisable) },\n    data: { isActive: false },\n  });\n\n  await strapi.store.set({\n    type: 'ee',\n    key: 'disabled_users',\n    value: currentlyDisabledUsers.concat(map(pick(['id', 'isActive']), usersToDisable)),\n  });\n};\n\nconst syncDisabledUserRecords = async () => {\n  const disabledUsers = await strapi.store.get({ type: 'ee', key: 'disabled_users' });\n\n  if (!disabledUsers) {\n    return;\n  }\n\n  await strapi.db.query('admin::user').updateMany({\n    where: { id: map(prop('id'), disabledUsers) },\n    data: { isActive: false },\n  });\n};\n\nconst seatEnforcementWorkflow = async () => {\n  const adminSeats = ee.seats;\n  if (isNil(adminSeats)) {\n    return;\n  }\n\n  // TODO: we need to make sure an admin can decide to disable specific user and reactivate others\n  await syncDisabledUserRecords();\n\n  const currentActiveUserCount = await getService('user').getCurrentActiveUserCount();\n\n  const adminSeatsLeft = adminSeats - currentActiveUserCount;\n\n  if (adminSeatsLeft > 0) {\n    await enableMaximumUserCount(adminSeatsLeft);\n  } else if (adminSeatsLeft < 0) {\n    await disableUsersAboveLicenseLimit(-adminSeatsLeft);\n  }\n};\n\nexport default {\n  seatEnforcementWorkflow,\n  getDisabledUserList,\n};\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport { mapAsync } from '@strapi/utils';\nimport { difference, merge } from 'lodash/fp';\nimport { getService } from '../../../utils';\nimport { WORKFLOW_MODEL_UID } from '../../../constants/workflows';\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const contentManagerContentTypeService = strapi\n    .plugin('content-manager')\n    .service('content-types');\n  const stagesService = getService('stages', { strapi });\n\n  const updateContentTypeConfig = async (uid: any, reviewWorkflowOption: any) => {\n    // Merge options in the configuration as the configuration service use a destructuration merge which doesn't include nested objects\n    const modelConfig = await contentManagerContentTypeService.findConfiguration(uid);\n\n    await contentManagerContentTypeService.updateConfiguration(\n      { uid },\n      { options: merge(modelConfig.options, { reviewWorkflows: reviewWorkflowOption }) }\n    );\n  };\n\n  return {\n    /**\n     * Migrates entities stages. Used when a content type is assigned to a workflow.\n     * @param {*} options\n     * @param {Array<string>} options.srcContentTypes - The content types assigned to the previous workflow\n     * @param {Array<string>} options.destContentTypes - The content types assigned to the new workflow\n     * @param {Workflow.Stage} options.stageId - The new stage to assign the entities to\n     */\n    async migrate({ srcContentTypes = [], destContentTypes, stageId }: any) {\n      const workflowsService = getService('workflows', { strapi });\n      const { created, deleted } = diffContentTypes(srcContentTypes, destContentTypes);\n\n      await mapAsync(\n        created,\n        async (uid: any) => {\n          // Content Types should only be assigned to one workflow\n          // However, edge cases can happen, and this handles them\n          const srcWorkflows = await workflowsService._getAssignedWorkflows(uid, {});\n\n          if (srcWorkflows.length) {\n            // Updates all existing entities stages links to the new stage\n            await stagesService.updateEntitiesStage(uid, { toStageId: stageId });\n            // Transfer content types from the previous workflow(s)\n            await mapAsync(srcWorkflows, (srcWorkflow: any) =>\n              this.transferContentTypes(srcWorkflow, uid)\n            );\n          }\n          await updateContentTypeConfig(uid, true);\n\n          // Create new stages links to the new stage\n          return stagesService.updateEntitiesStage(uid, {\n            fromStageId: null,\n            toStageId: stageId,\n          });\n        },\n        // transferContentTypes can cause race conditions if called in parallel when updating the same workflow\n        { concurrency: 1 }\n      );\n\n      await mapAsync(deleted, async (uid: any) => {\n        await updateContentTypeConfig(uid, false);\n        await stagesService.deleteAllEntitiesStage(uid, {});\n      });\n    },\n\n    /**\n     * Filters the content types assigned to a workflow\n     * @param {Workflow} srcWorkflow - The workflow to transfer from\n     * @param {string} uid - The content type uid\n     */\n    async transferContentTypes(srcWorkflow: any, uid: any) {\n      // Update assignedContentTypes of the previous workflow\n      await strapi.entityService.update(WORKFLOW_MODEL_UID, srcWorkflow.id, {\n        data: {\n          contentTypes: srcWorkflow.contentTypes.filter((contentType: any) => contentType !== uid),\n        },\n      });\n    },\n  };\n};\n\nconst diffContentTypes = (srcContentTypes: any, destContentTypes: any) => {\n  const created = difference(destContentTypes, srcContentTypes);\n  const deleted = difference(srcContentTypes, destContentTypes);\n  return { created, deleted };\n};\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport { set, isString, map, get } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\nimport { WORKFLOW_MODEL_UID, WORKFLOW_POPULATE } from '../../../constants/workflows';\nimport { getService } from '../../../utils';\nimport { getWorkflowContentTypeFilter } from '../../../utils/review-workflows';\nimport workflowsContentTypesFactory from './content-types';\n\nconst { ApplicationError } = errors;\nconst processFilters = ({ strapi }: { strapi: Strapi }, filters: any = {}) => {\n  const processedFilters = { ...filters };\n\n  if (isString(filters.contentTypes)) {\n    processedFilters.contentTypes = getWorkflowContentTypeFilter({ strapi }, filters.contentTypes);\n  }\n\n  return processedFilters;\n};\n\n// TODO: How can we improve this? Maybe using traversePopulate?\nconst processPopulate = (populate: any) => {\n  // If it does not exist or it's not an object (like an array) return the default populate\n  if (!populate) {\n    return populate;\n  }\n\n  return WORKFLOW_POPULATE;\n};\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const workflowsContentTypes = workflowsContentTypesFactory({ strapi });\n  const workflowsValidationService = getService('review-workflows-validation', { strapi });\n  const metrics = getService('review-workflows-metrics', { strapi });\n\n  return {\n    /**\n     * Returns all the workflows matching the user-defined filters.\n     * @param {object} opts - Options for the query.\n     * @param {object} opts.filters - Filters object.\n     * @returns {Promise<object[]>} - List of workflows that match the user's filters.\n     */\n    async find(opts: any = {}) {\n      const filters = processFilters({ strapi }, opts.filters);\n      const populate = processPopulate(opts.populate);\n\n      return strapi.entityService.findMany(WORKFLOW_MODEL_UID, { ...opts, filters, populate });\n    },\n\n    /**\n     * Returns the workflow with the specified ID.\n     * @param {string} id - ID of the requested workflow.\n     * @param {object} opts - Options for the query.\n     * @returns {Promise<object>} - Workflow object matching the requested ID.\n     */\n    findById(id: any, opts: any) {\n      const populate = processPopulate(opts.populate);\n      return strapi.entityService.findOne(WORKFLOW_MODEL_UID, id, { ...opts, populate });\n    },\n\n    /**\n     * Creates a new workflow.\n     * @param {object} opts - Options for creating the new workflow.\n     * @returns {Promise<object>} - Workflow object that was just created.\n     * @throws {ValidationError} - If the workflow has no stages.\n     */\n    async create(opts: any) {\n      let createOpts = { ...opts, populate: WORKFLOW_POPULATE };\n\n      workflowsValidationService.validateWorkflowStages(opts.data.stages);\n      await workflowsValidationService.validateWorkflowCount(1);\n\n      return strapi.db.transaction(async () => {\n        // Create stages\n        const stages = await getService('stages', { strapi }).createMany(opts.data.stages);\n        const mapIds = map(get('id'));\n\n        createOpts = set('data.stages', mapIds(stages), createOpts);\n\n        // Update (un)assigned Content Types\n        if (opts.data.contentTypes) {\n          await workflowsContentTypes.migrate({\n            destContentTypes: opts.data.contentTypes,\n            stageId: stages[0].id,\n          });\n        }\n\n        metrics.sendDidCreateWorkflow();\n\n        // Create Workflow\n        return strapi.entityService.create(WORKFLOW_MODEL_UID, createOpts);\n      });\n    },\n\n    /**\n     * Updates an existing workflow.\n     * @param {object} workflow - The existing workflow to update.\n     * @param {object} opts - Options for updating the workflow.\n     * @returns {Promise<object>} - Workflow object that was just updated.\n     * @throws {ApplicationError} - If the supplied stage ID does not belong to the workflow.\n     */\n    async update(workflow: any, opts: any) {\n      const stageService = getService('stages', { strapi });\n      let updateOpts = { ...opts, populate: { ...WORKFLOW_POPULATE } };\n      let updatedStageIds: any;\n\n      await workflowsValidationService.validateWorkflowCount();\n\n      return strapi.db.transaction(async () => {\n        // Update stages\n        if (opts.data.stages) {\n          workflowsValidationService.validateWorkflowStages(opts.data.stages);\n          opts.data.stages.forEach((stage: any) =>\n            this.assertStageBelongsToWorkflow(stage.id, workflow)\n          );\n\n          updatedStageIds = await stageService\n            .replaceStages(workflow.stages, opts.data.stages, workflow.contentTypes)\n            .then((stages: any) => stages.map((stage: any) => stage.id));\n\n          updateOpts = set('data.stages', updatedStageIds, updateOpts);\n        }\n\n        // Update (un)assigned Content Types\n        if (opts.data.contentTypes) {\n          await workflowsContentTypes.migrate({\n            srcContentTypes: workflow.contentTypes,\n            destContentTypes: opts.data.contentTypes,\n            stageId: updatedStageIds ? updatedStageIds[0] : workflow.stages[0].id,\n          });\n        }\n\n        metrics.sendDidEditWorkflow();\n\n        // Update Workflow\n        return strapi.entityService.update(WORKFLOW_MODEL_UID, workflow.id, updateOpts);\n      });\n    },\n\n    /**\n     * Deletes an existing workflow.\n     * Also deletes all the workflow stages and migrate all assigned the content types.\n     * @param {*} workflow\n     * @param {*} opts\n     * @returns\n     */\n    async delete(workflow: any, opts: any) {\n      const stageService = getService('stages', { strapi });\n\n      const workflowCount = await this.count();\n\n      if (workflowCount <= 1) {\n        throw new ApplicationError('Can not delete the last workflow');\n      }\n\n      return strapi.db.transaction(async () => {\n        // Delete stages\n        await stageService.deleteMany(workflow.stages);\n\n        // Unassign all content types, this will migrate the content types to null\n        await workflowsContentTypes.migrate({\n          srcContentTypes: workflow.contentTypes,\n          destContentTypes: [],\n        });\n\n        // Delete Workflow\n        return strapi.entityService.delete(WORKFLOW_MODEL_UID, workflow.id, opts);\n      });\n    },\n    /**\n     * Returns the total count of workflows.\n     * @returns {Promise<number>} - Total count of workflows.\n     */\n    count() {\n      return strapi.entityService.count(WORKFLOW_MODEL_UID);\n    },\n\n    /**\n     * Finds the assigned workflow for a given content type ID.\n     * @param {string} uid - Content type ID to find the assigned workflow for.\n     * @param {object} opts - Options for the query.\n     * @returns {Promise<object|null>} - Assigned workflow object if found, or null.\n     */\n    async getAssignedWorkflow(uid: any, opts: any = {}) {\n      const workflows = await this._getAssignedWorkflows(uid, opts);\n\n      // @ts-expect-error handle workflow null case\n      return workflows.length > 0 ? workflows[0] : null;\n    },\n\n    /**\n     * Finds all the assigned workflows for a given content type ID.\n     * Normally, there should only be one workflow assigned to a content type.\n     * However, edge cases can occur where a content type is assigned to multiple workflows.\n     * @param {string} uid - Content type ID to find the assigned workflows for.\n     * @param {object} opts - Options for the query.\n     * @returns {Promise<object[]>} - List of assigned workflow objects.\n     */\n    async _getAssignedWorkflows(uid: any, opts = {}) {\n      return this.find({\n        ...opts,\n        filters: { contentTypes: getWorkflowContentTypeFilter({ strapi }, uid) },\n      });\n    },\n\n    /**\n     * Asserts that a content type has an assigned workflow.\n     * @param {string} uid - Content type ID to verify the assignment of.\n     * @returns {Promise<object>} - Workflow object associated with the content type ID.\n     * @throws {ApplicationError} - If no assigned workflow is found for the content type ID.\n     */\n    async assertContentTypeBelongsToWorkflow(uid: any) {\n      const workflow = await this.getAssignedWorkflow(uid, {\n        populate: 'stages',\n      });\n      if (!workflow) {\n        throw new ApplicationError(`Review workflows is not activated on Content Type ${uid}.`);\n      }\n      return workflow;\n    },\n\n    /**\n     * Asserts that a stage belongs to a given workflow.\n     * @param {string} stageId - ID of stage to check.\n     * @param {object} workflow - Workflow object to check against.\n     * @returns\n     * @throws {ApplicationError} - If the stage does not belong to the specified workflow.\n     */\n    assertStageBelongsToWorkflow(stageId: any, workflow: any) {\n      if (!stageId) {\n        return;\n      }\n\n      const belongs = workflow.stages.some((stage: any) => stage.id === stageId);\n      if (!belongs) {\n        throw new ApplicationError(`Stage does not belong to workflow \"${workflow.name}\"`);\n      }\n    },\n  };\n};\n","import { Entity, LoadedStrapi as Strapi } from '@strapi/types';\nimport { mapAsync, reduceAsync, errors } from '@strapi/utils';\nimport { map, pick, isEqual } from 'lodash/fp';\nimport { STAGE_MODEL_UID, ENTITY_STAGE_ATTRIBUTE, ERRORS } from '../../constants/workflows';\nimport { getService } from '../../utils';\n\nconst { ApplicationError, ValidationError } = errors;\nconst sanitizedStageFields = ['id', 'name', 'workflow', 'color'];\nconst sanitizeStageFields = pick(sanitizedStageFields);\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const metrics = getService('review-workflows-metrics', { strapi });\n  const stagePermissionsService = getService('stage-permissions', { strapi });\n  const workflowsValidationService = getService('review-workflows-validation', { strapi });\n\n  return {\n    find({ workflowId, populate }: any) {\n      const params = {\n        filters: { workflow: workflowId },\n        populate,\n      };\n      return strapi.entityService.findMany(STAGE_MODEL_UID, params);\n    },\n\n    findById(id: Entity.ID, { populate }: any = {}) {\n      const params = {\n        populate,\n      };\n      return strapi.entityService.findOne(STAGE_MODEL_UID, id, params);\n    },\n\n    async createMany(stagesList: any, { fields }: any = {}) {\n      const params = { select: fields ?? '*' };\n\n      // TODO: pick the fields from the stage\n      const stages = await Promise.all(\n        stagesList.map((stage: any) =>\n          strapi.entityService.create(STAGE_MODEL_UID, {\n            data: sanitizeStageFields(stage),\n            ...params,\n          })\n        )\n      );\n\n      // Create stage permissions\n      await reduceAsync(stagesList)(async (_, stage, idx) => {\n        // Ignore stages without permissions\n        if (!stage.permissions || stage.permissions.length === 0) {\n          return;\n        }\n\n        const stagePermissions = stage.permissions;\n        const stageId = stages[idx].id;\n\n        const permissions = await mapAsync(\n          stagePermissions,\n          // Register each stage permission\n          (permission: any) =>\n            stagePermissionsService.register({\n              roleId: permission.role,\n              action: permission.action,\n              fromStage: stageId,\n            })\n        );\n\n        // Update stage with the new permissions\n        await strapi.entityService.update(STAGE_MODEL_UID, stageId, {\n          data: {\n            permissions: permissions.flat().map((p: any) => p.id),\n          },\n        });\n      }, []);\n\n      metrics.sendDidCreateStage();\n\n      return stages;\n    },\n\n    async update(srcStage: any, destStage: any) {\n      let stagePermissions = srcStage?.permissions ?? [];\n      const stageId = destStage.id;\n\n      if (destStage.permissions) {\n        await this.deleteStagePermissions([srcStage]);\n\n        const permissions = await mapAsync(destStage.permissions, (permission: any) =>\n          stagePermissionsService.register({\n            roleId: permission.role,\n            action: permission.action,\n            fromStage: stageId,\n          })\n        );\n        stagePermissions = permissions.flat().map((p: any) => p.id);\n      }\n\n      const stage = await strapi.entityService.update(STAGE_MODEL_UID, stageId, {\n        data: {\n          ...destStage,\n          permissions: stagePermissions,\n        },\n      });\n\n      metrics.sendDidEditStage();\n\n      return stage;\n    },\n\n    async delete(stage: any) {\n      // Unregister all permissions related to this stage id\n      await this.deleteStagePermissions([stage]);\n\n      const deletedStage = await strapi.entityService.delete(STAGE_MODEL_UID, stage.id);\n\n      metrics.sendDidDeleteStage();\n\n      return deletedStage;\n    },\n\n    async deleteMany(stages: any) {\n      await this.deleteStagePermissions(stages);\n\n      return strapi.entityService.deleteMany(STAGE_MODEL_UID, {\n        filters: { id: { $in: stages.map((s: any) => s.id) } },\n      });\n    },\n\n    async deleteStagePermissions(stages: any) {\n      // TODO: Find another way to do this for when we use the \"to\" parameter.\n      const permissions = stages.map((s: any) => s.permissions || []).flat();\n      await stagePermissionsService.unregister(permissions || []);\n    },\n\n    count({ workflowId }: any = {}) {\n      const opts = {} as any;\n\n      if (workflowId) {\n        opts.where = {\n          workflow: workflowId,\n        };\n      }\n      return strapi.entityService.count(STAGE_MODEL_UID, opts);\n    },\n\n    async replaceStages(srcStages: any, destStages: any, contentTypesToMigrate = []) {\n      const { created, updated, deleted } = getDiffBetweenStages(srcStages, destStages);\n\n      assertAtLeastOneStageRemain(srcStages || [], { created, deleted });\n\n      // Update stages and assign entity stages\n      return strapi.db.transaction(async ({ trx }) => {\n        // Create the new stages\n        const createdStages = await this.createMany(created, { fields: ['id'] });\n        // Put all the newly created stages ids\n        const createdStagesIds = map('id', createdStages);\n\n        // Update the workflow stages\n        await mapAsync(updated, (destStage: any) => {\n          const srcStage = srcStages.find((s: any) => s.id === destStage.id);\n\n          return this.update(srcStage, destStage);\n        });\n\n        // Delete the stages that are not in the new stages list\n        await mapAsync(deleted, async (stage: any) => {\n          // Find the nearest stage in the workflow and newly created stages\n          // that is not deleted, prioritizing the previous stages\n          const nearestStage = findNearestMatchingStage(\n            [...srcStages, ...createdStages],\n            srcStages.findIndex((s: any) => s.id === stage.id),\n            (targetStage: any) => {\n              return !deleted.find((s: any) => s.id === targetStage.id);\n            }\n          );\n\n          // Assign the new stage to entities that had the deleted stage\n          await mapAsync(contentTypesToMigrate, (contentTypeUID: any) => {\n            this.updateEntitiesStage(contentTypeUID, {\n              fromStageId: stage.id,\n              toStageId: nearestStage.id,\n              trx,\n            });\n          });\n\n          return this.delete(stage);\n        });\n\n        return destStages.map((stage: any) => ({\n          ...stage,\n          id: stage.id ?? createdStagesIds.shift(),\n        }));\n      });\n    },\n\n    /**\n     * Update the stage of an entity\n     *\n     * @param {object} entityInfo\n     * @param {number} entityInfo.id - Entity id\n     * @param {string} entityInfo.modelUID - the content-type of the entity\n     * @param {number} stageId - The id of the stage to assign to the entity\n     */\n    async updateEntity(entityInfo: any, stageId: any) {\n      const stage = await this.findById(stageId);\n\n      await workflowsValidationService.validateWorkflowCount();\n\n      if (!stage) {\n        throw new ApplicationError(`Selected stage does not exist`);\n      }\n\n      const entity = await strapi.entityService.update(entityInfo.modelUID, entityInfo.id, {\n        // @ts-expect-error - entity service can not receive any type of attribute\n        data: { [ENTITY_STAGE_ATTRIBUTE]: stageId },\n        populate: [ENTITY_STAGE_ATTRIBUTE],\n      });\n\n      metrics.sendDidChangeEntryStage();\n\n      return entity;\n    },\n\n    /**\n     * Updates entity stages of a content type:\n     *  - If fromStageId is undefined, all entities with an existing stage will be assigned the new stage\n     *  - If fromStageId is null, all entities without a stage will be assigned the new stage\n     *  - If fromStageId is a number, all entities with that stage will be assigned the new stage\n     *\n     * For performance reasons we use knex queries directly.\n     *\n     * @param {string} contentTypeUID\n     * @param {number | undefined | null} fromStageId\n     * @param {number} toStageId\n     * @param {import('knex').Knex.Transaction} trx\n     * @returns\n     */\n    async updateEntitiesStage(contentTypeUID: any, { fromStageId, toStageId }: any) {\n      const { attributes, tableName } = strapi.db.metadata.get(contentTypeUID) as any;\n      const joinTable = attributes[ENTITY_STAGE_ATTRIBUTE].joinTable;\n      const joinColumn = joinTable.joinColumn.name;\n      const invJoinColumn = joinTable.inverseJoinColumn.name;\n\n      await workflowsValidationService.validateWorkflowCount();\n\n      return strapi.db.transaction(async ({ trx }) => {\n        // Update all already existing links to the new stage\n        if (fromStageId === undefined) {\n          return strapi.db\n            .getConnection()\n            .from(joinTable.name)\n            .update({ [invJoinColumn]: toStageId })\n            .transacting(trx);\n        }\n\n        // Update all links from the specified stage to the new stage\n        const selectStatement = strapi.db\n          .getConnection()\n          .select({ [joinColumn]: 't1.id', [invJoinColumn]: toStageId })\n          .from(`${tableName} as t1`)\n          .leftJoin(`${joinTable.name} as t2`, `t1.id`, `t2.${joinColumn}`)\n          .where(`t2.${invJoinColumn}`, fromStageId)\n          .toSQL();\n\n        // Insert rows for all entries of the content type that have the specified stage\n        return strapi.db\n          .getConnection(joinTable.name)\n          .insert(\n            strapi.db.connection.raw(\n              `(${joinColumn}, ${invJoinColumn})  ${selectStatement.sql}`,\n              selectStatement.bindings\n            )\n          )\n          .transacting(trx);\n      });\n    },\n\n    /**\n     * Deletes all entity stages of a content type\n     * @param {string} contentTypeUID\n     * @returns\n     */\n    async deleteAllEntitiesStage(contentTypeUID: any) {\n      const { attributes } = strapi.db.metadata.get(contentTypeUID) as any;\n      const joinTable = attributes[ENTITY_STAGE_ATTRIBUTE].joinTable;\n\n      // Delete all stage links for the content type\n      return strapi.db.transaction(async ({ trx }) =>\n        strapi.db.getConnection().from(joinTable.name).delete().transacting(trx)\n      );\n    },\n  };\n};\n\n/**\n * Compares two arrays of stages and returns an object indicating the differences.\n *\n * The function compares the `id` properties of each stage in `sourceStages` and `comparisonStages` to determine if the stage is present in both arrays.\n * If a stage with the same `id` is found in both arrays but the `name` property is different, the stage is considered updated.\n * If a stage with a particular `id` is only found in `comparisonStages`, it is considered created.\n * If a stage with a particular `id` is only found in `sourceStages`, it is considered deleted.\n *\n * @typedef {{id: Number, name: String, workflow: Number}} Stage\n * @typedef {{created: Stage[], updated: Stage[], deleted: Stage[]}} DiffStages\n *\n * The DiffStages object has three properties: `created`, `updated`, and `deleted`.\n * `created` is an array of stages that are in `comparisonStages` but not in `sourceStages`.\n * `updated` is an array of stages that have different names in `comparisonStages` and `sourceStages`.\n * `deleted` is an array of stages that are in `sourceStages` but not in `comparisonStages`.\n *\n * @param {Stage[]} sourceStages\n * @param {Stage[]} comparisonStages\n * @returns { DiffStages }\n */\nfunction getDiffBetweenStages(sourceStages: any, comparisonStages: any) {\n  const result = comparisonStages.reduce(\n    // ...\n\n    (acc: any, stageToCompare: any) => {\n      const srcStage = sourceStages.find((stage: any) => stage.id === stageToCompare.id);\n\n      if (!srcStage) {\n        acc.created.push(stageToCompare);\n      } else if (\n        !isEqual(\n          pick(['name', 'color', 'permissions'], srcStage),\n          pick(['name', 'color', 'permissions'], stageToCompare)\n        )\n      ) {\n        acc.updated.push(stageToCompare);\n      }\n      return acc;\n    },\n    { created: [], updated: [] }\n  );\n\n  result.deleted = sourceStages.filter(\n    (srcStage: any) => !comparisonStages.some((cmpStage: any) => cmpStage.id === srcStage.id)\n  );\n\n  return result;\n}\n\n/**\n * Asserts that at least one stage remains in the workflow after applying deletions and additions.\n *\n * @param {Array} workflowStages - An array of stages in the current workflow.\n * @param {Object} diffStages - An object containing the stages to be deleted and created.\n * @param {Array} diffStages.deleted - An array of stages that are planned to be deleted from the workflow.\n * @param {Array} diffStages.created - An array of stages that are planned to be created in the workflow.\n *\n * @throws {ValidationError} If the number of remaining stages in the workflow after applying deletions and additions is less than 1.\n */\nfunction assertAtLeastOneStageRemain(workflowStages: any, diffStages: any) {\n  const remainingStagesCount =\n    workflowStages.length - diffStages.deleted.length + diffStages.created.length;\n  if (remainingStagesCount < 1) {\n    throw new ValidationError(ERRORS.WORKFLOW_WITHOUT_STAGES);\n  }\n}\n\n/**\n * Find the id of the nearest object in an array that matches a condition.\n * Used for searching for the nearest stage that is not deleted.\n * Starts by searching the elements before the index, then the remaining elements in the array.\n *\n * @param {Array} stages\n * @param {Number} startIndex the index to start searching from\n * @param {Function} condition must evaluate to true for the object to be considered a match\n * @returns {Object} stage\n */\nfunction findNearestMatchingStage(stages: any, startIndex: any, condition: any) {\n  // Start by searching the elements before the startIndex\n  for (let i = startIndex; i >= 0; i -= 1) {\n    if (condition(stages[i])) {\n      return stages[i];\n    }\n  }\n\n  // If no matching element is found before the startIndex,\n  // search the remaining elements in the array\n  const remainingArray = stages.slice(startIndex + 1);\n  const nearestObject = remainingArray.filter(condition)[0];\n  return nearestObject;\n}\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport { prop } from 'lodash/fp';\nimport { mapAsync, errors } from '@strapi/utils';\nimport { getService } from '../../utils';\nimport { STAGE_TRANSITION_UID } from '../../constants/workflows';\n\nconst { ApplicationError } = errors;\nconst validActions = [STAGE_TRANSITION_UID];\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const roleService = getService('role');\n  const permissionService = getService('permission');\n\n  return {\n    async register({ roleId, action, fromStage }: any) {\n      if (!validActions.includes(action)) {\n        throw new ApplicationError(`Invalid action ${action}`);\n      }\n      const permissions = await roleService.addPermissions(roleId, [\n        {\n          action,\n          actionParameters: {\n            from: fromStage,\n          },\n        },\n      ]);\n\n      // TODO: Filter response\n      return permissions;\n    },\n    async registerMany(permissions: any) {\n      return mapAsync(permissions, this.register);\n    },\n    async unregister(permissions: any) {\n      const permissionIds = permissions.map(prop('id'));\n      await permissionService.deleteByIds(permissionIds);\n    },\n    can(action: any, fromStage: any) {\n      const requestState = strapi.requestContext.get()?.state;\n\n      if (!requestState) {\n        return false;\n      }\n\n      // Override permissions for super admin\n      const userRoles = requestState.user?.roles;\n      if (userRoles?.some((role: any) => role.code === 'strapi-super-admin')) {\n        return true;\n      }\n\n      return requestState.userAbility.can({\n        name: action,\n        params: { from: fromStage },\n      });\n    },\n  };\n};\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport { errors } from '@strapi/utils';\nimport { isNil } from 'lodash/fp';\nimport { ENTITY_ASSIGNEE_ATTRIBUTE } from '../../constants/workflows';\nimport { getService } from '../../utils';\n\nconst { ApplicationError } = errors;\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const metrics = getService('review-workflows-metrics', { strapi });\n\n  return {\n    async findEntityAssigneeId(id: any, model: any) {\n      const entity = (await strapi.entityService.findOne(model, id, {\n        populate: [ENTITY_ASSIGNEE_ATTRIBUTE],\n        fields: [],\n      })) as any;\n\n      return entity?.[ENTITY_ASSIGNEE_ATTRIBUTE]?.id ?? null;\n    },\n\n    /**\n     * Update the assignee of an entity\n     */\n    async updateEntityAssignee(id: any, model: any, assigneeId: any) {\n      if (isNil(assigneeId)) {\n        return this.deleteEntityAssignee(id, model);\n      }\n\n      const userExists = await getService('user', { strapi }).exists({ id: assigneeId });\n\n      if (!userExists) {\n        throw new ApplicationError(`Selected user does not exist`);\n      }\n\n      metrics.sendDidEditAssignee(await this.findEntityAssigneeId(id, model), assigneeId);\n\n      return strapi.entityService.update(model, id, {\n        // @ts-expect-error check entity service types\n        data: { [ENTITY_ASSIGNEE_ATTRIBUTE]: assigneeId },\n        populate: [ENTITY_ASSIGNEE_ATTRIBUTE],\n        fields: [],\n      });\n    },\n\n    async deleteEntityAssignee(id: any, model: any) {\n      metrics.sendDidEditAssignee(await this.findEntityAssigneeId(id, model), null);\n\n      return strapi.entityService.update(model, id, {\n        // @ts-expect-error check entity service types\n        data: { [ENTITY_ASSIGNEE_ATTRIBUTE]: null },\n        populate: [ENTITY_ASSIGNEE_ATTRIBUTE],\n        fields: [],\n      });\n    },\n  };\n};\n","export const WORKFLOW_UPDATE_STAGE = 'review-workflows.updateEntryStage';\n\nexport default {\n  WORKFLOW_UPDATE_STAGE,\n};\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport { filter, set, forEach, pipe, map, stubTrue, cond, defaultsDeep } from 'lodash/fp';\nimport { getService } from '../../utils';\nimport { getVisibleContentTypesUID, hasStageAttribute } from '../../utils/review-workflows';\nimport defaultStages from '../../constants/default-stages.json';\nimport defaultWorkflow from '../../constants/default-workflow.json';\nimport {\n  ENTITY_STAGE_ATTRIBUTE,\n  ENTITY_ASSIGNEE_ATTRIBUTE,\n  STAGE_MODEL_UID,\n  MAX_WORKFLOWS,\n  MAX_STAGES_PER_WORKFLOW,\n} from '../../constants/workflows';\n\nimport { persistTables, removePersistedTablesWithSuffix } from '../../utils/persisted-tables';\nimport webhookEvents from '../../constants/webhookEvents';\n\nconst MAX_DB_TABLE_NAME_LEN = 63; // Postgres limit\n// The longest index name that Strapi can create is prefixed with '_strapi_stage_links_inv_fk', so the content type name  should be no longer than this.\nconst MAX_JOIN_TABLE_NAME_SUFFIX =\n  1 /* _ */ + ENTITY_STAGE_ATTRIBUTE.length + '_links_inv_fk'.length;\nconst MAX_CONTENT_TYPE_NAME_LEN = MAX_DB_TABLE_NAME_LEN - MAX_JOIN_TABLE_NAME_SUFFIX;\n\nconst DEFAULT_OPTIONS = {\n  numberOfWorkflows: MAX_WORKFLOWS,\n  stagesPerWorkflow: MAX_STAGES_PER_WORKFLOW,\n};\n\nasync function initDefaultWorkflow({ workflowsService, stagesService }: any) {\n  const wfCount = await workflowsService.count();\n  const stagesCount = await stagesService.count();\n\n  // Check if there is nothing about review-workflow in DB\n  // If any, the feature has already been initialized with a workflow and stages\n  if (wfCount === 0 && stagesCount === 0) {\n    const workflow = {\n      ...defaultWorkflow,\n      stages: defaultStages,\n    };\n\n    await workflowsService.create({ data: workflow });\n  }\n}\n\nfunction extendReviewWorkflowContentTypes({ strapi }: { strapi: Strapi }) {\n  const extendContentType = (contentTypeUID: any) => {\n    const assertContentTypeCompatibility = (contentType: any) =>\n      contentType.collectionName.length <= MAX_CONTENT_TYPE_NAME_LEN;\n    const incompatibleContentTypeAlert = (contentType: any) => {\n      strapi.log.warn(\n        `Review Workflow cannot be activated for the content type with the name '${contentType.info.displayName}' because the name exceeds the maximum length of ${MAX_CONTENT_TYPE_NAME_LEN} characters.`\n      );\n      return contentType;\n    };\n\n    const setRelation = (path: any, target: any) =>\n      set(path, {\n        writable: true,\n        private: false,\n        configurable: false,\n        visible: false,\n        useJoinTable: true, // We want a join table to persist data when downgrading to CE\n        type: 'relation',\n        relation: 'oneToOne',\n        target,\n      });\n\n    const setReviewWorkflowAttributes = pipe([\n      setRelation(`attributes.${ENTITY_STAGE_ATTRIBUTE}`, STAGE_MODEL_UID),\n      setRelation(`attributes.${ENTITY_ASSIGNEE_ATTRIBUTE}`, 'admin::user'),\n    ]);\n\n    const extendContentTypeIfCompatible = cond([\n      [assertContentTypeCompatibility, setReviewWorkflowAttributes],\n      [stubTrue, incompatibleContentTypeAlert],\n    ]);\n    strapi.container.get('content-types').extend(contentTypeUID, extendContentTypeIfCompatible);\n  };\n\n  pipe([\n    getVisibleContentTypesUID,\n    // Iterate over UIDs to extend the content-type\n    forEach(extendContentType),\n  ])(strapi.contentTypes);\n}\n\nfunction persistStagesJoinTables({ strapi }: { strapi: Strapi }) {\n  return async ({ contentTypes }: any) => {\n    const getStageTableToPersist = (contentTypeUID: any) => {\n      // Persist the stage join table\n      const { attributes, tableName } = strapi.db.metadata.get(contentTypeUID) as any;\n      const joinTableName = attributes[ENTITY_STAGE_ATTRIBUTE].joinTable.name;\n      return { name: joinTableName, dependsOn: [{ name: tableName }] };\n    };\n\n    const joinTablesToPersist = pipe([\n      getVisibleContentTypesUID,\n      filter((uid: any) => hasStageAttribute(contentTypes[uid])),\n      map(getStageTableToPersist),\n    ])(contentTypes);\n\n    // TODO: Instead of removing all the tables, we should only remove the ones that are not in the joinTablesToPersist\n    await removePersistedTablesWithSuffix('_strapi_stage_links');\n    await persistTables(joinTablesToPersist);\n  };\n}\n\nconst registerWebhookEvents = async ({ strapi }: { strapi: Strapi }) =>\n  Object.entries(webhookEvents).forEach(([eventKey, event]) =>\n    strapi.webhookStore.addAllowedEvent(eventKey, event)\n  );\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const workflowsService = getService('workflows', { strapi });\n  const stagesService = getService('stages', { strapi });\n  const workflowsValidationService = getService('review-workflows-validation', { strapi });\n\n  return {\n    async bootstrap() {\n      await registerWebhookEvents({ strapi });\n      await initDefaultWorkflow({ workflowsService, stagesService, strapi });\n    },\n    async register({ options } = { options: {} }) {\n      extendReviewWorkflowContentTypes({ strapi });\n      strapi.hook('strapi::content-types.afterSync').register(persistStagesJoinTables({ strapi }));\n\n      const reviewWorkflowsOptions = defaultsDeep(DEFAULT_OPTIONS, options);\n      workflowsValidationService.register(reviewWorkflowsOptions);\n    },\n  };\n};\n","import { Strapi } from '@strapi/types';\nimport { uniq } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\nimport { getService } from '../../utils';\nimport { ERRORS, MAX_WORKFLOWS, MAX_STAGES_PER_WORKFLOW } from '../../constants/workflows';\nimport { clampMaxWorkflows, clampMaxStagesPerWorkflow } from '../../utils/review-workflows';\n\nconst { ValidationError } = errors;\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  return {\n    limits: {\n      numberOfWorkflows: MAX_WORKFLOWS,\n      stagesPerWorkflow: MAX_STAGES_PER_WORKFLOW,\n    },\n    register({ numberOfWorkflows, stagesPerWorkflow }: any) {\n      if (!Object.isFrozen(this.limits)) {\n        this.limits.numberOfWorkflows = clampMaxWorkflows(\n          numberOfWorkflows || this.limits.numberOfWorkflows\n        );\n        this.limits.stagesPerWorkflow = clampMaxStagesPerWorkflow(\n          stagesPerWorkflow || this.limits.stagesPerWorkflow\n        );\n        Object.freeze(this.limits);\n      }\n    },\n    /**\n     * Validates the stages of a workflow.\n     * @param {Array} stages - Array of stages to be validated.\n     * @throws {ValidationError} - If the workflow has no stages or exceeds the limit.\n     */\n    validateWorkflowStages(stages: any) {\n      if (!stages || stages.length === 0) {\n        throw new ValidationError(ERRORS.WORKFLOW_WITHOUT_STAGES);\n      }\n      if (stages.length > this.limits.stagesPerWorkflow) {\n        throw new ValidationError(ERRORS.STAGES_LIMIT);\n      }\n      // Validate stage names are not duplicated\n      const stageNames = stages.map((stage: any) => stage.name);\n      if (uniq(stageNames).length !== stageNames.length) {\n        throw new ValidationError(ERRORS.DUPLICATED_STAGE_NAME);\n      }\n    },\n\n    async validateWorkflowCountStages(workflowId: any, countAddedStages = 0) {\n      const stagesService = getService('stages', { strapi });\n      const countWorkflowStages = await stagesService.count({ workflowId });\n\n      if (countWorkflowStages + countAddedStages > this.limits.stagesPerWorkflow) {\n        throw new ValidationError(ERRORS.STAGES_LIMIT);\n      }\n    },\n\n    /**\n     * Validates the count of existing and added workflows.\n     * @param {number} [countAddedWorkflows=0] - The count of workflows to be added.\n     * @throws {ValidationError} - If the total count of workflows exceeds the limit.\n     * @returns {Promise<void>} - A Promise that resolves when the validation is completed.\n     */\n    async validateWorkflowCount(countAddedWorkflows = 0) {\n      const workflowsService = getService('workflows', { strapi });\n      const countWorkflows = await workflowsService.count();\n      if (countWorkflows + countAddedWorkflows > this.limits.numberOfWorkflows) {\n        throw new ValidationError(ERRORS.WORKFLOWS_LIMIT);\n      }\n    },\n  };\n};\n","import '@strapi/types';\nimport { isNil } from 'lodash/fp';\nimport { ENTITY_STAGE_ATTRIBUTE } from '../../constants/workflows';\nimport { WORKFLOW_UPDATE_STAGE } from '../../constants/webhookEvents';\nimport { getService } from '../../utils';\n\n/**\n * Assigns the entity data to the default workflow stage if no stage is present in the data\n * @param {Object} data\n * @returns\n */\nconst getDataWithStage = async (workflow: any, data: any) => {\n  if (!isNil(ENTITY_STAGE_ATTRIBUTE)) {\n    return { ...data, [ENTITY_STAGE_ATTRIBUTE]: workflow.stages[0].id };\n  }\n  return data;\n};\n\n/**\n * Get the stage information of an entity\n * @param {String} uid\n * @param {Number} id\n * @returns {Object}\n */\nconst getEntityStage = async (uid: any, id: any) => {\n  const entity = await strapi.entityService.findOne(uid, id, {\n    populate: {\n      [ENTITY_STAGE_ATTRIBUTE]: {\n        populate: {\n          workflow: true,\n        },\n      },\n    },\n  });\n  return entity?.[ENTITY_STAGE_ATTRIBUTE] ?? {};\n};\n\n/**\n * Decorates the entity service with RW business logic\n * @param {object} service - entity service\n */\nconst decorator = (service: any) => ({\n  async create(uid: any, opts: any = {}) {\n    const workflow = await getService('workflows').getAssignedWorkflow(uid, {\n      populate: 'stages',\n    });\n\n    if (!workflow) {\n      return service.create.call(this, uid, opts);\n    }\n\n    const data = await getDataWithStage(workflow, opts.data);\n    return service.create.call(this, uid, { ...opts, data });\n  },\n  async update(uid: any, entityId: any, opts: any = {}) {\n    // Prevents the stage from being set to null\n    const data = { ...opts.data };\n    if (isNil(data[ENTITY_STAGE_ATTRIBUTE])) {\n      delete data[ENTITY_STAGE_ATTRIBUTE];\n      return service.update.call(this, uid, entityId, { ...opts, data });\n    }\n\n    const previousStage = (await getEntityStage(uid, entityId)) as any;\n\n    const updatedEntity = await service.update.call(this, uid, entityId, { ...opts, data });\n    const updatedStage = updatedEntity[ENTITY_STAGE_ATTRIBUTE];\n\n    // Stage might be null if field is not populated\n    if (updatedStage && previousStage?.id && previousStage.id !== updatedStage.id) {\n      const model = strapi.getModel(uid);\n\n      strapi.eventHub.emit(WORKFLOW_UPDATE_STAGE, {\n        model: model.modelName,\n        uid: model.uid,\n        entity: {\n          id: entityId,\n        },\n        workflow: {\n          id: previousStage.workflow.id,\n          stages: {\n            from: {\n              id: previousStage.id,\n              name: previousStage.name,\n            },\n            to: {\n              id: updatedStage.id,\n              name: updatedStage.name,\n            },\n          },\n        },\n      });\n    }\n\n    return updatedEntity;\n  },\n});\n\nexport default () => ({\n  decorator,\n});\n","import '@strapi/types';\n\nexport const sendDidCreateStage = async () => {\n  strapi.telemetry.send('didCreateStage', {});\n};\n\nexport const sendDidEditStage = async () => {\n  strapi.telemetry.send('didEditStage', {});\n};\n\nexport const sendDidDeleteStage = async () => {\n  strapi.telemetry.send('didDeleteStage', {});\n};\n\nexport const sendDidChangeEntryStage = async () => {\n  strapi.telemetry.send('didChangeEntryStage', {});\n};\n\nexport const sendDidCreateWorkflow = async () => {\n  strapi.telemetry.send('didCreateWorkflow', {});\n};\n\nexport const sendDidEditWorkflow = async () => {\n  strapi.telemetry.send('didEditWorkflow', {});\n};\n\nexport const sendDidEditAssignee = async (fromId: any, toId: any) => {\n  strapi.telemetry.send('didEditAssignee', { from: fromId, to: toId });\n};\n\nexport const sendDidSendReviewWorkflowPropertiesOnceAWeek = async (\n  numberOfActiveWorkflows: number,\n  avgStagesCount: number,\n  maxStagesCount: number,\n  activatedContentTypes: number\n) => {\n  strapi.telemetry.send('didSendReviewWorkflowPropertiesOnceAWeek', {\n    groupProperties: {\n      numberOfActiveWorkflows,\n      avgStagesCount,\n      maxStagesCount,\n      activatedContentTypes,\n    },\n  });\n};\n\nexport default {\n  sendDidCreateStage,\n  sendDidEditStage,\n  sendDidDeleteStage,\n  sendDidChangeEntryStage,\n  sendDidCreateWorkflow,\n  sendDidEditWorkflow,\n  sendDidSendReviewWorkflowPropertiesOnceAWeek,\n  sendDidEditAssignee,\n};\n","import { LoadedStrapi as Strapi } from '@strapi/types';\nimport { flow, map, sum, size, mean, max, defaultTo } from 'lodash/fp';\nimport { add } from 'date-fns';\nimport { getService } from '../../../utils';\n\nconst ONE_WEEK = 7 * 24 * 60 * 60 * 1000;\n\nconst getWeeklyCronScheduleAt = (date: Date) =>\n  `${date.getSeconds()} ${date.getMinutes()} ${date.getHours()} * * ${date.getDay()}`;\n\nexport default ({ strapi }: { strapi: Strapi }) => {\n  const metrics = getService('review-workflows-metrics', { strapi });\n  const workflowsService = getService('workflows', { strapi });\n\n  const getMetricsStoreValue = async () => {\n    const value = await strapi.store.get({ type: 'plugin', name: 'ee', key: 'metrics' });\n    return defaultTo({}, value);\n  };\n\n  const setMetricsStoreValue = (value: unknown) =>\n    strapi.store.set({ type: 'plugin', name: 'ee', key: 'metrics', value });\n\n  return {\n    async computeMetrics() {\n      // There will never be more than 200 workflow, so we can safely fetch them all\n      const workflows = await workflowsService.find({ populate: 'stages' });\n\n      const stagesCount = flow(\n        map('stages'), // Number of stages per workflow\n        map(size)\n      )(workflows);\n\n      const contentTypesCount = flow(\n        map('contentTypes'), // Number of content types per workflow\n        map(size)\n      )(workflows);\n\n      return {\n        numberOfActiveWorkflows: size(workflows),\n        avgStagesCount: mean(stagesCount),\n        maxStagesCount: max(stagesCount),\n        activatedContentTypes: sum(contentTypesCount),\n      };\n    },\n\n    async sendMetrics() {\n      const computedMetrics = await this.computeMetrics();\n      metrics.sendDidSendReviewWorkflowPropertiesOnceAWeek(computedMetrics);\n\n      const metricsInfoStored = await getMetricsStoreValue();\n      // @ts-expect-error metricsInfoStored can use spread\n      await setMetricsStoreValue({ ...metricsInfoStored, lastWeeklyUpdate: new Date().getTime() });\n    },\n\n    async ensureWeeklyStoredCronSchedule() {\n      const metricsInfoStored: any = await getMetricsStoreValue();\n      const { weeklySchedule: currentSchedule, lastWeeklyUpdate } = metricsInfoStored;\n\n      const now = new Date();\n      let weeklySchedule = currentSchedule;\n\n      if (!currentSchedule || !lastWeeklyUpdate || lastWeeklyUpdate + ONE_WEEK < now.getTime()) {\n        weeklySchedule = getWeeklyCronScheduleAt(add(now, { seconds: 10 }));\n        await setMetricsStoreValue({ ...metricsInfoStored, weeklySchedule });\n      }\n\n      return weeklySchedule;\n    },\n\n    async registerCron() {\n      const weeklySchedule = await this.ensureWeeklyStoredCronSchedule();\n\n      strapi.cron.add({ [weeklySchedule]: this.sendMetrics.bind(this) });\n    },\n  };\n};\n","import auth from './auth';\nimport passport from './passport';\nimport role from './role';\nimport user from './user';\nimport metrics from './metrics';\nimport seatEnforcement from './seat-enforcement';\nimport workflows from './review-workflows/workflows';\nimport stages from './review-workflows/stages';\nimport stagePermissions from './review-workflows/stage-permissions';\nimport assignees from './review-workflows/assignees';\nimport reviewWorkflows from './review-workflows/review-workflows';\nimport reviewWorkflowsValidation from './review-workflows/validation';\nimport reviewWorkflowsDecorator from './review-workflows/entity-service-decorator';\nimport reviewWorkflowsMetrics from './review-workflows/metrics';\nimport reviewWorkflowsWeeklyMetrics from './review-workflows/metrics/weekly-metrics';\n\nexport default {\n  auth,\n  passport,\n  role,\n  user,\n  metrics,\n  'seat-enforcement': seatEnforcement,\n  workflows,\n  stages,\n  'stage-permissions': stagePermissions,\n  assignees,\n  'review-workflows': reviewWorkflows,\n  'review-workflows-validation': reviewWorkflowsValidation,\n  'review-workflows-decorator': reviewWorkflowsDecorator,\n  'review-workflows-metrics': reviewWorkflowsMetrics,\n  'review-workflows-weekly-metrics': reviewWorkflowsWeeklyMetrics,\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\n\nconst providerOptionsUpdateSchema = yup.object().shape({\n  autoRegister: yup.boolean().required(),\n  defaultRole: yup\n    .strapiID()\n    .when('autoRegister', (value, initSchema) => {\n      return value ? initSchema.required() : initSchema.nullable();\n    })\n    .test('is-valid-role', 'You must submit a valid default role', (roleId) => {\n      if (roleId === null) {\n        return true;\n      }\n      return strapi.admin.services.role.exists({ id: roleId });\n    }),\n  ssoLockedRoles: yup\n    .array()\n    .nullable()\n    .of(\n      yup\n        .strapiID()\n        .test(\n          'is-valid-role',\n          'You must submit a valid role for the SSO Locked roles',\n          (roleId) => {\n            return strapi.admin.services.role.exists({ id: roleId });\n          }\n        )\n    ),\n});\n\nexport const validateProviderOptionsUpdate = validateYupSchema(providerOptionsUpdateSchema);\n\nexport default {\n  validateProviderOptionsUpdate,\n};\n","export const PROVIDER_REDIRECT_BASE = '/auth/login';\nexport const PROVIDER_REDIRECT_SUCCESS = `${PROVIDER_REDIRECT_BASE}/success`;\nexport const PROVIDER_REDIRECT_ERROR = `${PROVIDER_REDIRECT_BASE}/error`;\n\nexport default {\n  PROVIDER_REDIRECT_BASE,\n  PROVIDER_REDIRECT_SUCCESS,\n  PROVIDER_REDIRECT_ERROR,\n};\n","import { mapValues } from 'lodash/fp';\nimport { PROVIDER_REDIRECT_ERROR, PROVIDER_REDIRECT_SUCCESS } from './constants';\n\nconst PROVIDER_URLS_MAP = {\n  success: PROVIDER_REDIRECT_SUCCESS,\n  error: PROVIDER_REDIRECT_ERROR,\n};\n\nexport const getAdminStore = async () => strapi.store({ type: 'core', name: 'admin' });\n\nexport const getPrefixedRedirectUrls = () => {\n  const { url: adminUrl } = strapi.config.get('admin') as any;\n  const prefixUrl = (url: string) => `${adminUrl || '/admin'}${url}`;\n\n  return mapValues(prefixUrl, PROVIDER_URLS_MAP);\n};\n\nexport default {\n  getAdminStore,\n  getPrefixedRedirectUrls,\n};\n","import { Common } from '@strapi/types';\nimport passport from 'koa-passport';\nimport { getService } from '../../utils';\nimport utils from './utils';\n\nconst defaultConnectionError = () => new Error('Invalid connection payload');\n\nexport const authenticate: Common.MiddlewareHandler = async (ctx, next) => {\n  const {\n    params: { provider },\n  } = ctx;\n  const redirectUrls = utils.getPrefixedRedirectUrls();\n\n  // @ts-expect-error - can not use null to authenticate\n  return passport.authenticate(provider, null, async (error, profile) => {\n    if (error || !profile || !profile.email) {\n      if (error) {\n        strapi.log.error(error);\n      }\n\n      strapi.eventHub.emit('admin.auth.error', {\n        error: error || defaultConnectionError(),\n        provider,\n      });\n\n      return ctx.redirect(redirectUrls.error);\n    }\n\n    const user = await getService('user').findOneByEmail(profile.email);\n    const scenario = user ? existingUserScenario : nonExistingUserScenario;\n\n    return scenario(ctx, next)(user || profile, provider);\n  })(ctx, next);\n};\n\nconst existingUserScenario: Common.MiddlewareHandler =\n  (ctx, next) => async (user: any, provider: any) => {\n    const redirectUrls = utils.getPrefixedRedirectUrls();\n\n    if (!user.isActive) {\n      strapi.eventHub.emit('admin.auth.error', {\n        error: new Error(`Deactivated user tried to login (${user.id})`),\n        provider,\n      });\n      return ctx.redirect(redirectUrls.error);\n    }\n\n    ctx.state.user = user;\n    return next();\n  };\n\nconst nonExistingUserScenario: Common.MiddlewareHandler =\n  (ctx, next) => async (profile: any, provider: any) => {\n    const { email, firstname, lastname, username } = profile;\n    const redirectUrls = utils.getPrefixedRedirectUrls();\n    const adminStore = await utils.getAdminStore();\n    const { providers } = (await adminStore.get({ key: 'auth' })) as any;\n\n    // We need at least the username or the firstname/lastname combination to register a new user\n    const isMissingRegisterFields = !username && (!firstname || !lastname);\n\n    if (!providers.autoRegister || !providers.defaultRole || isMissingRegisterFields) {\n      strapi.eventHub.emit('admin.auth.error', { error: defaultConnectionError(), provider });\n      return ctx.redirect(redirectUrls.error);\n    }\n\n    const defaultRole = await getService('role').findOne({ id: providers.defaultRole });\n\n    // If the default role has been misconfigured, redirect with an error\n    if (!defaultRole) {\n      strapi.eventHub.emit('admin.auth.error', { error: defaultConnectionError(), provider });\n      return ctx.redirect(redirectUrls.error);\n    }\n\n    // Register a new user with the information given by the provider and login with it\n    ctx.state.user = await getService('user').create({\n      email,\n      username,\n      firstname,\n      lastname,\n      roles: [defaultRole.id],\n      isActive: true,\n      registrationToken: null,\n    });\n\n    strapi.eventHub.emit('admin.auth.autoRegistration', {\n      user: ctx.state.user,\n      provider,\n    });\n\n    return next();\n  };\n\nexport const redirectWithAuth: Common.MiddlewareHandler = (ctx) => {\n  const {\n    params: { provider },\n  } = ctx;\n  const redirectUrls = utils.getPrefixedRedirectUrls();\n  const domain: string | undefined = strapi.config.get('admin.auth.domain');\n  const { user } = ctx.state;\n\n  const jwt = getService('token').createJwtToken(user);\n\n  const isProduction = strapi.config.get('environment') === 'production';\n\n  const cookiesOptions = { httpOnly: false, secure: isProduction, overwrite: true, domain };\n\n  const sanitizedUser = getService('user').sanitizeUser(user);\n  strapi.eventHub.emit('admin.auth.success', { user: sanitizedUser, provider });\n\n  ctx.cookies.set('jwtToken', jwt, cookiesOptions);\n  ctx.redirect(redirectUrls.success);\n};\n\nexport default {\n  authenticate,\n  redirectWithAuth,\n};\n","import type { Context, Next } from 'koa';\n\nimport { pick } from 'lodash/fp';\nimport compose from 'koa-compose';\nimport { errors } from '@strapi/utils';\nimport { validateProviderOptionsUpdate } from '../validation/authentication';\nimport { middlewares, utils } from './authentication-utils';\n\nconst toProviderDTO = pick(['uid', 'displayName', 'icon']);\nconst toProviderLoginOptionsDTO = pick(['autoRegister', 'defaultRole', 'ssoLockedRoles']);\n\nconst { ValidationError } = errors;\n\nconst providerAuthenticationFlow = compose([\n  middlewares.authenticate,\n  middlewares.redirectWithAuth,\n]);\n\nexport default {\n  async getProviders(ctx: Context) {\n    const { providerRegistry } = strapi.admin.services.passport;\n\n    ctx.body = providerRegistry.getAll().map(toProviderDTO);\n  },\n\n  async getProviderLoginOptions(ctx: Context) {\n    const adminStore = await utils.getAdminStore();\n    const { providers: providersOptions } = (await adminStore.get({ key: 'auth' })) as any;\n\n    ctx.body = {\n      data: toProviderLoginOptionsDTO(providersOptions),\n    };\n  },\n\n  async updateProviderLoginOptions(ctx: Context) {\n    const {\n      request: { body },\n    } = ctx;\n\n    await validateProviderOptionsUpdate(body);\n\n    const adminStore = await utils.getAdminStore();\n    const currentAuthOptions = (await adminStore.get({ key: 'auth' })) as any;\n    const newAuthOptions = { ...currentAuthOptions, providers: body };\n    await adminStore.set({ key: 'auth', value: newAuthOptions });\n\n    strapi.telemetry.send('didUpdateSSOSettings');\n\n    ctx.body = {\n      data: toProviderLoginOptionsDTO(newAuthOptions.providers),\n    };\n  },\n\n  providerLogin(ctx: Context, next: Next) {\n    const {\n      params: { provider: providerName },\n    } = ctx;\n\n    const { providerRegistry } = strapi.admin.services.passport;\n\n    if (!providerRegistry.has(providerName)) {\n      throw new ValidationError(`Invalid provider supplied: ${providerName}`);\n    }\n\n    return providerAuthenticationFlow(ctx, next);\n  },\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\nimport EE from '@strapi/strapi/dist/utils/ee';\n\nconst roleCreateSchema = yup\n  .object()\n  .shape({\n    name: yup.string().min(1).required(),\n    description: yup.string().nullable(),\n  })\n  .noUnknown();\n\nconst rolesDeleteSchema = yup\n  .object()\n  .shape({\n    ids: yup\n      .array()\n      .of(yup.strapiID())\n      .min(1)\n      .required()\n      .test(\n        'roles-deletion-checks',\n        'Roles deletion checks have failed',\n        async function rolesDeletionChecks(ids) {\n          try {\n            await strapi.admin.services.role.checkRolesIdForDeletion(ids);\n\n            if (EE.features.isEnabled('sso')) {\n              await strapi.admin.services.role.ssoCheckRolesIdForDeletion(ids);\n            }\n          } catch (e: any) {\n            return this.createError({ path: 'ids', message: e.message });\n          }\n\n          return true;\n        }\n      ),\n  })\n  .noUnknown();\n\nconst roleDeleteSchema = yup\n  .strapiID()\n  .required()\n  .test(\n    'no-admin-single-delete',\n    'Role deletion checks have failed',\n    async function noAdminSingleDelete(id) {\n      try {\n        await strapi.admin.services.role.checkRolesIdForDeletion([id]);\n\n        if (EE.features.isEnabled('sso')) {\n          await strapi.admin.services.role.ssoCheckRolesIdForDeletion([id]);\n        }\n      } catch (e: any) {\n        return this.createError({ path: 'id', message: e.message });\n      }\n\n      return true;\n    }\n  );\n\nexport const validateRoleCreateInput = validateYupSchema(roleCreateSchema);\nexport const validateRolesDeleteInput = validateYupSchema(rolesDeleteSchema);\nexport const validateRoleDeleteInput = validateYupSchema(roleDeleteSchema);\n\nexport default {\n  validateRoleCreateInput,\n  validateRolesDeleteInput,\n  validateRoleDeleteInput,\n};\n","import type { Context } from 'koa';\n\nimport {\n  validateRoleCreateInput,\n  validateRoleDeleteInput,\n  validateRolesDeleteInput,\n} from '../validation/role';\nimport { getService } from '../utils';\n\nexport default {\n  /**\n   * Create a new role\n   * @param {KoaContext} ctx - koa context\n   */\n  async create(ctx: Context) {\n    await validateRoleCreateInput(ctx.request.body);\n\n    const roleService = getService('role');\n\n    const role = await roleService.create(ctx.request.body);\n    const sanitizedRole = roleService.sanitizeRole(role);\n\n    ctx.created({ data: sanitizedRole });\n  },\n\n  /**\n   * Delete a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteOne(ctx: Context) {\n    const { id } = ctx.params;\n\n    await validateRoleDeleteInput(id);\n\n    const roleService = getService('role');\n\n    const roles = await roleService.deleteByIds([id]);\n\n    const sanitizedRole = roles.map((role: unknown) => roleService.sanitizeRole(role))[0] || null;\n\n    return ctx.deleted({\n      data: sanitizedRole,\n    });\n  },\n\n  /**\n   * delete several roles\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteMany(ctx: Context) {\n    const { body } = ctx.request;\n\n    await validateRolesDeleteInput(body);\n\n    const roleService = getService('role');\n\n    const roles = await roleService.deleteByIds(body.ids);\n    const sanitizedRoles = roles.map(roleService.sanitizeRole);\n\n    return ctx.deleted({\n      data: sanitizedRoles,\n    });\n  },\n};\n","import { curry, pipe, merge, set, pick, omit, includes, isArray, prop } from 'lodash/fp';\nimport { Utils } from '@strapi/types';\n\nexport type Action = {\n  actionId: string; // The unique identifier of the action\n  section: string; // The section linked to the action - These can be 'contentTypes' | 'plugins' | 'settings' | 'internal'\n  displayName: string; // The human readable name of an action\n  category: string; // The main category of an action\n  subCategory?: string; // The secondary category of an action (only for settings and plugins section)\n  pluginName?: string; // The plugin which provide the action\n  subjects?: string[]; // A list of subjects on which the action can be applied\n  options: {\n    // The options of an action\n    applyToProperties: string[] | null; // The list of properties that can be associated with an action\n  };\n};\n\n/**\n * Set of attributes used to create a new {@link Action} object\n * @typedef {Action, { uid: string }} CreateActionPayload\n */\nexport type CreateActionPayload = Utils.Object.PartialBy<\n  // Action Id is computed from the uid value\n  Omit<Action, 'actionId'>,\n  // Options is filled with default values\n  'options'\n> & {\n  uid: string;\n};\n\n/**\n * Return the default attributes of a new {@link Action}\n * @return Partial<Action>\n */\nconst getDefaultActionAttributes = (): Partial<Action> => ({\n  options: {\n    applyToProperties: null,\n  },\n});\n\n/**\n * Get the list of all the valid attributes of an {@link Action}\n */\nconst actionFields = [\n  'section',\n  'displayName',\n  'category',\n  'subCategory',\n  'pluginName',\n  'subjects',\n  'options',\n  'actionId',\n] as const;\n\n/**\n * Remove unwanted attributes from an {@link Action}\n */\nconst sanitizeActionAttributes = pick(actionFields) as (\n  action: Action | CreateActionPayload\n) => Action;\n\n/**\n * Create and return an identifier for an {@link CreateActionPayload}.\n * The format is based on the action's source ({@link CreateActionPayload.pluginName} or 'application') and {@link CreateActionPayload.uid}.\n * @param {CreateActionPayload} attributes\n * @return {string}\n */\n// TODO: TS - Use Common.UID\nconst computeActionId = (attributes: CreateActionPayload): string => {\n  const { pluginName, uid } = attributes;\n\n  if (!pluginName) {\n    return `api::${uid}`;\n  }\n\n  if (pluginName === 'admin') {\n    return `admin::${uid}`;\n  }\n\n  return `plugin::${pluginName}.${uid}`;\n};\n\n/**\n * Assign an actionId attribute to an {@link CreateActionPayload} object\n */\nconst assignActionId = (attrs: CreateActionPayload) =>\n  set('actionId', computeActionId(attrs), attrs);\n\n/**\n * Transform an action by adding or removing the {@link Action.subCategory} attribute\n * @param {Action} action - The action to process\n * @return {Action}\n */\nconst assignOrOmitSubCategory = (action: Action): Action => {\n  const shouldHaveSubCategory = ['settings', 'plugins'].includes(action.section);\n\n  return shouldHaveSubCategory\n    ? set('subCategory', action.subCategory || 'general', action)\n    : omit('subCategory', action);\n};\n\n/**\n * Check if a property can be applied to an {@link Action}\n */\nconst appliesToProperty = curry((property: string, action: Action): boolean => {\n  return pipe(prop('options.applyToProperties'), includes(property))(action);\n});\n\n/**\n * Check if an action applies to a subject\n */\nconst appliesToSubject = curry((subject: string, action: Action): boolean => {\n  return isArray(action.subjects) && includes(subject, action.subjects);\n});\n\n/**\n * Transform the given attributes into a domain representation of an Action\n */\nconst create: (payload: CreateActionPayload) => Action = pipe(\n  // Create and assign an action identifier to the action\n  // (need to be done before the sanitizeActionAttributes since we need the uid here)\n  assignActionId,\n  // Add or remove the sub category field based on the pluginName attribute\n  assignOrOmitSubCategory,\n  // Remove unwanted attributes from the payload\n  sanitizeActionAttributes,\n  // Complete the action creation by adding default values for some attributes\n  merge(getDefaultActionAttributes())\n);\n\nexport default {\n  actionFields,\n  appliesToProperty,\n  appliesToSubject,\n  assignActionId,\n  assignOrOmitSubCategory,\n  create,\n  computeActionId,\n  getDefaultActionAttributes,\n  sanitizeActionAttributes,\n};\n","import _ from 'lodash';\n\nconst checkFieldsAreCorrectlyNested = (fields: unknown) => {\n  if (_.isNil(fields)) {\n    // Only check if the fields exist\n    return true;\n  }\n  if (!Array.isArray(fields)) {\n    return false;\n  }\n\n  let failed = false;\n  for (let indexA = 0; indexA < fields.length; indexA += 1) {\n    failed = fields\n      .slice(indexA + 1)\n      .some(\n        (fieldB) =>\n          fieldB.startsWith(`${fields[indexA]}.`) || fields[indexA].startsWith(`${fieldB}.`)\n      );\n    if (failed) break;\n  }\n\n  return !failed;\n};\n\nexport default checkFieldsAreCorrectlyNested;\n","import _ from 'lodash';\n\nconst checkFieldsDontHaveDuplicates = (fields: unknown) => {\n  if (_.isNil(fields)) {\n    // Only check if the fields exist\n    return true;\n  }\n  if (!Array.isArray(fields)) {\n    return false;\n  }\n\n  return _.uniq(fields).length === fields.length;\n};\n\nexport default checkFieldsDontHaveDuplicates;\n","import { yup } from '@strapi/utils';\nimport _ from 'lodash';\nimport { isEmpty, has, isNil, isArray } from 'lodash/fp';\nimport { getService } from '../utils';\nimport actionDomain, { type Action } from '../domain/action';\nimport { checkFieldsAreCorrectlyNested, checkFieldsDontHaveDuplicates } from './common-functions';\nimport actions from '../domain/action/index';\n\nconst { actionFields } = actions;\n\nconst getActionFromProvider = (actionId: string) => {\n  return getService('permission').actionProvider.get(actionId);\n};\n\nexport const email = yup.string().email().lowercase();\n\nexport const firstname = yup.string().trim().min(1);\n\nexport const lastname = yup.string();\n\nexport const username = yup.string().min(1);\n\nexport const password = yup\n  .string()\n  .min(8)\n  .matches(/[a-z]/, '${path} must contain at least one lowercase character')\n  .matches(/[A-Z]/, '${path} must contain at least one uppercase character')\n  .matches(/\\d/, '${path} must contain at least one number');\n\nexport const roles = yup.array(yup.strapiID()).min(1);\n\nconst isAPluginName = yup\n  .string()\n  .test('is-a-plugin-name', 'is not a plugin name', function (value) {\n    return [undefined, 'admin', ...Object.keys(strapi.plugins)].includes(value)\n      ? true\n      : this.createError({ path: this.path, message: `${this.path} is not an existing plugin` });\n  });\n\nexport const arrayOfConditionNames = yup\n  .array()\n  .of(yup.string())\n  .test('is-an-array-of-conditions', 'is not a plugin name', function (value) {\n    const ids = strapi.admin.services.permission.conditionProvider.keys();\n    return _.isUndefined(value) || _.difference(value, ids).length === 0\n      ? true\n      : this.createError({ path: this.path, message: `contains conditions that don't exist` });\n  });\n\nexport const permissionsAreEquals = (a: any, b: any) =>\n  a.action === b.action && (a.subject === b.subject || (_.isNil(a.subject) && _.isNil(b.subject)));\n\nconst checkNoDuplicatedPermissions = (permissions: unknown) =>\n  !Array.isArray(permissions) ||\n  permissions.every((permA, i) =>\n    permissions.slice(i + 1).every((permB) => !permissionsAreEquals(permA, permB))\n  );\n\nconst checkNilFields = (action: Action) =>\n  function (fields: typeof actionFields) {\n    // If the parent has no action field, then we ignore this test\n    if (isNil(action)) {\n      return true;\n    }\n\n    return actionDomain.appliesToProperty('fields', action) || isNil(fields);\n  };\n\nconst fieldsPropertyValidation = (action: Action) =>\n  yup\n    .array()\n    .of(yup.string())\n    .nullable()\n    .test(\n      'field-nested',\n      'Fields format are incorrect (bad nesting).',\n      checkFieldsAreCorrectlyNested\n    )\n    .test(\n      'field-nested',\n      'Fields format are incorrect (duplicates).',\n      checkFieldsDontHaveDuplicates\n    )\n    .test(\n      'fields-restriction',\n      'The permission at ${path} must have fields set to null or undefined',\n      // @ts-expect-error yup types\n      checkNilFields(action)\n    );\n\nexport const permission = yup\n  .object()\n  .shape({\n    action: yup\n      .string()\n      .required()\n      .test('action-validity', 'action is not an existing permission action', function (actionId) {\n        // If the action field is Nil, ignore the test and let the required check handle the error\n        if (isNil(actionId)) {\n          return true;\n        }\n\n        return !!getActionFromProvider(actionId);\n      }),\n    actionParameters: yup.object().nullable(),\n    subject: yup\n      .string()\n      .nullable()\n      .test('subject-validity', 'Invalid subject submitted', function (subject) {\n        // @ts-expect-error yup types\n        const action = getActionFromProvider(this.options.parent.action);\n\n        if (!action) {\n          return true;\n        }\n\n        if (isNil(action.subjects)) {\n          return isNil(subject);\n        }\n\n        if (isArray(action.subjects)) {\n          return action.subjects.includes(subject);\n        }\n\n        return false;\n      }),\n    properties: yup\n      .object()\n      .test('properties-structure', 'Invalid property set at ${path}', function (properties) {\n        // @ts-expect-error yup types\n        const action = getActionFromProvider(this.options.parent.action) as any;\n        const hasNoProperties = isEmpty(properties) || isNil(properties);\n\n        if (!has('options.applyToProperties', action)) {\n          return hasNoProperties;\n        }\n\n        if (hasNoProperties) {\n          return true;\n        }\n\n        const { applyToProperties } = action.options;\n\n        if (!isArray(applyToProperties)) {\n          return false;\n        }\n\n        return Object.keys(properties).every((property) => applyToProperties.includes(property));\n      })\n      .test(\n        'fields-property',\n        'Invalid fields property at ${path}',\n        async function (properties = {}) {\n          // @ts-expect-error yup types\n          const action = getActionFromProvider(this.options.parent.action) as any;\n\n          if (!action || !properties) {\n            return true;\n          }\n\n          if (!actionDomain.appliesToProperty('fields', action)) {\n            return true;\n          }\n\n          try {\n            await fieldsPropertyValidation(action).validate(properties.fields, {\n              strict: true,\n              abortEarly: false,\n            });\n            return true;\n          } catch (e: any) {\n            // Propagate fieldsPropertyValidation error with updated path\n            throw this.createError({\n              message: e.message,\n              path: `${this.path}.fields`,\n            });\n          }\n        }\n      ),\n    conditions: yup.array().of(yup.string()),\n  })\n  .noUnknown();\n\nexport const updatePermissions = yup\n  .object()\n  .shape({\n    permissions: yup\n      .array()\n      .required()\n      .of(permission)\n      .test(\n        'duplicated-permissions',\n        'Some permissions are duplicated (same action and subject)',\n        checkNoDuplicatedPermissions\n      ),\n  })\n  .required()\n  .noUnknown();\n\nexport default {\n  email,\n  firstname,\n  lastname,\n  username,\n  password,\n  roles,\n  isAPluginName,\n  arrayOfConditionNames,\n  permission,\n  updatePermissions,\n};\n","import { isUndefined } from 'lodash/fp';\nimport { yup, validateYupSchema } from '@strapi/utils';\nimport validators from './common-validators';\n\nconst userCreationSchema = yup\n  .object()\n  .shape({\n    email: validators.email.required(),\n    firstname: validators.firstname.required(),\n    lastname: validators.lastname,\n    roles: validators.roles.min(1),\n    preferedLanguage: yup.string().nullable(),\n  })\n  .noUnknown();\n\nconst profileUpdateSchema = yup\n  .object()\n  .shape({\n    email: validators.email.notNull(),\n    firstname: validators.firstname.notNull(),\n    lastname: validators.lastname.nullable(),\n    username: validators.username.nullable(),\n    password: validators.password.notNull(),\n    currentPassword: yup\n      .string()\n      .when('password', (password: string, schema: any) =>\n        !isUndefined(password) ? schema.required() : schema\n      )\n      .notNull(),\n    preferedLanguage: yup.string().nullable(),\n  })\n  .noUnknown();\n\nconst userUpdateSchema = yup\n  .object()\n  .shape({\n    email: validators.email.notNull(),\n    firstname: validators.firstname.notNull(),\n    lastname: validators.lastname.nullable(),\n    username: validators.username.nullable(),\n    password: validators.password.notNull(),\n    isActive: yup.bool().notNull(),\n    roles: validators.roles.min(1).notNull(),\n  })\n  .noUnknown();\n\nconst usersDeleteSchema = yup\n  .object()\n  .shape({\n    ids: yup.array().of(yup.strapiID()).min(1).required(),\n  })\n  .noUnknown();\n\nexport const validateUserCreationInput = validateYupSchema(userCreationSchema);\nexport const validateProfileUpdateInput = validateYupSchema(profileUpdateSchema);\nexport const validateUserUpdateInput = validateYupSchema(userUpdateSchema);\nexport const validateUsersDeleteInput = validateYupSchema(usersDeleteSchema);\nexport const schemas = {\n  userCreationSchema,\n  usersDeleteSchema,\n  userUpdateSchema,\n};\n\nexport default {\n  validateUserCreationInput,\n  validateProfileUpdateInput,\n  validateUserUpdateInput,\n  validateUsersDeleteInput,\n  schemas,\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\nimport EE from '@strapi/strapi/dist/utils/ee';\nimport { schemas } from '../../../../server/src/validation/user';\n\nconst ssoUserCreationInputExtension = yup\n  .object()\n  .shape({\n    useSSORegistration: yup.boolean(),\n  })\n  .noUnknown();\n\nexport const validateUserCreationInput = (data: any) => {\n  let schema = schemas.userCreationSchema;\n\n  if (EE.features.isEnabled('sso')) {\n    schema = schema.concat(ssoUserCreationInputExtension);\n  }\n\n  return validateYupSchema(schema)(data);\n};\n\nexport default {\n  validateUserCreationInput,\n};\n","import type { Context } from 'koa';\n\nimport ee from '@strapi/strapi/dist/utils/ee';\nimport _ from 'lodash';\nimport { pick, isNil } from 'lodash/fp';\nimport { errors } from '@strapi/utils';\nimport { validateUserCreationInput } from '../validation/user';\nimport { validateUserUpdateInput } from '../../../../server/src/validation/user';\nimport { getService } from '../utils';\nimport { isSsoLocked } from '../utils/sso-lock';\n\nconst { ApplicationError, ForbiddenError } = errors;\n\nconst pickUserCreationAttributes = pick(['firstname', 'lastname', 'email', 'roles']);\n\nconst hasAdminSeatsAvaialble = async () => {\n  if (!strapi.EE) {\n    return true;\n  }\n\n  const permittedSeats = ee.seats as any;\n  if (isNil(permittedSeats)) {\n    return true;\n  }\n\n  const userCount = await strapi.service('admin::user').getCurrentActiveUserCount();\n\n  if (userCount < permittedSeats) {\n    return true;\n  }\n};\n\nexport default {\n  async create(ctx: Context) {\n    if (!(await hasAdminSeatsAvaialble())) {\n      throw new ForbiddenError('License seat limit reached. You cannot create a new user');\n    }\n\n    const { body } = ctx.request;\n    const cleanData = { ...body, email: _.get(body, `email`, ``).toLowerCase() };\n\n    await validateUserCreationInput(cleanData);\n\n    const attributes = pickUserCreationAttributes(cleanData);\n    const { useSSORegistration } = cleanData;\n\n    const userAlreadyExists = await getService('user').exists({ email: attributes.email });\n\n    if (userAlreadyExists) {\n      throw new ApplicationError('Email already taken');\n    }\n\n    if (useSSORegistration) {\n      Object.assign(attributes, { registrationToken: null, isActive: true });\n    }\n\n    const createdUser = await getService('user').create(attributes);\n    const userInfo = getService('user').sanitizeUser(createdUser);\n\n    // Note: We need to assign manually the registrationToken to the\n    // final user payload so that it's not removed in the sanitation process.\n    Object.assign(userInfo, { registrationToken: createdUser.registrationToken });\n\n    ctx.created({ data: userInfo });\n  },\n\n  async update(ctx: Context) {\n    const { id } = ctx.params;\n    const { body: input } = ctx.request;\n\n    await validateUserUpdateInput(input);\n\n    if (_.has(input, 'email')) {\n      const uniqueEmailCheck = await getService('user').exists({\n        id: { $ne: id },\n        email: input.email,\n      });\n\n      if (uniqueEmailCheck) {\n        throw new ApplicationError('A user with this email address already exists');\n      }\n    }\n\n    const user = await getService('user').findOne(id, null);\n\n    if (!(await hasAdminSeatsAvaialble()) && !user.isActive && input.isActive) {\n      throw new ForbiddenError('License seat limit reached. You cannot active this user');\n    }\n\n    const updatedUser = await getService('user').updateById(id, input);\n\n    if (!updatedUser) {\n      return ctx.notFound('User does not exist');\n    }\n\n    ctx.body = {\n      data: getService('user').sanitizeUser(updatedUser),\n    };\n  },\n\n  async isSSOLocked(ctx: Context) {\n    const { user } = ctx.state;\n    const isSSOLocked = await isSsoLocked(user);\n\n    ctx.body = {\n      data: {\n        isSSOLocked,\n      },\n    };\n  },\n};\n","import { yup, validateYupSchema } from '@strapi/utils';\n\nconst ALLOWED_SORT_STRINGS = ['action:ASC', 'action:DESC', 'date:ASC', 'date:DESC'];\n\nconst validateFindManySchema = yup\n  .object()\n  .shape({\n    page: yup.number().integer().min(1),\n    pageSize: yup.number().integer().min(1).max(100),\n    sort: yup.mixed().oneOf(ALLOWED_SORT_STRINGS),\n  })\n  .required();\n\nexport const validateFindMany = validateYupSchema(validateFindManySchema, { strict: false });\n\nexport default {\n  validateFindMany,\n};\n","import type { Context } from 'koa';\n\nimport { validateFindMany } from '../validation/audit-logs';\n\nexport default {\n  async findMany(ctx: Context) {\n    const { query } = ctx.request;\n    await validateFindMany(query);\n\n    const auditLogs = strapi.container.get('audit-logs');\n    const body = await auditLogs.findMany(query);\n\n    ctx.body = body;\n  },\n\n  async findOne(ctx: Context) {\n    const { id } = ctx.params;\n\n    const auditLogs = strapi.container.get('audit-logs');\n    const body = await auditLogs.findOne(id);\n\n    ctx.body = body;\n\n    strapi.telemetry.send('didWatchAnAuditLog');\n  },\n};\n","import { isNil } from 'lodash/fp';\nimport ee from '@strapi/strapi/dist/utils/ee';\nimport { env } from '@strapi/utils';\nimport { getService } from '../utils';\n\nexport default {\n  // NOTE: Overrides CE admin controller\n  async getProjectType() {\n    const flags = strapi.config.get('admin.flags', {});\n    try {\n      return { data: { isEE: strapi.EE, features: ee.features.list(), flags } };\n    } catch (err) {\n      return { data: { isEE: false, features: [], flags } };\n    }\n  },\n\n  async licenseLimitInformation() {\n    const permittedSeats = ee.seats;\n\n    let shouldNotify = false;\n    let licenseLimitStatus = null;\n    let enforcementUserCount;\n\n    const currentActiveUserCount = await getService('user').getCurrentActiveUserCount();\n\n    const eeDisabledUsers = await getService('seat-enforcement').getDisabledUserList();\n\n    if (eeDisabledUsers) {\n      enforcementUserCount = currentActiveUserCount + eeDisabledUsers.length;\n    } else {\n      enforcementUserCount = currentActiveUserCount;\n    }\n\n    if (!isNil(permittedSeats) && enforcementUserCount > permittedSeats) {\n      shouldNotify = true;\n      licenseLimitStatus = 'OVER_LIMIT';\n    }\n\n    if (!isNil(permittedSeats) && enforcementUserCount === permittedSeats) {\n      shouldNotify = true;\n      licenseLimitStatus = 'AT_LIMIT';\n    }\n\n    const data = {\n      enforcementUserCount,\n      currentActiveUserCount,\n      permittedSeats,\n      shouldNotify,\n      shouldStopCreate: isNil(permittedSeats) ? false : currentActiveUserCount >= permittedSeats,\n      licenseLimitStatus,\n      isHostedOnStrapiCloud: env('STRAPI_HOSTING', null) === 'strapi.cloud',\n      features: ee.features.list() ?? [],\n    };\n\n    return { data };\n  },\n};\n","/* eslint-disable func-names */\nimport { yup, validateYupSchema } from '@strapi/utils';\nimport { hasStageAttribute } from '../utils/review-workflows';\nimport { STAGE_TRANSITION_UID } from '../constants/workflows';\n\nconst stageObject = yup.object().shape({\n  id: yup.number().integer().min(1),\n  name: yup.string().max(255).required(),\n  color: yup.string().matches(/^#(?:[0-9a-fA-F]{3}){1,2}$/i), // hex color\n  permissions: yup.array().of(\n    yup.object().shape({\n      role: yup.number().integer().min(1).required(),\n      action: yup.string().oneOf([STAGE_TRANSITION_UID]).required(),\n      actionParameters: yup.object().shape({\n        from: yup.number().integer().min(1).required(),\n        to: yup.number().integer().min(1),\n      }),\n    })\n  ),\n});\n\nconst validateUpdateStageOnEntitySchema = yup\n  .object()\n  .shape({\n    id: yup.number().integer().min(1).required(),\n  })\n  .required();\n\nconst validateContentTypes = yup.array().of(\n  // @ts-expect-error yup types\n  yup\n    .string()\n    .test({\n      name: 'content-type-exists',\n      message: (value) => `Content type ${value.originalValue} does not exist`,\n      test(uid: any) {\n        // Warning; we use the strapi global - to avoid that, it would need to refactor how\n        // we generate validation function by using a factory with the strapi instance as parameter.\n        return strapi.getModel(uid);\n      },\n    })\n    .test({\n      name: 'content-type-review-workflow-enabled',\n      message: (value) =>\n        `Content type ${value.originalValue} does not have review workflow enabled`,\n      test(uid: any) {\n        const model = strapi.getModel(uid);\n\n        // It's not a valid content type if it doesn't have the stage attribute\n        return hasStageAttribute(model);\n      },\n    })\n);\n\nconst validateWorkflowCreateSchema = yup.object().shape({\n  name: yup.string().max(255).min(1, 'Workflow name can not be empty').required(),\n  stages: yup\n    .array()\n    .of(stageObject)\n    // @ts-expect-error - add unique property into the yup namespace typing\n    .uniqueProperty('name', 'Stage name must be unique')\n    .min(1, 'Can not create a workflow without stages')\n    .max(200, 'Can not have more than 200 stages')\n    .required('Can not create a workflow without stages'),\n  contentTypes: validateContentTypes,\n});\n\nconst validateWorkflowUpdateSchema = yup.object().shape({\n  name: yup.string().max(255).min(1, 'Workflow name can not be empty'),\n  stages: yup\n    .array()\n    .of(stageObject)\n    // @ts-expect-error - add unique property into the yup namespace typing\n    .uniqueProperty('name', 'Stage name must be unique')\n    .min(1, 'Can not update a workflow without stages')\n    .max(200, 'Can not have more than 200 stages'),\n  contentTypes: validateContentTypes,\n});\n\nconst validateUpdateAssigneeOnEntitySchema = yup\n  .object()\n  .shape({\n    id: yup.number().integer().min(1).nullable(),\n  })\n  .required();\n\nexport const validateWorkflowCreate = validateYupSchema(validateWorkflowCreateSchema);\nexport const validateUpdateStageOnEntity = validateYupSchema(validateUpdateStageOnEntitySchema);\nexport const validateUpdateAssigneeOnEntity = validateYupSchema(\n  validateUpdateAssigneeOnEntitySchema\n);\nexport const validateWorkflowUpdate = validateYupSchema(validateWorkflowUpdateSchema);\n\nexport default {\n  validateWorkflowCreate,\n  validateUpdateStageOnEntity,\n  validateUpdateAssigneeOnEntity,\n  validateWorkflowUpdate,\n};\n","import type { Context } from 'koa';\n\nimport { Strapi } from '@strapi/types';\nimport { update, map, property } from 'lodash/fp';\nimport { mapAsync } from '@strapi/utils';\nimport { getService } from '../../utils';\nimport { validateWorkflowCreate, validateWorkflowUpdate } from '../../validation/review-workflows';\nimport { WORKFLOW_MODEL_UID, WORKFLOW_POPULATE } from '../../constants/workflows';\n\n/**\n *\n * @param { Strapi } strapi - Strapi instance\n * @param userAbility\n * @return { PermissionChecker }\n */\nfunction getWorkflowsPermissionChecker({ strapi }: { strapi: Strapi }, userAbility: unknown) {\n  return strapi\n    .plugin('content-manager')\n    .service('permission-checker')\n    .create({ userAbility, model: WORKFLOW_MODEL_UID });\n}\n\n/**\n * Transforms workflow to an admin UI format.\n * Some attributes (like permissions) are presented in a different format in the admin UI.\n * @param {Workflow} workflow\n */\nfunction formatWorkflowToAdmin(workflow: any) {\n  if (!workflow) return;\n  if (!workflow.stages) return workflow;\n\n  // Transform permissions roles to be the id string instead of an object\n  const transformPermissions = map(update('role', property('id')));\n  const transformStages = map(update('permissions', transformPermissions));\n  return update('stages', transformStages, workflow);\n}\n\nexport default {\n  /**\n   * Create a new workflow\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async create(ctx: Context) {\n    const { body, query } = ctx.request;\n    const { sanitizeCreateInput, sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker(\n      { strapi },\n      ctx.state.userAbility\n    );\n    const { populate } = await sanitizedQuery.create(query);\n\n    const workflowBody = await validateWorkflowCreate(body.data);\n\n    const workflowService = getService('workflows');\n    const createdWorkflow = await workflowService\n      .create({\n        data: await sanitizeCreateInput(workflowBody),\n        populate,\n      })\n      .then(formatWorkflowToAdmin);\n\n    ctx.body = {\n      data: await sanitizeOutput(createdWorkflow),\n    };\n  },\n\n  /**\n   * Update a workflow\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async update(ctx: Context) {\n    const { id } = ctx.params;\n    const { body, query } = ctx.request;\n    const workflowService = getService('workflows');\n    const { sanitizeUpdateInput, sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker(\n      { strapi },\n      ctx.state.userAbility\n    );\n    const { populate } = await sanitizedQuery.update(query);\n    const workflowBody = await validateWorkflowUpdate(body.data);\n\n    // Find if workflow exists\n    const workflow = await workflowService.findById(id, { populate: WORKFLOW_POPULATE });\n    if (!workflow) {\n      return ctx.notFound();\n    }\n\n    // Sanitize input data\n    const getPermittedFieldToUpdate = sanitizeUpdateInput(workflow);\n    const dataToUpdate = await getPermittedFieldToUpdate(workflowBody);\n\n    // Update workflow\n    const updatedWorkflow = await workflowService\n      .update(workflow, {\n        data: dataToUpdate,\n        populate,\n      })\n      .then(formatWorkflowToAdmin);\n\n    // Send sanitized response\n    ctx.body = {\n      data: await sanitizeOutput(updatedWorkflow),\n    };\n  },\n\n  /**\n   * Delete a workflow\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async delete(ctx: Context) {\n    const { id } = ctx.params;\n    const { query } = ctx.request;\n    const workflowService = getService('workflows');\n    const { sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker(\n      { strapi },\n      ctx.state.userAbility\n    );\n    const { populate } = await sanitizedQuery.delete(query);\n\n    const workflow = await workflowService.findById(id, { populate: WORKFLOW_POPULATE });\n    if (!workflow) {\n      return ctx.notFound(\"Workflow doesn't exist\");\n    }\n\n    const deletedWorkflow = await workflowService\n      .delete(workflow, { populate })\n      .then(formatWorkflowToAdmin);\n\n    ctx.body = {\n      data: await sanitizeOutput(deletedWorkflow),\n    };\n  },\n\n  /**\n   * List all workflows\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async find(ctx: Context) {\n    const { query } = ctx.request;\n    const workflowService = getService('workflows');\n    const { sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker(\n      { strapi },\n      ctx.state.userAbility\n    );\n    const { populate, filters, sort } = await sanitizedQuery.read(query);\n\n    const [workflows, workflowCount] = await Promise.all([\n      workflowService.find({ populate, filters, sort }).then(map(formatWorkflowToAdmin)),\n      workflowService.count(),\n    ]);\n\n    ctx.body = {\n      data: await mapAsync(workflows, sanitizeOutput),\n      meta: {\n        workflowCount,\n      },\n    };\n  },\n  /**\n   * Get one workflow based on its id contained in request parameters\n   * Returns count of workflows in meta, used to prevent workflow edition when\n   * max workflow count is reached for the current plan\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async findById(ctx: Context) {\n    const { id } = ctx.params;\n    const { query } = ctx.request;\n    const { sanitizeOutput, sanitizedQuery } = getWorkflowsPermissionChecker(\n      { strapi },\n      ctx.state.userAbility\n    );\n    const { populate } = await sanitizedQuery.read(query);\n\n    const workflowService = getService('workflows');\n\n    const [workflow, workflowCount] = await Promise.all([\n      workflowService.findById(id, { populate }).then(formatWorkflowToAdmin),\n      workflowService.count(),\n    ]);\n\n    ctx.body = {\n      data: await sanitizeOutput(workflow),\n      meta: { workflowCount },\n    };\n  },\n};\n","import type { Context } from 'koa';\n\nimport { Strapi } from '@strapi/types';\nimport { mapAsync } from '@strapi/utils';\nimport { getService } from '../../../utils';\nimport { validateUpdateStageOnEntity } from '../../../validation/review-workflows';\nimport {\n  STAGE_MODEL_UID,\n  ENTITY_STAGE_ATTRIBUTE,\n  STAGE_TRANSITION_UID,\n} from '../../../constants/workflows';\n\n/**\n *\n * @param { Strapi } strapi - Strapi instance\n * @param userAbility\n * @return { (Stage) => SanitizedStage }\n */\nfunction sanitizeStage({ strapi }: { strapi: Strapi }, userAbility: unknown) {\n  const permissionChecker = strapi\n    .plugin('content-manager')\n    .service('permission-checker')\n    .create({ userAbility, model: STAGE_MODEL_UID });\n\n  return (entity: unknown) => permissionChecker.sanitizeOutput(entity);\n}\n\nexport default {\n  /**\n   * List all stages\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async find(ctx: Context) {\n    const { workflow_id: workflowId } = ctx.params;\n    const { populate } = ctx.query;\n    const stagesService = getService('stages');\n    const sanitizer = sanitizeStage({ strapi }, ctx.state.userAbility);\n\n    const stages = await stagesService.find({\n      workflowId,\n      populate,\n    });\n\n    ctx.body = {\n      data: await mapAsync(stages, sanitizer),\n    };\n  },\n  /**\n   * Get one stage\n   * @param {import('koa').BaseContext} ctx - koa context\n   */\n  async findById(ctx: Context) {\n    const { id, workflow_id: workflowId } = ctx.params;\n    const { populate } = ctx.query;\n    const stagesService = getService('stages');\n    const sanitizer = sanitizeStage({ strapi }, ctx.state.userAbility);\n\n    const stage = await stagesService.findById(id, {\n      workflowId,\n      populate,\n    });\n\n    ctx.body = {\n      data: await sanitizer(stage),\n    };\n  },\n\n  /**\n   * Updates an entity's stage.\n   * @async\n   * @param {Object} ctx - The Koa context object.\n   * @param {Object} ctx.params - An object containing the parameters from the request URL.\n   * @param {string} ctx.params.model_uid - The model UID of the entity.\n   * @param {string} ctx.params.id - The ID of the entity to update.\n   * @param {Object} ctx.request.body.data - Optional data object containing the new stage ID for the entity.\n   * @param {string} ctx.request.body.data.id - The ID of the new stage for the entity.\n   * @throws {ApplicationError} If review workflows is not activated on the specified model UID.\n   * @throws {ValidationError} If the `data` object in the request body fails to pass validation.\n   * @returns {Promise<void>} A promise that resolves when the entity's stage has been updated.\n   */\n  async updateEntity(ctx: Context) {\n    const stagesService = getService('stages');\n    const stagePermissions = getService('stage-permissions');\n    const workflowService = getService('workflows');\n\n    const { model_uid: modelUID, id } = ctx.params;\n    const { body } = ctx.request;\n\n    const { sanitizeOutput } = strapi\n      .plugin('content-manager')\n      .service('permission-checker')\n      .create({ userAbility: ctx.state.userAbility, model: modelUID });\n\n    // Load entity\n    const entity = (await strapi.entityService.findOne(modelUID, Number(id), {\n      populate: [ENTITY_STAGE_ATTRIBUTE],\n    })) as any;\n\n    if (!entity) {\n      ctx.throw(404, 'Entity not found');\n    }\n\n    // Validate if entity stage can be updated\n    const canTransition = stagePermissions.can(\n      STAGE_TRANSITION_UID,\n      entity[ENTITY_STAGE_ATTRIBUTE]?.id\n    );\n\n    if (!canTransition) {\n      ctx.throw(403, 'Forbidden stage transition');\n    }\n\n    const { id: stageId } = await validateUpdateStageOnEntity(\n      { id: Number(body?.data?.id) },\n      'You should pass an id to the body of the put request.'\n    );\n\n    const workflow = await workflowService.assertContentTypeBelongsToWorkflow(modelUID);\n    workflowService.assertStageBelongsToWorkflow(stageId, workflow);\n\n    const updatedEntity = await stagesService.updateEntity({ id: entity.id, modelUID }, stageId);\n\n    ctx.body = { data: await sanitizeOutput(updatedEntity) };\n  },\n\n  /**\n   * List all the stages that are available for a user to transition an entity to.\n   * If the user has permission to change the current stage of the entity every other stage in the workflow is returned\n   * @async\n   * @param {*} ctx\n   * @param {string} ctx.params.model_uid - The model UID of the entity.\n   * @param {string} ctx.params.id - The ID of the entity.\n   * @throws {ApplicationError} If review workflows is not activated on the specified model UID.\n   */\n  async listAvailableStages(ctx: Context) {\n    const stagePermissions = getService('stage-permissions');\n    const workflowService = getService('workflows');\n\n    const { model_uid: modelUID, id } = ctx.params;\n\n    if (\n      strapi\n        .plugin('content-manager')\n        .service('permission-checker')\n        .create({ userAbility: ctx.state.userAbility, model: modelUID })\n        .cannot.read()\n    ) {\n      return ctx.forbidden();\n    }\n\n    // Load entity\n    const entity = (await strapi.entityService.findOne(modelUID, Number(id), {\n      populate: [ENTITY_STAGE_ATTRIBUTE],\n    })) as any;\n\n    if (!entity) {\n      ctx.throw(404, 'Entity not found');\n    }\n\n    const entityStageId = entity[ENTITY_STAGE_ATTRIBUTE]?.id;\n    const canTransition = stagePermissions.can(STAGE_TRANSITION_UID, entityStageId);\n\n    const [workflowCount, { stages: workflowStages }] = await Promise.all([\n      workflowService.count(),\n      workflowService.getAssignedWorkflow(modelUID, {\n        populate: 'stages',\n      }),\n    ]);\n\n    const meta = {\n      stageCount: workflowStages.length,\n      workflowCount,\n    };\n\n    if (!canTransition) {\n      ctx.body = {\n        data: [],\n        meta,\n      };\n\n      return;\n    }\n\n    const data = workflowStages.filter((stage: any) => stage.id !== entityStageId);\n    ctx.body = {\n      data,\n      meta,\n    };\n  },\n};\n","import type { Context } from 'koa';\n\nimport { getService } from '../../../utils';\nimport { validateUpdateAssigneeOnEntity } from '../../../validation/review-workflows';\n\nexport default {\n  /**\n   * Updates an entity's assignee.\n   * @async\n   * @param {Object} ctx - The Koa context object.\n   * @param {Object} ctx.params - An object containing the parameters from the request URL.\n   * @param {string} ctx.params.model_uid - The model UID of the entity.\n   * @param {string} ctx.params.id - The ID of the entity to update.\n   * @param {Object} ctx.request.body.data - Optional data object containing the new assignee ID for the entity.\n   * @param {string} ctx.request.body.data.id - The ID of the new assignee for the entity.\n   * @throws {ApplicationError} If review workflows is not activated on the specified model UID.\n   * @throws {ValidationError} If the `data` object in the request body fails to pass validation.\n   * @returns {Promise<void>} A promise that resolves when the entity's assignee has been updated.\n   */\n  async updateEntity(ctx: Context) {\n    const assigneeService = getService('assignees');\n    const workflowService = getService('workflows');\n\n    const { model_uid: model, id } = ctx.params;\n\n    const { sanitizeOutput } = strapi\n      .plugin('content-manager')\n      .service('permission-checker')\n      .create({ userAbility: ctx.state.userAbility, model });\n\n    // TODO: check if user has update permission on the entity\n\n    const { id: assigneeId } = await validateUpdateAssigneeOnEntity(\n      ctx.request?.body?.data,\n      'You should pass a valid id to the body of the put request.'\n    );\n\n    await workflowService.assertContentTypeBelongsToWorkflow(model);\n\n    const entity = await assigneeService.updateEntityAssignee(id, model, assigneeId);\n\n    ctx.body = { data: await sanitizeOutput(entity) };\n  },\n};\n","import 'koa-bodyparser';\n\nimport authentication from './authentication';\nimport role from './role';\nimport user from './user';\nimport auditLogs from './audit-logs';\nimport admin from './admin';\nimport workflows from './workflows';\nimport stages from './workflows/stages';\nimport assignees from './workflows/assignees';\n\nexport default {\n  authentication,\n  role,\n  user,\n  auditLogs,\n  admin,\n  workflows,\n  stages,\n  assignees,\n};\n"],"names":["strapi","getService","name","authenticate","user","UnauthorizedError","ForbiddenError","auth","stages","roles","role","stagePermissions","permission","contentTypes","workflow","defaultEvents","reviewWorkflows","actions","decorator","sso","auditLogs","ApplicationError","email","password","LocalStrategy","getPassportStrategies","authEventsMapper","passport","SUPER_ADMIN_CODE","ValidationError","updatedUser","providerRegistry","ee","metrics","workflows","_","assignees","firstname","lastname","username","property"],"mappings":"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"}