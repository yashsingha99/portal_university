{"version":3,"file":"index.mjs","sources":["../../server/src/constants.ts","../../server/src/utils/index.ts","../../server/src/migrations/index.ts","../../server/src/register.ts","../../server/src/bootstrap.ts","../../server/src/destroy.ts","../../server/src/content-types/release/schema.ts","../../server/src/content-types/release/index.ts","../../server/src/content-types/release-action/schema.ts","../../server/src/content-types/release-action/index.ts","../../server/src/content-types/index.ts","../../server/src/services/release.ts","../../server/src/services/validation.ts","../../server/src/services/scheduling.ts","../../server/src/services/index.ts","../../shared/validation-schemas.ts","../../server/src/controllers/validation/release.ts","../../server/src/controllers/release.ts","../../server/src/controllers/validation/release-action.ts","../../server/src/controllers/release-action.ts","../../server/src/controllers/index.ts","../../server/src/routes/release.ts","../../server/src/routes/release-action.ts","../../server/src/routes/index.ts","../../server/src/index.ts"],"sourcesContent":["export const RELEASE_MODEL_UID = 'plugin::content-releases.release';\nexport const RELEASE_ACTION_MODEL_UID = 'plugin::content-releases.release-action';\n\nexport const ACTIONS = [\n  {\n    section: 'plugins',\n    displayName: 'Read',\n    uid: 'read',\n    pluginName: 'content-releases',\n  },\n  {\n    section: 'plugins',\n    displayName: 'Create',\n    uid: 'create',\n    pluginName: 'content-releases',\n  },\n  {\n    section: 'plugins',\n    displayName: 'Edit',\n    uid: 'update',\n    pluginName: 'content-releases',\n  },\n  {\n    section: 'plugins',\n    displayName: 'Delete',\n    uid: 'delete',\n    pluginName: 'content-releases',\n  },\n  {\n    section: 'plugins',\n    displayName: 'Publish',\n    uid: 'publish',\n    pluginName: 'content-releases',\n  },\n  {\n    section: 'plugins',\n    displayName: 'Remove an entry from a release',\n    uid: 'delete-action',\n    pluginName: 'content-releases',\n  },\n  {\n    section: 'plugins',\n    displayName: 'Add an entry to a release',\n    uid: 'create-action',\n    pluginName: 'content-releases',\n  },\n];\n\nexport const ALLOWED_WEBHOOK_EVENTS = {\n  RELEASES_PUBLISH: 'releases.publish',\n};\n","import type { Common, Entity } from '@strapi/types';\n\nexport const getService = (\n  name: 'release' | 'release-validation' | 'scheduling' | 'release-action' | 'event-manager',\n  { strapi } = { strapi: global.strapi }\n) => {\n  return strapi.plugin('content-releases').service(name);\n};\n\nexport const getPopulatedEntry = async (\n  contentTypeUid: Common.UID.ContentType,\n  entryId: Entity.ID,\n  { strapi } = { strapi: global.strapi }\n) => {\n  const populateBuilderService = strapi.plugin('content-manager').service('populate-builder');\n  // @ts-expect-error - populateBuilderService should be a function but is returning service\n  const populate = await populateBuilderService(contentTypeUid).populateDeep(Infinity).build();\n\n  const entry = await strapi.entityService.findOne(contentTypeUid, entryId, { populate });\n\n  return entry;\n};\n\nexport const getEntryValidStatus = async (\n  contentTypeUid: Common.UID.ContentType,\n  entry: { id: Entity.ID; [key: string]: any },\n  { strapi } = { strapi: global.strapi }\n) => {\n  try {\n    // Same function used by entity-manager to validate entries before publishing\n    await strapi.entityValidator.validateEntityCreation(\n      strapi.getModel(contentTypeUid),\n      entry,\n      undefined,\n      // @ts-expect-error - FIXME: entity here is unnecessary\n      entry\n    );\n\n    return true;\n  } catch {\n    return false;\n  }\n};\n","import type { Schema, Common } from '@strapi/types';\nimport { contentTypes as contentTypesUtils, mapAsync } from '@strapi/utils';\nimport isEqual from 'lodash/isEqual';\n\nimport { difference, keys } from 'lodash';\nimport { RELEASE_ACTION_MODEL_UID, RELEASE_MODEL_UID } from '../constants';\nimport { getPopulatedEntry, getEntryValidStatus, getService } from '../utils';\nimport { Release } from '../../../shared/contracts/releases';\nimport { ReleaseAction } from '../../../shared/contracts/release-actions';\n\ninterface Input {\n  oldContentTypes: Record<string, Schema.ContentType>;\n  contentTypes: Record<string, Schema.ContentType>;\n}\n\nexport async function deleteActionsOnDisableDraftAndPublish({\n  oldContentTypes,\n  contentTypes,\n}: Input) {\n  if (!oldContentTypes) {\n    return;\n  }\n\n  for (const uid in contentTypes) {\n    if (!oldContentTypes[uid]) {\n      continue;\n    }\n\n    const oldContentType = oldContentTypes[uid];\n    const contentType = contentTypes[uid];\n\n    if (\n      contentTypesUtils.hasDraftAndPublish(oldContentType) &&\n      !contentTypesUtils.hasDraftAndPublish(contentType)\n    ) {\n      await strapi.db\n        ?.queryBuilder(RELEASE_ACTION_MODEL_UID)\n        .delete()\n        .where({ contentType: uid })\n        .execute();\n    }\n  }\n}\n\nexport async function deleteActionsOnDeleteContentType({ oldContentTypes, contentTypes }: Input) {\n  const deletedContentTypes = difference(keys(oldContentTypes), keys(contentTypes)) ?? [];\n\n  if (deletedContentTypes.length) {\n    await mapAsync(deletedContentTypes, async (deletedContentTypeUID: unknown) => {\n      return strapi.db\n        ?.queryBuilder(RELEASE_ACTION_MODEL_UID)\n        .delete()\n        .where({ contentType: deletedContentTypeUID })\n        .execute();\n    });\n  }\n}\n\nexport async function migrateIsValidAndStatusReleases() {\n  const releasesWithoutStatus = (await strapi.db.query(RELEASE_MODEL_UID).findMany({\n    where: {\n      status: null,\n      releasedAt: null,\n    },\n    populate: {\n      actions: {\n        populate: {\n          entry: true,\n        },\n      },\n    },\n  })) as Release[];\n\n  mapAsync(releasesWithoutStatus, async (release: Release) => {\n    const actions = release.actions;\n\n    const notValidatedActions = actions.filter((action) => action.isEntryValid === null);\n\n    for (const action of notValidatedActions) {\n      // We need to check the Action is related to a valid entry because we can't assume this is gonna be always the case\n      // example: users could make changes directly to their database, or data could be lost\n      if (action.entry) {\n        const populatedEntry = await getPopulatedEntry(action.contentType, action.entry.id, {\n          strapi,\n        });\n\n        if (populatedEntry) {\n          const isEntryValid = getEntryValidStatus(action.contentType, populatedEntry, { strapi });\n\n          await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({\n            where: {\n              id: action.id,\n            },\n            data: {\n              isEntryValid,\n            },\n          });\n        }\n      }\n    }\n\n    return getService('release', { strapi }).updateReleaseStatus(release.id);\n  });\n\n  const publishedReleases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n    where: {\n      status: null,\n      releasedAt: {\n        $notNull: true,\n      },\n    },\n  });\n\n  mapAsync(publishedReleases, async (release: Release) => {\n    return strapi.db.query(RELEASE_MODEL_UID).update({\n      where: {\n        id: release.id,\n      },\n      data: {\n        status: 'done',\n      },\n    });\n  });\n}\n\nexport async function revalidateChangedContentTypes({ oldContentTypes, contentTypes }: Input) {\n  if (oldContentTypes !== undefined && contentTypes !== undefined) {\n    const contentTypesWithDraftAndPublish = Object.keys(oldContentTypes).filter(\n      (uid) => oldContentTypes[uid]?.options?.draftAndPublish\n    );\n    const releasesAffected = new Set();\n\n    mapAsync(contentTypesWithDraftAndPublish, async (contentTypeUID: Common.UID.ContentType) => {\n      const oldContentType = oldContentTypes[contentTypeUID];\n      const contentType = contentTypes[contentTypeUID];\n\n      // If attributes have changed, we need to revalidate actions because maybe validations rules are different\n      if (!isEqual(oldContentType?.attributes, contentType?.attributes)) {\n        const actions = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findMany({\n          where: {\n            contentType: contentTypeUID,\n          },\n          populate: {\n            entry: true,\n            release: true,\n          },\n        });\n\n        await mapAsync(actions, async (action: ReleaseAction) => {\n          if (action.entry && action.release) {\n            const populatedEntry = await getPopulatedEntry(contentTypeUID, action.entry.id, {\n              strapi,\n            });\n\n            if (populatedEntry) {\n              const isEntryValid = await getEntryValidStatus(contentTypeUID, populatedEntry, {\n                strapi,\n              });\n\n              releasesAffected.add(action.release.id);\n\n              await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({\n                where: {\n                  id: action.id,\n                },\n                data: {\n                  isEntryValid,\n                },\n              });\n            }\n          }\n        });\n      }\n    }).then(() => {\n      // We need to update the status of the releases affected\n      mapAsync(releasesAffected, async (releaseId: Release['id']) => {\n        return getService('release', { strapi }).updateReleaseStatus(releaseId);\n      });\n    });\n  }\n}\n\nexport async function disableContentTypeLocalized({ oldContentTypes, contentTypes }: Input) {\n  if (!oldContentTypes) {\n    return;\n  }\n\n  for (const uid in contentTypes) {\n    if (!oldContentTypes[uid]) {\n      continue;\n    }\n\n    const oldContentType = oldContentTypes[uid];\n    const contentType = contentTypes[uid];\n\n    const i18nPlugin = strapi.plugin('i18n');\n    const { isLocalizedContentType } = i18nPlugin.service('content-types');\n\n    // if i18N is disabled remove non default locales before sync\n    if (isLocalizedContentType(oldContentType) && !isLocalizedContentType(contentType)) {\n      await strapi.db\n        .queryBuilder(RELEASE_ACTION_MODEL_UID)\n        .update({\n          locale: null,\n        })\n        .where({ contentType: uid })\n        .execute();\n    }\n  }\n}\n\nexport async function enableContentTypeLocalized({ oldContentTypes, contentTypes }: Input) {\n  if (!oldContentTypes) {\n    return;\n  }\n\n  for (const uid in contentTypes) {\n    if (!oldContentTypes[uid]) {\n      continue;\n    }\n\n    const oldContentType = oldContentTypes[uid];\n    const contentType = contentTypes[uid];\n\n    const i18nPlugin = strapi.plugin('i18n');\n    const { isLocalizedContentType } = i18nPlugin.service('content-types');\n    const { getDefaultLocale } = i18nPlugin.service('locales');\n\n    // if i18N is enabled remove non default locales before sync\n    if (!isLocalizedContentType(oldContentType) && isLocalizedContentType(contentType)) {\n      const defaultLocale = await getDefaultLocale();\n\n      await strapi.db\n        .queryBuilder(RELEASE_ACTION_MODEL_UID)\n        .update({\n          locale: defaultLocale,\n        })\n        .where({ contentType: uid })\n        .execute();\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport type { LoadedStrapi } from '@strapi/types';\n\nimport { ACTIONS, RELEASE_MODEL_UID, RELEASE_ACTION_MODEL_UID } from './constants';\nimport {\n  deleteActionsOnDeleteContentType,\n  deleteActionsOnDisableDraftAndPublish,\n  migrateIsValidAndStatusReleases,\n  revalidateChangedContentTypes,\n  disableContentTypeLocalized,\n  enableContentTypeLocalized,\n} from './migrations';\n\nconst { features } = require('@strapi/strapi/dist/utils/ee');\n\nexport const register = async ({ strapi }: { strapi: LoadedStrapi }) => {\n  if (features.isEnabled('cms-content-releases')) {\n    await strapi.admin.services.permission.actionProvider.registerMany(ACTIONS);\n\n    strapi\n      .hook('strapi::content-types.beforeSync')\n      .register(deleteActionsOnDisableDraftAndPublish)\n      .register(disableContentTypeLocalized);\n    strapi\n      .hook('strapi::content-types.afterSync')\n      .register(deleteActionsOnDeleteContentType)\n      .register(enableContentTypeLocalized)\n      .register(revalidateChangedContentTypes)\n      .register(migrateIsValidAndStatusReleases);\n  }\n\n  if (strapi.plugin('graphql')) {\n    const graphqlExtensionService = strapi.plugin('graphql').service('extension');\n    // Exclude the release and release action models from the GraphQL schema\n    graphqlExtensionService.shadowCRUD(RELEASE_MODEL_UID).disable();\n    graphqlExtensionService.shadowCRUD(RELEASE_ACTION_MODEL_UID).disable();\n  }\n};\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport type { Common, LoadedStrapi, Entity as StrapiEntity } from '@strapi/types';\n\nimport { RELEASE_ACTION_MODEL_UID, RELEASE_MODEL_UID, ALLOWED_WEBHOOK_EVENTS } from './constants';\nimport { getEntryValidStatus, getService } from './utils';\n\nconst { features } = require('@strapi/strapi/dist/utils/ee');\n\nexport const bootstrap = async ({ strapi }: { strapi: LoadedStrapi }) => {\n  if (features.isEnabled('cms-content-releases')) {\n    const contentTypesWithDraftAndPublish = Object.keys(strapi.contentTypes).filter(\n      (uid) => strapi.contentTypes[uid]?.options?.draftAndPublish\n    );\n\n    // Clean up release-actions when an entry is deleted\n    strapi.db.lifecycles.subscribe({\n      models: contentTypesWithDraftAndPublish,\n\n      async afterDelete(event) {\n        try {\n          // @ts-expect-error TODO: lifecycles types looks like are not 100% finished\n          const { model, result } = event;\n          // @ts-expect-error TODO: lifecycles types looks like are not 100% finished\n          if (model.kind === 'collectionType' && model.options?.draftAndPublish) {\n            const { id } = result;\n\n            const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n              where: {\n                actions: {\n                  target_type: model.uid,\n                  target_id: id,\n                },\n              },\n            });\n\n            await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({\n              where: {\n                target_type: model.uid,\n                target_id: id,\n              },\n            });\n\n            // We update the status of each release after delete the actions\n            for (const release of releases) {\n              getService('release', { strapi }).updateReleaseStatus(release.id);\n            }\n          }\n        } catch (error) {\n          // If an error happens we don't want to block the delete entry flow, but we log the error\n          strapi.log.error('Error while deleting release actions after entry delete', { error });\n        }\n      },\n      /**\n       * deleteMany hook doesn't return the deleted entries ids\n       * so we need to fetch them before deleting the entries to save the ids on our state\n       */\n      async beforeDeleteMany(event) {\n        const { model, params } = event;\n        // @ts-expect-error TODO: lifecycles types looks like are not 100% finished\n        if (model.kind === 'collectionType' && model.options?.draftAndPublish) {\n          const { where } = params;\n          const entriesToDelete = await strapi.db\n            .query(model.uid)\n            .findMany({ select: ['id'], where });\n          event.state.entriesToDelete = entriesToDelete;\n        }\n      },\n      /**\n       * We delete the release actions related to deleted entries\n       * We make this only after deleteMany is succesfully executed to avoid errors\n       */\n      async afterDeleteMany(event) {\n        try {\n          const { model, state } = event;\n          const entriesToDelete = state.entriesToDelete;\n          if (entriesToDelete) {\n            const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n              where: {\n                actions: {\n                  target_type: model.uid,\n                  target_id: {\n                    $in: (entriesToDelete as Array<{ id: StrapiEntity.ID }>).map(\n                      (entry) => entry.id\n                    ),\n                  },\n                },\n              },\n            });\n\n            await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({\n              where: {\n                target_type: model.uid,\n                target_id: {\n                  $in: (entriesToDelete as Array<{ id: StrapiEntity.ID }>).map((entry) => entry.id),\n                },\n              },\n            });\n\n            // We update the status of each release after delete the actions\n            for (const release of releases) {\n              getService('release', { strapi }).updateReleaseStatus(release.id);\n            }\n          }\n        } catch (error) {\n          // If an error happens we don't want to block the delete entry flow, but we log the error\n          strapi.log.error('Error while deleting release actions after entry deleteMany', {\n            error,\n          });\n        }\n      },\n\n      async afterUpdate(event) {\n        try {\n          // @ts-expect-error TODO: lifecycles types looks like are not 100% finished\n          const { model, result } = event;\n          // @ts-expect-error TODO: lifecycles types looks like are not 100% finished\n          if (model.kind === 'collectionType' && model.options?.draftAndPublish) {\n            const isEntryValid = await getEntryValidStatus(\n              model.uid as Common.UID.ContentType,\n              result,\n              {\n                strapi,\n              }\n            );\n\n            await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({\n              where: {\n                target_type: model.uid,\n                target_id: result.id,\n              },\n              data: {\n                isEntryValid,\n              },\n            });\n\n            const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n              where: {\n                actions: {\n                  target_type: model.uid,\n                  target_id: result.id,\n                },\n              },\n            });\n\n            for (const release of releases) {\n              getService('release', { strapi }).updateReleaseStatus(release.id);\n            }\n          }\n        } catch (error) {\n          // If an error happens we don't want to block the update entry flow, but we log the error\n          strapi.log.error('Error while updating release actions after entry update', { error });\n        }\n      },\n    });\n\n    getService('scheduling', { strapi })\n      .syncFromDatabase()\n      .catch((err: Error) => {\n        strapi.log.error(\n          'Error while syncing scheduled jobs from the database in the content-releases plugin. This could lead to errors in the releases scheduling.'\n        );\n\n        throw err;\n      });\n\n    Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value]) => {\n      strapi.webhookStore.addAllowedEvent(key, value);\n    });\n  }\n};\n","import { Job } from 'node-schedule';\nimport { LoadedStrapi } from '@strapi/types';\n\nimport { Release } from '../../shared/contracts/releases';\nimport { getService } from './utils';\n\nexport const destroy = async ({ strapi }: { strapi: LoadedStrapi }) => {\n  const scheduledJobs: Map<Release['id'], Job> = getService('scheduling', {\n    strapi,\n  }).getAll();\n\n  for (const [, job] of scheduledJobs) {\n    job.cancel();\n  }\n};\n","import { RELEASE_ACTION_MODEL_UID } from '../../constants';\n\nexport default {\n  collectionName: 'strapi_releases',\n  info: {\n    singularName: 'release',\n    pluralName: 'releases',\n    displayName: 'Release',\n  },\n  options: {\n    draftAndPublish: false,\n  },\n  pluginOptions: {\n    'content-manager': {\n      visible: false,\n    },\n    'content-type-builder': {\n      visible: false,\n    },\n  },\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    releasedAt: {\n      type: 'datetime',\n    },\n    scheduledAt: {\n      type: 'datetime',\n    },\n    timezone: {\n      type: 'string',\n    },\n    status: {\n      type: 'enumeration',\n      enum: ['ready', 'blocked', 'failed', 'done', 'empty'],\n      required: true,\n    },\n    actions: {\n      type: 'relation',\n      relation: 'oneToMany',\n      target: RELEASE_ACTION_MODEL_UID,\n      mappedBy: 'release',\n    },\n  },\n};\n","import schema from './schema';\n\nexport const release = {\n  schema,\n};\n","import { RELEASE_MODEL_UID } from '../../constants';\n\nexport default {\n  collectionName: 'strapi_release_actions',\n  info: {\n    singularName: 'release-action',\n    pluralName: 'release-actions',\n    displayName: 'Release Action',\n  },\n  options: {\n    draftAndPublish: false,\n  },\n  pluginOptions: {\n    'content-manager': {\n      visible: false,\n    },\n    'content-type-builder': {\n      visible: false,\n    },\n  },\n  attributes: {\n    type: {\n      type: 'enumeration',\n      enum: ['publish', 'unpublish'],\n      required: true,\n    },\n    entry: {\n      type: 'relation',\n      relation: 'morphToOne',\n      configurable: false,\n    },\n    contentType: {\n      type: 'string',\n      required: true,\n    },\n    locale: {\n      type: 'string',\n    },\n    release: {\n      type: 'relation',\n      relation: 'manyToOne',\n      target: RELEASE_MODEL_UID,\n      inversedBy: 'actions',\n    },\n    isEntryValid: {\n      type: 'boolean',\n    },\n  },\n};\n","import schema from './schema';\n\nexport const releaseAction = {\n  schema,\n};\n","import { release } from './release';\nimport { releaseAction } from './release-action';\n\nexport const contentTypes = {\n  release,\n  'release-action': releaseAction,\n};\n","import { setCreatorFields, errors } from '@strapi/utils';\n\nimport type { LoadedStrapi, EntityService, UID, Schema } from '@strapi/types';\n\nimport _ from 'lodash/fp';\n\nimport { ALLOWED_WEBHOOK_EVENTS, RELEASE_ACTION_MODEL_UID, RELEASE_MODEL_UID } from '../constants';\nimport type {\n  GetReleases,\n  CreateRelease,\n  UpdateRelease,\n  PublishRelease,\n  GetRelease,\n  Release,\n  DeleteRelease,\n  GetContentTypeEntryReleases,\n} from '../../../shared/contracts/releases';\nimport type {\n  CreateReleaseAction,\n  GetReleaseActions,\n  ReleaseAction,\n  UpdateReleaseAction,\n  DeleteReleaseAction,\n  ReleaseActionGroupBy,\n} from '../../../shared/contracts/release-actions';\nimport type { Entity, UserInfo } from '../../../shared/types';\nimport { getService, getPopulatedEntry, getEntryValidStatus } from '../utils';\n\nexport interface Locale extends Entity {\n  name: string;\n  code: string;\n}\n\ntype LocaleDictionary = {\n  [key: Locale['code']]: Pick<Locale, 'name' | 'code'>;\n};\n\nconst getGroupName = (queryValue?: ReleaseActionGroupBy) => {\n  switch (queryValue) {\n    case 'contentType':\n      return 'contentType.displayName';\n    case 'action':\n      return 'type';\n    case 'locale':\n      return _.getOr('No locale', 'locale.name');\n    default:\n      return 'contentType.displayName';\n  }\n};\n\nconst createReleaseService = ({ strapi }: { strapi: LoadedStrapi }) => {\n  const dispatchWebhook = (\n    event: string,\n    { isPublished, release, error }: { isPublished: boolean; release?: any; error?: unknown }\n  ) => {\n    strapi.eventHub.emit(event, {\n      isPublished,\n      error,\n      release,\n    });\n  };\n\n  const publishSingleTypeAction = async (\n    uid: UID.ContentType,\n    actionType: 'publish' | 'unpublish',\n    entryId: Entity['id']\n  ) => {\n    const entityManagerService = strapi.plugin('content-manager').service('entity-manager');\n    const populateBuilderService = strapi.plugin('content-manager').service('populate-builder');\n\n    // @ts-expect-error - populateBuilderService should be a function but is returning service\n    const populate = await populateBuilderService(uid).populateDeep(Infinity).build();\n\n    const entry = await strapi.entityService.findOne(uid, entryId, { populate });\n\n    try {\n      if (actionType === 'publish') {\n        await entityManagerService.publish(entry, uid);\n      } else {\n        await entityManagerService.unpublish(entry, uid);\n      }\n    } catch (error) {\n      if (\n        error instanceof errors.ApplicationError &&\n        (error.message === 'already.published' || error.message === 'already.draft')\n      ) {\n        // We don't want throw an error if the entry is already published or draft\n      } else {\n        throw error;\n      }\n    }\n  };\n\n  const publishCollectionTypeAction = async (\n    uid: UID.ContentType,\n    entriesToPublishIds: Array<Entity['id']>,\n    entriestoUnpublishIds: Array<Entity['id']>\n  ) => {\n    const entityManagerService = strapi.plugin('content-manager').service('entity-manager');\n    const populateBuilderService = strapi.plugin('content-manager').service('populate-builder');\n\n    // @ts-expect-error - populateBuilderService should be a function but is returning service\n    const populate = await populateBuilderService(uid).populateDeep(Infinity).build();\n\n    /**\n     * We need to get the populate entries to be able to publish without errors on components/relations/dynamicZones\n     * Considering that populate doesn't work well with morph relations we can't get the entries from the Release model\n     * So, we need to fetch them manually\n     */\n    const entriesToPublish = (await strapi.entityService.findMany(uid, {\n      filters: {\n        id: {\n          $in: entriesToPublishIds,\n        },\n      },\n      populate,\n    })) as Entity[];\n\n    const entriesToUnpublish = (await strapi.entityService.findMany(uid, {\n      filters: {\n        id: {\n          $in: entriestoUnpublishIds,\n        },\n      },\n      populate,\n    })) as Entity[];\n\n    if (entriesToPublish.length > 0) {\n      await entityManagerService.publishMany(entriesToPublish, uid);\n    }\n\n    if (entriesToUnpublish.length > 0) {\n      await entityManagerService.unpublishMany(entriesToUnpublish, uid);\n    }\n  };\n\n  /**\n   * Given a release id, it returns the actions formatted ready to be used to publish them.\n   * First we separate actions by collectiontType and singleType,\n   * Then, we split the collectionType based on the action type (publish/unpublish)\n   */\n  const getFormattedActions = async (releaseId: Release['id']) => {\n    const actions = await strapi.db.query(RELEASE_ACTION_MODEL_UID).findMany({\n      where: {\n        release: {\n          id: releaseId,\n        },\n      },\n      populate: {\n        entry: {\n          fields: ['id'],\n        },\n      },\n    });\n\n    if (actions.length === 0) {\n      throw new errors.ValidationError('No entries to publish');\n    }\n\n    /**\n     * We separate publish and unpublish actions, grouping them by contentType and extracting only their IDs. Then we can fetch more data for each entry\n     * We need to separate collectionTypes from singleTypes because findMany work as findOne for singleTypes and publishMany can't be used for singleTypes\n     */\n    const collectionTypeActions: {\n      [key: UID.ContentType]: {\n        entriesToPublishIds: ReleaseAction['entry']['id'][];\n        entriesToUnpublishIds: ReleaseAction['entry']['id'][];\n      };\n    } = {};\n    const singleTypeActions: {\n      uid: UID.ContentType;\n      id: ReleaseAction['entry']['id'];\n      action: ReleaseAction['type'];\n    }[] = [];\n\n    for (const action of actions) {\n      const contentTypeUid = action.contentType;\n\n      if (strapi.contentTypes[contentTypeUid].kind === 'collectionType') {\n        if (!collectionTypeActions[contentTypeUid]) {\n          collectionTypeActions[contentTypeUid] = {\n            entriesToPublishIds: [],\n            entriesToUnpublishIds: [],\n          };\n        }\n\n        if (action.type === 'publish') {\n          collectionTypeActions[contentTypeUid].entriesToPublishIds.push(action.entry.id);\n        } else {\n          collectionTypeActions[contentTypeUid].entriesToUnpublishIds.push(action.entry.id);\n        }\n      } else {\n        singleTypeActions.push({\n          uid: contentTypeUid,\n          action: action.type,\n          id: action.entry.id,\n        });\n      }\n    }\n\n    return { collectionTypeActions, singleTypeActions };\n  };\n\n  return {\n    async create(releaseData: CreateRelease.Request['body'], { user }: { user: UserInfo }) {\n      const releaseWithCreatorFields = await setCreatorFields({ user })(releaseData);\n\n      const {\n        validatePendingReleasesLimit,\n        validateUniqueNameForPendingRelease,\n        validateScheduledAtIsLaterThanNow,\n      } = getService('release-validation', { strapi });\n\n      await Promise.all([\n        validatePendingReleasesLimit(),\n        validateUniqueNameForPendingRelease(releaseWithCreatorFields.name),\n        validateScheduledAtIsLaterThanNow(releaseWithCreatorFields.scheduledAt),\n      ]);\n\n      const release = await strapi.entityService.create(RELEASE_MODEL_UID, {\n        data: {\n          ...releaseWithCreatorFields,\n          status: 'empty',\n        },\n      });\n\n      if (releaseWithCreatorFields.scheduledAt) {\n        const schedulingService = getService('scheduling', { strapi });\n\n        await schedulingService.set(release.id, release.scheduledAt);\n      }\n\n      strapi.telemetry.send('didCreateContentRelease');\n\n      return release;\n    },\n\n    async findOne(id: GetRelease.Request['params']['id'], query = {}) {\n      const release = await strapi.entityService.findOne(RELEASE_MODEL_UID, id, {\n        ...query,\n      });\n\n      return release;\n    },\n\n    findPage(query?: GetReleases.Request['query']) {\n      return strapi.entityService.findPage(RELEASE_MODEL_UID, {\n        ...query,\n        populate: {\n          actions: {\n            // @ts-expect-error Ignore missing properties\n            count: true,\n          },\n        },\n      });\n    },\n\n    async findManyWithContentTypeEntryAttached(\n      contentTypeUid: GetContentTypeEntryReleases.Request['query']['contentTypeUid'],\n      entryId: GetContentTypeEntryReleases.Request['query']['entryId']\n    ) {\n      const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n        where: {\n          actions: {\n            target_type: contentTypeUid,\n            target_id: entryId,\n          },\n          releasedAt: {\n            $null: true,\n          },\n        },\n        populate: {\n          // Filter the action to get only the content type entry\n          actions: {\n            where: {\n              target_type: contentTypeUid,\n              target_id: entryId,\n            },\n          },\n        },\n      });\n\n      return releases.map((release) => {\n        if (release.actions?.length) {\n          const [actionForEntry] = release.actions;\n\n          // Remove the actions key to replace it with an action key\n          delete release.actions;\n\n          return {\n            ...release,\n            action: actionForEntry,\n          };\n        }\n\n        return release;\n      });\n    },\n\n    async findManyWithoutContentTypeEntryAttached(\n      contentTypeUid: GetContentTypeEntryReleases.Request['query']['contentTypeUid'],\n      entryId: GetContentTypeEntryReleases.Request['query']['entryId']\n    ) {\n      // We get the list of releases where the entry is present\n      const releasesRelated = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n        where: {\n          releasedAt: {\n            $null: true,\n          },\n          actions: {\n            target_type: contentTypeUid,\n            target_id: entryId,\n          },\n        },\n      });\n\n      const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n        where: {\n          $or: [\n            {\n              id: {\n                $notIn: releasesRelated.map((release) => release.id),\n              },\n            },\n            {\n              actions: null,\n            },\n          ],\n          releasedAt: {\n            $null: true,\n          },\n        },\n      });\n\n      return releases.map((release) => {\n        if (release.actions?.length) {\n          const [actionForEntry] = release.actions;\n\n          // Remove the actions key to replace it with an action key\n          delete release.actions;\n\n          return {\n            ...release,\n            action: actionForEntry,\n          };\n        }\n\n        return release;\n      });\n    },\n\n    async update(\n      id: number,\n      releaseData: UpdateRelease.Request['body'],\n      { user }: { user: UserInfo }\n    ) {\n      const releaseWithCreatorFields = await setCreatorFields({ user, isEdition: true })(\n        releaseData\n      );\n\n      const { validateUniqueNameForPendingRelease, validateScheduledAtIsLaterThanNow } = getService(\n        'release-validation',\n        { strapi }\n      );\n\n      await Promise.all([\n        validateUniqueNameForPendingRelease(releaseWithCreatorFields.name, id),\n        validateScheduledAtIsLaterThanNow(releaseWithCreatorFields.scheduledAt),\n      ]);\n\n      const release = await strapi.entityService.findOne(RELEASE_MODEL_UID, id);\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${id}`);\n      }\n\n      if (release.releasedAt) {\n        throw new errors.ValidationError('Release already published');\n      }\n\n      const updatedRelease = await strapi.entityService.update(RELEASE_MODEL_UID, id, {\n        /*\n         * The type returned from the entity service: Partial<Input<\"plugin::content-releases.release\">>\n         * is not compatible with the type we are passing here: UpdateRelease.Request['body']\n         */\n        // @ts-expect-error see above\n        data: releaseWithCreatorFields,\n      });\n\n      const schedulingService = getService('scheduling', { strapi });\n\n      if (releaseData.scheduledAt) {\n        // set function always cancel the previous job if it exists, so we can call it directly\n        await schedulingService.set(id, releaseData.scheduledAt);\n      } else if (release.scheduledAt) {\n        // When user don't send a scheduledAt and we have one on the release, means that user want to unschedule it\n        schedulingService.cancel(id);\n      }\n\n      this.updateReleaseStatus(id);\n\n      strapi.telemetry.send('didUpdateContentRelease');\n\n      return updatedRelease;\n    },\n\n    async createAction(\n      releaseId: CreateReleaseAction.Request['params']['releaseId'],\n      action: Pick<CreateReleaseAction.Request['body'], 'type' | 'entry'>\n    ) {\n      const { validateEntryContentType, validateUniqueEntry } = getService('release-validation', {\n        strapi,\n      });\n\n      await Promise.all([\n        validateEntryContentType(action.entry.contentType),\n        validateUniqueEntry(releaseId, action),\n      ]);\n\n      const release = await strapi.entityService.findOne(RELEASE_MODEL_UID, releaseId);\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n      }\n\n      if (release.releasedAt) {\n        throw new errors.ValidationError('Release already published');\n      }\n\n      const { entry, type } = action;\n\n      const populatedEntry = await getPopulatedEntry(entry.contentType, entry.id, { strapi });\n      const isEntryValid = await getEntryValidStatus(entry.contentType, populatedEntry, { strapi });\n\n      const releaseAction = await strapi.entityService.create(RELEASE_ACTION_MODEL_UID, {\n        data: {\n          type,\n          contentType: entry.contentType,\n          locale: entry.locale,\n          isEntryValid,\n          entry: {\n            id: entry.id,\n            __type: entry.contentType,\n            __pivot: { field: 'entry' },\n          },\n          release: releaseId,\n        },\n        populate: { release: { fields: ['id'] }, entry: { fields: ['id'] } },\n      });\n\n      this.updateReleaseStatus(releaseId);\n\n      return releaseAction;\n    },\n\n    async findActions(\n      releaseId: GetReleaseActions.Request['params']['releaseId'],\n      query?: GetReleaseActions.Request['query']\n    ) {\n      const release = await strapi.entityService.findOne(RELEASE_MODEL_UID, releaseId, {\n        fields: ['id'],\n      });\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n      }\n\n      return strapi.entityService.findPage(RELEASE_ACTION_MODEL_UID, {\n        ...query,\n        populate: {\n          entry: {\n            populate: '*',\n          },\n        },\n        filters: {\n          release: releaseId,\n        },\n      });\n    },\n\n    async countActions(\n      query: EntityService.Params.Pick<typeof RELEASE_ACTION_MODEL_UID, 'filters'>\n    ) {\n      return strapi.entityService.count(RELEASE_ACTION_MODEL_UID, query);\n    },\n\n    async groupActions(actions: ReleaseAction[], groupBy: ReleaseActionGroupBy) {\n      const contentTypeUids = actions.reduce<ReleaseAction['contentType'][]>((acc, action) => {\n        if (!acc.includes(action.contentType)) {\n          acc.push(action.contentType);\n        }\n\n        return acc;\n      }, []);\n      const allReleaseContentTypesDictionary = await this.getContentTypesDataForActions(\n        contentTypeUids\n      );\n      const allLocalesDictionary = await this.getLocalesDataForActions();\n\n      const formattedData = actions.map((action: ReleaseAction) => {\n        const { mainField, displayName } = allReleaseContentTypesDictionary[action.contentType];\n\n        return {\n          ...action,\n          locale: action.locale ? allLocalesDictionary[action.locale] : null,\n          contentType: {\n            displayName,\n            mainFieldValue: action.entry[mainField],\n            uid: action.contentType,\n          },\n        };\n      });\n\n      const groupName = getGroupName(groupBy);\n      return _.groupBy(groupName)(formattedData);\n    },\n\n    async getLocalesDataForActions() {\n      if (!strapi.plugin('i18n')) {\n        return {};\n      }\n\n      const allLocales: Locale[] = (await strapi.plugin('i18n').service('locales').find()) || [];\n      return allLocales.reduce<LocaleDictionary>((acc, locale) => {\n        acc[locale.code] = { name: locale.name, code: locale.code };\n\n        return acc;\n      }, {});\n    },\n\n    async getContentTypesDataForActions(contentTypesUids: ReleaseAction['contentType'][]) {\n      const contentManagerContentTypeService = strapi\n        .plugin('content-manager')\n        .service('content-types');\n\n      const contentTypesData: Record<UID.ContentType, { mainField: string; displayName: string }> =\n        {};\n      for (const contentTypeUid of contentTypesUids) {\n        const contentTypeConfig = await contentManagerContentTypeService.findConfiguration({\n          uid: contentTypeUid,\n        });\n\n        contentTypesData[contentTypeUid] = {\n          mainField: contentTypeConfig.settings.mainField,\n          displayName: strapi.getModel(contentTypeUid).info.displayName,\n        };\n      }\n\n      return contentTypesData;\n    },\n\n    getContentTypeModelsFromActions(actions: ReleaseAction[]) {\n      const contentTypeUids = actions.reduce<ReleaseAction['contentType'][]>((acc, action) => {\n        if (!acc.includes(action.contentType)) {\n          acc.push(action.contentType);\n        }\n\n        return acc;\n      }, []);\n\n      const contentTypeModelsMap = contentTypeUids.reduce(\n        (\n          acc: { [key: ReleaseAction['contentType']]: Schema.ContentType },\n          contentTypeUid: ReleaseAction['contentType']\n        ) => {\n          acc[contentTypeUid] = strapi.getModel(contentTypeUid);\n\n          return acc;\n        },\n        {}\n      );\n\n      return contentTypeModelsMap;\n    },\n\n    async getAllComponents() {\n      const contentManagerComponentsService = strapi\n        .plugin('content-manager')\n        .service('components');\n\n      const components = await contentManagerComponentsService.findAllComponents();\n\n      const componentsMap = components.reduce(\n        (\n          acc: { [key: Schema.Component['uid']]: Schema.Component },\n          component: Schema.Component\n        ) => {\n          acc[component.uid] = component;\n\n          return acc;\n        },\n        {}\n      );\n\n      return componentsMap;\n    },\n\n    async delete(releaseId: DeleteRelease.Request['params']['id']) {\n      const release = (await strapi.entityService.findOne(RELEASE_MODEL_UID, releaseId, {\n        populate: {\n          actions: {\n            fields: ['id'],\n          },\n        },\n      })) as unknown as Release;\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n      }\n\n      if (release.releasedAt) {\n        throw new errors.ValidationError('Release already published');\n      }\n\n      // Only delete the release and its actions is you in fact can delete all the actions and the release\n      // Otherwise, if the transaction fails it throws an error\n      await strapi.db.transaction(async () => {\n        await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({\n          where: {\n            id: {\n              $in: release.actions.map((action) => action.id),\n            },\n          },\n        });\n        await strapi.entityService.delete(RELEASE_MODEL_UID, releaseId);\n      });\n\n      if (release.scheduledAt) {\n        const schedulingService = getService('scheduling', { strapi });\n        await schedulingService.cancel(release.id);\n      }\n\n      strapi.telemetry.send('didDeleteContentRelease');\n\n      return release;\n    },\n\n    async publish(releaseId: PublishRelease.Request['params']['id']) {\n      const {\n        release,\n        error,\n      }: { release: Pick<Release, 'id' | 'releasedAt' | 'status'>; error: Error } =\n        await strapi.db.transaction(async ({ trx }) => {\n          /**\n           * We lock the release in this transaction, so any other process trying to publish it will wait until this transaction is finished\n           * In this transaction we don't care about rollback, becasue we want to persist the lock until the end and if it fails we want to change the release status to failed\n           */\n          const lockedRelease = (await strapi.db\n            ?.queryBuilder(RELEASE_MODEL_UID)\n            .where({ id: releaseId })\n            .select(['id', 'name', 'releasedAt', 'status'])\n            .first()\n            .transacting(trx)\n            .forUpdate()\n            .execute()) as Pick<Release, 'id' | 'name' | 'releasedAt' | 'status'> | undefined;\n\n          if (!lockedRelease) {\n            throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n          }\n\n          if (lockedRelease.releasedAt) {\n            throw new errors.ValidationError('Release already published');\n          }\n\n          if (lockedRelease.status === 'failed') {\n            throw new errors.ValidationError('Release failed to publish');\n          }\n\n          try {\n            strapi.log.info(`[Content Releases] Starting to publish release ${lockedRelease.name}`);\n\n            const { collectionTypeActions, singleTypeActions } = await getFormattedActions(\n              releaseId\n            );\n\n            await strapi.db.transaction(async () => {\n              // First we publish all the singleTypes\n              for (const { uid, action, id } of singleTypeActions) {\n                await publishSingleTypeAction(uid, action, id);\n              }\n\n              // Then, we can continue with publishing the collectionTypes\n              for (const contentTypeUid of Object.keys(collectionTypeActions)) {\n                const uid = contentTypeUid as UID.ContentType;\n\n                await publishCollectionTypeAction(\n                  uid,\n                  collectionTypeActions[uid].entriesToPublishIds,\n                  collectionTypeActions[uid].entriesToUnpublishIds\n                );\n              }\n            });\n\n            const release = await strapi.db.query(RELEASE_MODEL_UID).update({\n              where: {\n                id: releaseId,\n              },\n              data: {\n                status: 'done',\n                releasedAt: new Date(),\n              },\n            });\n\n            dispatchWebhook(ALLOWED_WEBHOOK_EVENTS.RELEASES_PUBLISH, {\n              isPublished: true,\n              release,\n            });\n\n            strapi.telemetry.send('didPublishContentRelease');\n\n            return { release, error: null };\n          } catch (error) {\n            dispatchWebhook(ALLOWED_WEBHOOK_EVENTS.RELEASES_PUBLISH, {\n              isPublished: false,\n              error,\n            });\n\n            // We need to run the update in the same transaction because the release is locked\n            await strapi.db\n              ?.queryBuilder(RELEASE_MODEL_UID)\n              .where({ id: releaseId })\n              .update({\n                status: 'failed',\n              })\n              .transacting(trx)\n              .execute();\n\n            // At this point, we don't want to throw the error because if that happen we rollback the change in the release status\n            // We want to throw the error after the transaction is finished, so we return the error\n            return {\n              release: null,\n              error,\n            };\n          }\n        });\n\n      // Now the first transaction is commited, we can safely throw the error if it exists\n      if (error) {\n        throw error;\n      }\n\n      return release;\n    },\n\n    async updateAction(\n      actionId: UpdateReleaseAction.Request['params']['actionId'],\n      releaseId: UpdateReleaseAction.Request['params']['releaseId'],\n      update: UpdateReleaseAction.Request['body']\n    ) {\n      const updatedAction = await strapi.db.query(RELEASE_ACTION_MODEL_UID).update({\n        where: {\n          id: actionId,\n          release: {\n            id: releaseId,\n            releasedAt: {\n              $null: true,\n            },\n          },\n        },\n        data: update,\n      });\n\n      if (!updatedAction) {\n        throw new errors.NotFoundError(\n          `Action with id ${actionId} not found in release with id ${releaseId} or it is already published`\n        );\n      }\n\n      return updatedAction;\n    },\n\n    async deleteAction(\n      actionId: DeleteReleaseAction.Request['params']['actionId'],\n      releaseId: DeleteReleaseAction.Request['params']['releaseId']\n    ) {\n      const deletedAction = await strapi.db.query(RELEASE_ACTION_MODEL_UID).delete({\n        where: {\n          id: actionId,\n          release: {\n            id: releaseId,\n            releasedAt: {\n              $null: true,\n            },\n          },\n        },\n      });\n\n      if (!deletedAction) {\n        throw new errors.NotFoundError(\n          `Action with id ${actionId} not found in release with id ${releaseId} or it is already published`\n        );\n      }\n\n      this.updateReleaseStatus(releaseId);\n\n      return deletedAction;\n    },\n\n    async updateReleaseStatus(releaseId: Release['id']) {\n      const [totalActions, invalidActions] = await Promise.all([\n        this.countActions({\n          filters: {\n            release: releaseId,\n          },\n        }),\n        this.countActions({\n          filters: {\n            release: releaseId,\n            isEntryValid: false,\n          },\n        }),\n      ]);\n\n      if (totalActions > 0) {\n        if (invalidActions > 0) {\n          return strapi.db.query(RELEASE_MODEL_UID).update({\n            where: {\n              id: releaseId,\n            },\n            data: {\n              status: 'blocked',\n            },\n          });\n        }\n\n        return strapi.db.query(RELEASE_MODEL_UID).update({\n          where: {\n            id: releaseId,\n          },\n          data: {\n            status: 'ready',\n          },\n        });\n      }\n\n      return strapi.db.query(RELEASE_MODEL_UID).update({\n        where: {\n          id: releaseId,\n        },\n        data: {\n          status: 'empty',\n        },\n      });\n    },\n  };\n};\n\nexport default createReleaseService;\n","import { errors } from '@strapi/utils';\nimport { LoadedStrapi } from '@strapi/types';\nimport EE from '@strapi/strapi/dist/utils/ee';\nimport type { Release, CreateRelease, UpdateRelease } from '../../../shared/contracts/releases';\nimport type { CreateReleaseAction } from '../../../shared/contracts/release-actions';\nimport { RELEASE_MODEL_UID } from '../constants';\n\nexport class AlreadyOnReleaseError extends errors.ApplicationError<'AlreadyOnReleaseError'> {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AlreadyOnReleaseError';\n  }\n}\n\nconst createReleaseValidationService = ({ strapi }: { strapi: LoadedStrapi }) => ({\n  async validateUniqueEntry(\n    releaseId: CreateReleaseAction.Request['params']['releaseId'],\n    releaseActionArgs: CreateReleaseAction.Request['body']\n  ) {\n    /**\n     * Asserting the type, otherwise TS complains: 'release.actions' is of type 'unknown', even though the types come through for non-populated fields...\n     * Possibly related to the comment on GetValues: https://github.com/strapi/strapi/blob/main/packages/core/types/src/modules/entity-service/result.ts\n     */\n    const release = (await strapi.entityService.findOne(RELEASE_MODEL_UID, releaseId, {\n      populate: { actions: { populate: { entry: { fields: ['id'] } } } },\n    })) as Release | null;\n\n    if (!release) {\n      throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n    }\n\n    const isEntryInRelease = release.actions.some(\n      (action) =>\n        Number(action.entry.id) === Number(releaseActionArgs.entry.id) &&\n        action.contentType === releaseActionArgs.entry.contentType\n    );\n\n    if (isEntryInRelease) {\n      throw new AlreadyOnReleaseError(\n        `Entry with id ${releaseActionArgs.entry.id} and contentType ${releaseActionArgs.entry.contentType} already exists in release with id ${releaseId}`\n      );\n    }\n  },\n  validateEntryContentType(\n    contentTypeUid: CreateReleaseAction.Request['body']['entry']['contentType']\n  ) {\n    const contentType = strapi.contentType(contentTypeUid);\n\n    if (!contentType) {\n      throw new errors.NotFoundError(`No content type found for uid ${contentTypeUid}`);\n    }\n\n    // TODO: V5 migration - All contentType will have draftAndPublish enabled\n    if (!contentType.options?.draftAndPublish) {\n      throw new errors.ValidationError(\n        `Content type with uid ${contentTypeUid} does not have draftAndPublish enabled`\n      );\n    }\n  },\n  async validatePendingReleasesLimit() {\n    // Use the maximum releases option if it exists, otherwise default to 3\n    const maximumPendingReleases =\n      // @ts-expect-error - options is not typed into features\n      EE.features.get('cms-content-releases')?.options?.maximumReleases || 3;\n\n    const [, pendingReleasesCount] = await strapi.db.query(RELEASE_MODEL_UID).findWithCount({\n      filters: {\n        releasedAt: {\n          $null: true,\n        },\n      },\n    });\n\n    // Unlimited is a number that will never be reached like 9999\n    if (pendingReleasesCount >= maximumPendingReleases) {\n      throw new errors.ValidationError('You have reached the maximum number of pending releases');\n    }\n  },\n  async validateUniqueNameForPendingRelease(\n    name: CreateRelease.Request['body']['name'],\n    id?: UpdateRelease.Request['params']['id']\n  ) {\n    const pendingReleases = (await strapi.entityService.findMany(RELEASE_MODEL_UID, {\n      filters: {\n        releasedAt: {\n          $null: true,\n        },\n        name,\n        ...(id && { id: { $ne: id } }),\n      },\n    })) as Release[];\n\n    const isNameUnique = pendingReleases.length === 0;\n\n    if (!isNameUnique) {\n      throw new errors.ValidationError(`Release with name ${name} already exists`);\n    }\n  },\n  async validateScheduledAtIsLaterThanNow(\n    scheduledAt: CreateRelease.Request['body']['scheduledAt']\n  ) {\n    if (scheduledAt && new Date(scheduledAt) <= new Date()) {\n      throw new errors.ValidationError('Scheduled at must be later than now');\n    }\n  },\n});\n\nexport default createReleaseValidationService;\n","import { scheduleJob, Job } from 'node-schedule';\nimport { LoadedStrapi } from '@strapi/types';\n\nimport { errors } from '@strapi/utils';\nimport { Release } from '../../../shared/contracts/releases';\nimport { getService } from '../utils';\nimport { RELEASE_MODEL_UID } from '../constants';\n\nconst createSchedulingService = ({ strapi }: { strapi: LoadedStrapi }) => {\n  const scheduledJobs = new Map<Release['id'], Job>();\n\n  return {\n    async set(releaseId: Release['id'], scheduleDate: Date) {\n      const release = await strapi.db\n        .query(RELEASE_MODEL_UID)\n        .findOne({ where: { id: releaseId, releasedAt: null } });\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n      }\n\n      const job = scheduleJob(scheduleDate, async () => {\n        try {\n          await getService('release').publish(releaseId);\n          // @TODO: Trigger webhook with success message\n        } catch (error) {\n          // @TODO: Trigger webhook with error message\n        }\n\n        this.cancel(releaseId);\n      });\n\n      if (scheduledJobs.has(releaseId)) {\n        this.cancel(releaseId);\n      }\n\n      scheduledJobs.set(releaseId, job);\n\n      return scheduledJobs;\n    },\n\n    cancel(releaseId: Release['id']) {\n      if (scheduledJobs.has(releaseId)) {\n        scheduledJobs.get(releaseId)!.cancel();\n        scheduledJobs.delete(releaseId);\n      }\n\n      return scheduledJobs;\n    },\n\n    getAll() {\n      return scheduledJobs;\n    },\n\n    /**\n     * On bootstrap, we can use this function to make sure to sync the scheduled jobs from the database that are not yet released\n     * This is useful in case the server was restarted and the scheduled jobs were lost\n     * This also could be used to sync different Strapi instances in case of a cluster\n     */\n    async syncFromDatabase() {\n      const releases = await strapi.db.query(RELEASE_MODEL_UID).findMany({\n        where: {\n          scheduledAt: {\n            $gte: new Date(),\n          },\n          releasedAt: null,\n        },\n      });\n\n      for (const release of releases) {\n        this.set(release.id, release.scheduledAt);\n      }\n\n      return scheduledJobs;\n    },\n  };\n};\n\nexport default createSchedulingService;\n","import release from './release';\nimport releaseValidation from './validation';\nimport scheduling from './scheduling';\n\nexport const services = {\n  release,\n  'release-validation': releaseValidation,\n  scheduling,\n};\n","import * as yup from 'yup';\n\nexport const RELEASE_SCHEMA = yup\n  .object()\n  .shape({\n    name: yup.string().trim().required(),\n    scheduledAt: yup.string().nullable(),\n    isScheduled: yup.boolean().optional(),\n    time: yup.string().when('isScheduled', {\n      is: true,\n      then: yup.string().trim().required(),\n      otherwise: yup.string().nullable(),\n    }),\n    timezone: yup.string().when('isScheduled', {\n      is: true,\n      then: yup.string().required().nullable(),\n      otherwise: yup.string().nullable(),\n    }),\n    date: yup.string().when('isScheduled', {\n      is: true,\n      then: yup.string().required().nullable(),\n      otherwise: yup.string().nullable(),\n    }),\n  })\n  .required()\n  .noUnknown();\n","import { validateYupSchema } from '@strapi/utils';\nimport { RELEASE_SCHEMA } from '../../../../shared/validation-schemas';\n\nexport const validateRelease = validateYupSchema(RELEASE_SCHEMA);\n","import type Koa from 'koa';\nimport { errors } from '@strapi/utils';\nimport { RELEASE_MODEL_UID } from '../constants';\nimport { validateRelease } from './validation/release';\nimport type {\n  CreateRelease,\n  UpdateRelease,\n  PublishRelease,\n  GetRelease,\n  Release,\n  DeleteRelease,\n  GetContentTypeEntryReleases,\n  GetReleases,\n} from '../../../shared/contracts/releases';\nimport type { UserInfo } from '../../../shared/types';\nimport { getService } from '../utils';\n\ntype ReleaseWithPopulatedActions = Release & { actions: { count: number } };\n\nconst releaseController = {\n  async findMany(ctx: Koa.Context) {\n    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({\n      ability: ctx.state.userAbility,\n      model: RELEASE_MODEL_UID,\n    });\n\n    await permissionsManager.validateQuery(ctx.query);\n\n    const releaseService = getService('release', { strapi });\n\n    // Handle requests for releases filtered by content type entry\n    const isFindManyForContentTypeEntry = Boolean(ctx.query?.contentTypeUid && ctx.query?.entryId);\n    if (isFindManyForContentTypeEntry) {\n      const query: GetContentTypeEntryReleases.Request['query'] =\n        await permissionsManager.sanitizeQuery(ctx.query);\n\n      const contentTypeUid = query.contentTypeUid;\n      const entryId = query.entryId;\n      // Parse the string value or fallback to a default\n      const hasEntryAttached: GetContentTypeEntryReleases.Request['query']['hasEntryAttached'] =\n        typeof query.hasEntryAttached === 'string' ? JSON.parse(query.hasEntryAttached) : false;\n\n      const data = hasEntryAttached\n        ? await releaseService.findManyWithContentTypeEntryAttached(contentTypeUid, entryId)\n        : await releaseService.findManyWithoutContentTypeEntryAttached(contentTypeUid, entryId);\n\n      ctx.body = { data };\n    } else {\n      const query: GetReleases.Request['query'] = await permissionsManager.sanitizeQuery(ctx.query);\n      const { results, pagination } = await releaseService.findPage(query);\n\n      const data = results.map((release: ReleaseWithPopulatedActions) => {\n        const { actions, ...releaseData } = release;\n\n        return {\n          ...releaseData,\n          actions: {\n            meta: {\n              count: actions.count,\n            },\n          },\n        };\n      });\n\n      const pendingReleasesCount = await strapi.query(RELEASE_MODEL_UID).count({\n        where: {\n          releasedAt: null,\n        },\n      });\n\n      ctx.body = { data, meta: { pagination, pendingReleasesCount } };\n    }\n  },\n\n  async findOne(ctx: Koa.Context) {\n    const id: GetRelease.Request['params']['id'] = ctx.params.id;\n\n    const releaseService = getService('release', { strapi });\n    const release = await releaseService.findOne(id, { populate: ['createdBy'] });\n    if (!release) {\n      throw new errors.NotFoundError(`Release not found for id: ${id}`);\n    }\n\n    const count = await releaseService.countActions({\n      filters: {\n        release: id,\n      },\n    });\n    const sanitizedRelease = {\n      ...release,\n      createdBy: release.createdBy\n        ? strapi.admin.services.user.sanitizeUser(release.createdBy)\n        : null,\n    };\n\n    // Format the data object\n    const data = {\n      ...sanitizedRelease,\n      actions: {\n        meta: {\n          count,\n        },\n      },\n    };\n\n    ctx.body = { data };\n  },\n\n  async create(ctx: Koa.Context) {\n    const user: UserInfo = ctx.state.user;\n    const releaseArgs: CreateRelease.Request['body'] = ctx.request.body;\n\n    await validateRelease(releaseArgs);\n\n    const releaseService = getService('release', { strapi });\n    const release = await releaseService.create(releaseArgs, { user });\n\n    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({\n      ability: ctx.state.userAbility,\n      model: RELEASE_MODEL_UID,\n    });\n\n    ctx.body = {\n      data: await permissionsManager.sanitizeOutput(release),\n    };\n  },\n\n  async update(ctx: Koa.Context) {\n    const user: UserInfo = ctx.state.user;\n    const releaseArgs: UpdateRelease.Request['body'] = ctx.request.body;\n    const id: UpdateRelease.Request['params']['id'] = ctx.params.id;\n\n    await validateRelease(releaseArgs);\n\n    const releaseService = getService('release', { strapi });\n    const release = await releaseService.update(id, releaseArgs, { user });\n\n    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({\n      ability: ctx.state.userAbility,\n      model: RELEASE_MODEL_UID,\n    });\n\n    ctx.body = {\n      data: await permissionsManager.sanitizeOutput(release),\n    };\n  },\n\n  async delete(ctx: Koa.Context) {\n    const id: DeleteRelease.Request['params']['id'] = ctx.params.id;\n\n    const releaseService = getService('release', { strapi });\n    const release = await releaseService.delete(id);\n\n    ctx.body = {\n      data: release,\n    };\n  },\n\n  async publish(ctx: Koa.Context) {\n    const user: PublishRelease.Request['state']['user'] = ctx.state.user;\n    const id: PublishRelease.Request['params']['id'] = ctx.params.id;\n\n    const releaseService = getService('release', { strapi });\n    const release = await releaseService.publish(id, { user });\n\n    const [countPublishActions, countUnpublishActions] = await Promise.all([\n      releaseService.countActions({\n        filters: {\n          release: id,\n          type: 'publish',\n        },\n      }),\n      releaseService.countActions({\n        filters: {\n          release: id,\n          type: 'unpublish',\n        },\n      }),\n    ]);\n\n    ctx.body = {\n      data: release,\n      meta: {\n        totalEntries: countPublishActions + countUnpublishActions,\n        totalPublishedEntries: countPublishActions,\n        totalUnpublishedEntries: countUnpublishActions,\n      },\n    };\n  },\n};\n\nexport default releaseController;\n","import { yup, validateYupSchema } from '@strapi/utils';\n\nconst RELEASE_ACTION_SCHEMA = yup.object().shape({\n  entry: yup\n    .object()\n    .shape({\n      id: yup.strapiID().required(),\n      contentType: yup.string().required(),\n    })\n    .required(),\n  type: yup.string().oneOf(['publish', 'unpublish']).required(),\n});\n\nconst RELEASE_ACTION_UPDATE_SCHEMA = yup.object().shape({\n  type: yup.string().oneOf(['publish', 'unpublish']).required(),\n});\n\nexport const validateReleaseAction = validateYupSchema(RELEASE_ACTION_SCHEMA);\nexport const validateReleaseActionUpdateSchema = validateYupSchema(RELEASE_ACTION_UPDATE_SCHEMA);\n","import type Koa from 'koa';\n\nimport { mapAsync } from '@strapi/utils';\nimport {\n  validateReleaseAction,\n  validateReleaseActionUpdateSchema,\n} from './validation/release-action';\nimport type {\n  CreateReleaseAction,\n  CreateManyReleaseActions,\n  GetReleaseActions,\n  UpdateReleaseAction,\n  DeleteReleaseAction,\n} from '../../../shared/contracts/release-actions';\nimport { getService } from '../utils';\nimport { RELEASE_ACTION_MODEL_UID } from '../constants';\nimport { AlreadyOnReleaseError } from '../services/validation';\n\nconst releaseActionController = {\n  async create(ctx: Koa.Context) {\n    const releaseId: CreateReleaseAction.Request['params']['releaseId'] = ctx.params.releaseId;\n    const releaseActionArgs: CreateReleaseAction.Request['body'] = ctx.request.body;\n\n    await validateReleaseAction(releaseActionArgs);\n\n    const releaseService = getService('release', { strapi });\n    const releaseAction = await releaseService.createAction(releaseId, releaseActionArgs);\n\n    ctx.body = {\n      data: releaseAction,\n    };\n  },\n\n  async createMany(ctx: Koa.Context) {\n    const releaseId: CreateManyReleaseActions.Request['params']['releaseId'] = ctx.params.releaseId;\n    const releaseActionsArgs: CreateManyReleaseActions.Request['body'] = ctx.request.body;\n\n    await Promise.all(\n      releaseActionsArgs.map((releaseActionArgs) => validateReleaseAction(releaseActionArgs))\n    );\n\n    const releaseService = getService('release', { strapi });\n\n    const releaseActions = await strapi.db.transaction(async () => {\n      const releaseActions = await Promise.all(\n        releaseActionsArgs.map(async (releaseActionArgs) => {\n          try {\n            const action = await releaseService.createAction(releaseId, releaseActionArgs);\n\n            return action;\n          } catch (error) {\n            // If the entry is already in the release, we don't want to throw an error, so we catch and ignore it\n            if (error instanceof AlreadyOnReleaseError) {\n              return null;\n            }\n\n            throw error;\n          }\n        })\n      );\n\n      return releaseActions;\n    });\n\n    const newReleaseActions = releaseActions.filter((action) => action !== null);\n\n    ctx.body = {\n      data: newReleaseActions,\n      meta: {\n        entriesAlreadyInRelease: releaseActions.length - newReleaseActions.length,\n        totalEntries: releaseActions.length,\n      },\n    };\n  },\n\n  async findMany(ctx: Koa.Context) {\n    const releaseId: GetReleaseActions.Request['params']['releaseId'] = ctx.params.releaseId;\n    const permissionsManager = strapi.admin.services.permission.createPermissionsManager({\n      ability: ctx.state.userAbility,\n      model: RELEASE_ACTION_MODEL_UID,\n    });\n    const query = await permissionsManager.sanitizeQuery(ctx.query);\n\n    const releaseService = getService('release', { strapi });\n    const { results, pagination } = await releaseService.findActions(releaseId, {\n      sort: query.groupBy === 'action' ? 'type' : query.groupBy,\n      ...query,\n    });\n\n    /**\n     * Release actions can be related to entries of different content types.\n     * We need to sanitize the entry output according to that content type.\n     * So, we group the sanitized output function by content type.\n     */\n    const contentTypeOutputSanitizers = results.reduce((acc, action) => {\n      if (acc[action.contentType]) {\n        return acc;\n      }\n\n      const contentTypePermissionsManager =\n        strapi.admin.services.permission.createPermissionsManager({\n          ability: ctx.state.userAbility,\n          model: action.contentType,\n        });\n\n      acc[action.contentType] = contentTypePermissionsManager.sanitizeOutput;\n\n      return acc;\n    }, {});\n\n    /**\n     * sanitizeOutput doesn't work if you use it directly on the Release Action model, it doesn't sanitize the entries\n     * So, we need to sanitize manually each entry inside a Release Action\n     */\n    const sanitizedResults = await mapAsync(results, async (action) => ({\n      ...action,\n      entry: await contentTypeOutputSanitizers[action.contentType](action.entry),\n    }));\n\n    const groupedData = await releaseService.groupActions(sanitizedResults, query.groupBy);\n\n    const contentTypes = releaseService.getContentTypeModelsFromActions(results);\n    const components = await releaseService.getAllComponents();\n\n    ctx.body = {\n      data: groupedData,\n      meta: {\n        pagination,\n        contentTypes,\n        components,\n      },\n    };\n  },\n\n  async update(ctx: Koa.Context) {\n    const actionId: UpdateReleaseAction.Request['params']['actionId'] = ctx.params.actionId;\n    const releaseId: UpdateReleaseAction.Request['params']['releaseId'] = ctx.params.releaseId;\n    const releaseActionUpdateArgs: UpdateReleaseAction.Request['body'] = ctx.request.body;\n\n    await validateReleaseActionUpdateSchema(releaseActionUpdateArgs);\n\n    const releaseService = getService('release', { strapi });\n\n    const updatedAction = await releaseService.updateAction(\n      actionId,\n      releaseId,\n      releaseActionUpdateArgs\n    );\n\n    ctx.body = {\n      data: updatedAction,\n    };\n  },\n\n  async delete(ctx: Koa.Context) {\n    const actionId: DeleteReleaseAction.Request['params']['actionId'] = ctx.params.actionId;\n    const releaseId: DeleteReleaseAction.Request['params']['releaseId'] = ctx.params.releaseId;\n\n    const releaseService = getService('release', { strapi });\n\n    const deletedReleaseAction = await releaseService.deleteAction(actionId, releaseId);\n\n    ctx.body = {\n      data: deletedReleaseAction,\n    };\n  },\n};\n\nexport default releaseActionController;\n","import release from './release';\nimport releaseAction from './release-action';\n\nexport const controllers = { release, 'release-action': releaseAction };\n","export default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'POST',\n      path: '/',\n      handler: 'release.create',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.create'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/',\n      handler: 'release.findMany',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/:id',\n      handler: 'release.findOne',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/:id',\n      handler: 'release.update',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.update'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/:id',\n      handler: 'release.delete',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.delete'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/:id/publish',\n      handler: 'release.publish',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.publish'],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n","export default {\n  type: 'admin',\n  routes: [\n    {\n      method: 'POST',\n      path: '/:releaseId/actions',\n      handler: 'release-action.create',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.create-action'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'POST',\n      path: '/:releaseId/actions/bulk',\n      handler: 'release-action.createMany',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.create-action'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'GET',\n      path: '/:releaseId/actions',\n      handler: 'release-action.findMany',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.read'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'PUT',\n      path: '/:releaseId/actions/:actionId',\n      handler: 'release-action.update',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.update'],\n            },\n          },\n        ],\n      },\n    },\n    {\n      method: 'DELETE',\n      path: '/:releaseId/actions/:actionId',\n      handler: 'release-action.delete',\n      config: {\n        policies: [\n          'admin::isAuthenticatedAdmin',\n          {\n            name: 'admin::hasPermissions',\n            config: {\n              actions: ['plugin::content-releases.delete-action'],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n","import release from './release';\nimport releaseAction from './release-action';\n\nexport const routes = {\n  release,\n  'release-action': releaseAction,\n};\n","/* eslint-disable @typescript-eslint/no-var-requires */\nimport { register } from './register';\nimport { bootstrap } from './bootstrap';\nimport { destroy } from './destroy';\nimport { contentTypes } from './content-types';\nimport { services } from './services';\nimport { controllers } from './controllers';\nimport { routes } from './routes';\n\nconst { features } = require('@strapi/strapi/dist/utils/ee');\n\nconst getPlugin = () => {\n  if (features.isEnabled('cms-content-releases')) {\n    return {\n      register,\n      bootstrap,\n      destroy,\n      contentTypes,\n      services,\n      controllers,\n      routes,\n    };\n  }\n\n  return {\n    // Always return register, it handles its own feature check\n    register,\n    // Always return contentTypes to avoid losing data when the feature is disabled\n    contentTypes,\n  };\n};\n\nexport default getPlugin();\n"],"names":["strapi","contentTypes","contentTypesUtils","release","features","schema","releaseAction","error","releaseValidation","scheduling","yup","releaseActions"],"mappings":"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"}