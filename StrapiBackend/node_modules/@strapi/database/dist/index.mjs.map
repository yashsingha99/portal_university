{"version":3,"file":"index.mjs","sources":["../src/dialects/dialect.ts","../src/errors/database.ts","../src/errors/not-null.ts","../src/errors/invalid-time.ts","../src/errors/invalid-date.ts","../src/errors/invalid-datetime.ts","../src/errors/invalid-relation.ts","../src/dialects/postgresql/schema-inspector.ts","../src/dialects/postgresql/index.ts","../src/dialects/mysql/schema-inspector.ts","../src/dialects/mysql/constants.ts","../src/dialects/mysql/database-inspector.ts","../src/dialects/mysql/index.ts","../src/dialects/sqlite/schema-inspector.ts","../src/dialects/sqlite/index.ts","../src/dialects/index.ts","../src/schema/builder.ts","../src/schema/diff.ts","../src/schema/storage.ts","../src/utils/types.ts","../src/schema/schema.ts","../src/schema/index.ts","../src/metadata/relations.ts","../src/metadata/metadata.ts","../src/metadata/index.ts","../src/fields/field.ts","../src/fields/string.ts","../src/fields/json.ts","../src/fields/biginteger.ts","../src/fields/number.ts","../src/fields/shared/parsers.ts","../src/fields/date.ts","../src/fields/time.ts","../src/fields/datetime.ts","../src/fields/timestamp.ts","../src/fields/boolean.ts","../src/fields/index.ts","../src/query/helpers/transform.ts","../src/query/helpers/search.ts","../src/query/helpers/join.ts","../src/query/helpers/order-by.ts","../src/query/helpers/populate/apply.ts","../src/query/helpers/populate/process.ts","../src/utils/knex.ts","../src/query/helpers/where.ts","../src/query/helpers/streams/readable.ts","../src/transaction-context.ts","../src/query/query-builder.ts","../src/entity-manager/entity-repository.ts","../src/entity-manager/morph-relations.ts","../src/entity-manager/regular-relations.ts","../src/entity-manager/relations-orderer.ts","../src/entity-manager/relations/cloning/regular-relations.ts","../src/entity-manager/index.ts","../src/migrations/storage.ts","../src/migrations/index.ts","../src/lifecycles/subscribers/models-lifecycles.ts","../src/lifecycles/subscribers/timestamps.ts","../src/lifecycles/subscribers/index.ts","../src/lifecycles/index.ts","../src/connection.ts","../src/utils/content-types.ts","../src/validations/relations/bidirectional.ts","../src/validations/relations/index.ts","../src/validations/index.ts","../src/index.ts"],"sourcesContent":["import type { Database } from '..';\nimport type { Schema } from '../schema';\n\nexport interface SchemaInspector {\n  getSchema(): Promise<Schema>;\n}\n\nexport default class Dialect {\n  db: Database;\n\n  schemaInspector: SchemaInspector = {} as SchemaInspector;\n\n  client: string;\n\n  constructor(db: Database, client: string) {\n    this.db = db;\n    this.client = client;\n  }\n\n  configure() {}\n\n  initialize() {}\n\n  getSqlType(type: unknown) {\n    return type;\n  }\n\n  canAlterConstraints() {\n    return true;\n  }\n\n  usesForeignKeys() {\n    return false;\n  }\n\n  useReturning() {\n    return false;\n  }\n\n  supportsUnsigned() {\n    return false;\n  }\n\n  supportsWindowFunctions() {\n    return true;\n  }\n\n  supportsOperator(operator?: string): boolean;\n  supportsOperator(): boolean {\n    return true;\n  }\n\n  async startSchemaUpdate() {\n    // noop\n  }\n\n  async endSchemaUpdate() {\n    // noop\n  }\n\n  transformErrors(error: Error | { message: string }) {\n    if (error instanceof Error) {\n      throw error;\n    }\n\n    throw new Error(error.message);\n  }\n\n  canAddIncrements() {\n    return true;\n  }\n}\n","export default class DatabaseError extends Error {\n  details: unknown;\n\n  constructor(message = 'A database error occured', details = {}) {\n    super();\n    this.name = 'DatabaseError';\n    this.message = message;\n    this.details = details;\n  }\n}\n","import DatabaseError from './database';\n\nexport default class NotNullError extends DatabaseError {\n  constructor({ column = '' } = {}) {\n    super(`Not null constraint violation${column ? ` on column ${column}` : ''}.`);\n    this.name = 'NotNullError';\n    this.details = { column };\n    this.stack = '';\n  }\n}\n","import DatabaseError from './database';\n\nexport default class InvalidTimeError extends DatabaseError {\n  constructor(message = 'Invalid time format, expected HH:mm:ss.SSS') {\n    super(message);\n    this.name = 'InvalidTimeFormat';\n  }\n}\n","import DatabaseError from './database';\n\nexport default class InvalidDateError extends DatabaseError {\n  constructor(message = 'Invalid date format, expected YYYY-MM-DD') {\n    super(message);\n    this.name = 'InvalidDateFormat';\n  }\n}\n","import DatabaseError from './database';\n\nexport default class InvalidDateTimeError extends DatabaseError {\n  constructor(message = 'Invalid relation format') {\n    super(message);\n    this.name = 'InvalidDatetimeFormat';\n  }\n}\n","import DatabaseError from './database';\n\nexport default class InvalidRelationError extends DatabaseError {\n  constructor(message = 'Invalid relation format') {\n    super(message);\n    this.name = 'InvalidRelationFormat';\n  }\n}\n","import type { Database } from '../..';\nimport type { Schema, Column, Index, ForeignKey } from '../../schema/types';\nimport type { SchemaInspector } from '../dialect';\n\ninterface RawTable {\n  table_name: string;\n}\n\ninterface RawColumn {\n  data_type: string;\n  column_name: string;\n  character_maximum_length: number;\n  column_default: string;\n  is_nullable: string;\n}\n\ninterface RawIndex {\n  indexrelid: string;\n  index_name: string;\n  column_name: string;\n  is_unique: boolean;\n  is_primary: boolean;\n}\n\ninterface RawForeignKey {\n  constraint_name: string;\n}\n\nconst SQL_QUERIES = {\n  TABLE_LIST: /* sql */ `\n    SELECT *\n    FROM information_schema.tables\n    WHERE\n      table_schema = ?\n      AND table_type = 'BASE TABLE'\n      AND table_name != 'geometry_columns'\n      AND table_name != 'spatial_ref_sys';\n  `,\n  LIST_COLUMNS: /* sql */ `\n    SELECT data_type, column_name, character_maximum_length, column_default, is_nullable\n    FROM information_schema.columns\n    WHERE table_schema = ? AND table_name = ?;\n  `,\n  INDEX_LIST: /* sql */ `\n    SELECT\n      ix.indexrelid,\n      i.relname as index_name,\n      a.attname as column_name,\n      ix.indisunique as is_unique,\n      ix.indisprimary as is_primary\n    FROM\n      pg_class t,\n      pg_namespace s,\n      pg_class i,\n      pg_index ix,\n      pg_attribute a\n    WHERE\n      t.oid = ix.indrelid\n      AND i.oid = ix.indexrelid\n      AND a.attrelid = t.oid\n      AND a.attnum = ANY(ix.indkey)\n      AND t.relkind = 'r'\n      AND t.relnamespace = s.oid\n      AND s.nspname = ?\n      AND t.relname = ?;\n  `,\n  FOREIGN_KEY_LIST: /* sql */ `\n    SELECT\n      tco.\"constraint_name\" as constraint_name\n    FROM information_schema.table_constraints tco\n    WHERE\n      tco.constraint_type = 'FOREIGN KEY'\n      AND tco.constraint_schema = ?\n      AND tco.table_name = ?\n  `,\n  FOREIGN_KEY_REFERENCES: /* sql */ `\n    SELECT\n      kcu.\"constraint_name\" as constraint_name,\n      kcu.\"column_name\" as column_name\n\n    FROM information_schema.key_column_usage kcu\n    WHERE kcu.constraint_name=ANY(?)\n    AND kcu.table_schema = ?\n    AND kcu.table_name = ?;\n  `,\n\n  FOREIGN_KEY_REFERENCES_CONSTRAIN: /* sql */ `\n  SELECT\n  rco.update_rule as on_update,\n  rco.delete_rule as on_delete,\n  rco.\"unique_constraint_name\" as unique_constraint_name\n  FROM information_schema.referential_constraints rco\n  WHERE rco.constraint_name=ANY(?)\n  AND rco.constraint_schema = ?\n`,\n  FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE: /* sql */ `\n  SELECT\n  rel_kcu.\"table_name\" as foreign_table,\n  rel_kcu.\"column_name\" as fk_column_name\n    FROM information_schema.key_column_usage rel_kcu\n    WHERE rel_kcu.constraint_name=?\n    AND rel_kcu.table_schema = ?\n`,\n};\n\nconst toStrapiType = (column: RawColumn) => {\n  const rootType = column.data_type.toLowerCase().match(/[^(), ]+/)?.[0];\n\n  switch (rootType) {\n    case 'integer': {\n      // find a way to figure out the increments\n      return { type: 'integer' };\n    }\n    case 'text': {\n      return { type: 'text', args: ['longtext'] };\n    }\n    case 'boolean': {\n      return { type: 'boolean' };\n    }\n    case 'character': {\n      return { type: 'string', args: [column.character_maximum_length] };\n    }\n    case 'timestamp': {\n      return { type: 'datetime', args: [{ useTz: false, precision: 6 }] };\n    }\n    case 'date': {\n      return { type: 'date' };\n    }\n    case 'time': {\n      return { type: 'time', args: [{ precision: 3 }] };\n    }\n    case 'numeric': {\n      return { type: 'decimal', args: [10, 2] };\n    }\n    case 'real':\n    case 'double': {\n      return { type: 'double' };\n    }\n    case 'bigint': {\n      return { type: 'bigInteger' };\n    }\n    case 'jsonb': {\n      return { type: 'jsonb' };\n    }\n    default: {\n      return { type: 'specificType', args: [column.data_type] };\n    }\n  }\n};\n\nconst getIndexType = (index: RawIndex) => {\n  if (index.is_primary) {\n    return 'primary';\n  }\n\n  if (index.is_unique) {\n    return 'unique';\n  }\n};\n\nexport default class PostgresqlSchemaInspector implements SchemaInspector {\n  db: Database;\n\n  constructor(db: Database) {\n    this.db = db;\n  }\n\n  async getSchema() {\n    const schema: Schema = { tables: [] };\n\n    const tables = await this.getTables();\n\n    schema.tables = await Promise.all(\n      tables.map(async (tableName) => {\n        const columns = await this.getColumns(tableName);\n        const indexes = await this.getIndexes(tableName);\n        const foreignKeys = await this.getForeignKeys(tableName);\n\n        return {\n          name: tableName,\n          columns,\n          indexes,\n          foreignKeys,\n        };\n      })\n    );\n\n    return schema;\n  }\n\n  getDatabaseSchema(): string {\n    return this.db.getSchemaName() || 'public';\n  }\n\n  async getTables(): Promise<string[]> {\n    const { rows } = await this.db.connection.raw<{ rows: RawTable[] }>(SQL_QUERIES.TABLE_LIST, [\n      this.getDatabaseSchema(),\n    ]);\n\n    return rows.map((row) => row.table_name);\n  }\n\n  async getColumns(tableName: string): Promise<Column[]> {\n    const { rows } = await this.db.connection.raw<{ rows: RawColumn[] }>(SQL_QUERIES.LIST_COLUMNS, [\n      this.getDatabaseSchema(),\n      tableName,\n    ]);\n\n    return rows.map((row) => {\n      const { type, args = [], ...rest } = toStrapiType(row);\n\n      const defaultTo =\n        row.column_default && row.column_default.includes('nextval(') ? null : row.column_default;\n\n      return {\n        type,\n        args,\n        defaultTo,\n        name: row.column_name,\n        notNullable: row.is_nullable === 'NO',\n        unsigned: false,\n        ...rest,\n      };\n    });\n  }\n\n  async getIndexes(tableName: string): Promise<Index[]> {\n    const { rows } = await this.db.connection.raw<{ rows: RawIndex[] }>(SQL_QUERIES.INDEX_LIST, [\n      this.getDatabaseSchema(),\n      tableName,\n    ]);\n\n    const ret: Record<RawIndex['indexrelid'], Index> = {};\n\n    for (const index of rows) {\n      if (index.column_name === 'id') {\n        continue;\n      }\n\n      if (!ret[index.indexrelid]) {\n        ret[index.indexrelid] = {\n          columns: [index.column_name],\n          name: index.index_name,\n          type: getIndexType(index),\n        };\n      } else {\n        ret[index.indexrelid].columns.push(index.column_name);\n      }\n    }\n\n    return Object.values(ret);\n  }\n\n  async getForeignKeys(tableName: string): Promise<ForeignKey[]> {\n    const { rows } = await this.db.connection.raw<{ rows: RawForeignKey[] }>(\n      SQL_QUERIES.FOREIGN_KEY_LIST,\n      [this.getDatabaseSchema(), tableName]\n    );\n\n    const ret: Record<RawForeignKey['constraint_name'], ForeignKey> = {};\n\n    for (const fk of rows) {\n      ret[fk.constraint_name] = {\n        name: fk.constraint_name,\n        columns: [],\n        referencedColumns: [],\n        referencedTable: null,\n        onUpdate: null,\n        onDelete: null,\n      } as unknown as ForeignKey;\n    }\n\n    const constraintNames = Object.keys(ret);\n    const dbSchema = this.getDatabaseSchema();\n    if (constraintNames.length > 0) {\n      const { rows: fkReferences } = await this.db.connection.raw(\n        SQL_QUERIES.FOREIGN_KEY_REFERENCES,\n        [[constraintNames], dbSchema, tableName]\n      );\n\n      for (const fkReference of fkReferences) {\n        ret[fkReference.constraint_name].columns.push(fkReference.column_name);\n\n        const { rows: fkReferencesConstraint } = await this.db.connection.raw(\n          SQL_QUERIES.FOREIGN_KEY_REFERENCES_CONSTRAIN,\n          [[fkReference.constraint_name], dbSchema]\n        );\n\n        for (const fkReferenceC of fkReferencesConstraint) {\n          const { rows: fkReferencesConstraintReferece } = await this.db.connection.raw(\n            SQL_QUERIES.FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE,\n            [fkReferenceC.unique_constraint_name, dbSchema]\n          );\n          for (const fkReferenceConst of fkReferencesConstraintReferece) {\n            ret[fkReference.constraint_name].referencedTable = fkReferenceConst.foreign_table;\n            ret[fkReference.constraint_name].referencedColumns.push(\n              fkReferenceConst.fk_column_name\n            );\n          }\n          ret[fkReference.constraint_name].onUpdate = fkReferenceC.on_update.toUpperCase();\n          ret[fkReference.constraint_name].onDelete = fkReferenceC.on_delete.toUpperCase();\n        }\n      }\n    }\n\n    return Object.values(ret);\n  }\n}\n","import * as errors from '../../errors';\nimport type { Database } from '../..';\nimport Dialect from '../dialect';\nimport PostgresqlSchemaInspector from './schema-inspector';\n\nexport default class PostgresDialect extends Dialect {\n  schemaInspector: PostgresqlSchemaInspector;\n\n  constructor(db: Database) {\n    super(db, 'postgres');\n\n    this.schemaInspector = new PostgresqlSchemaInspector(db);\n  }\n\n  useReturning() {\n    return true;\n  }\n\n  async initialize() {\n    // Don't cast DATE string to Date()\n    this.db.connection.client.driver.types.setTypeParser(\n      this.db.connection.client.driver.types.builtins.DATE,\n      'text',\n      (v: unknown) => v\n    );\n    // Don't parse JSONB automatically\n    this.db.connection.client.driver.types.setTypeParser(\n      this.db.connection.client.driver.types.builtins.JSONB,\n      'text',\n      (v: unknown) => v\n    );\n    this.db.connection.client.driver.types.setTypeParser(\n      this.db.connection.client.driver.types.builtins.NUMERIC,\n      'text',\n      parseFloat\n    );\n  }\n\n  usesForeignKeys() {\n    return true;\n  }\n\n  getSqlType(type: string) {\n    switch (type) {\n      case 'timestamp': {\n        return 'datetime';\n      }\n      default: {\n        return type;\n      }\n    }\n  }\n\n  transformErrors(error: NodeJS.ErrnoException) {\n    switch (error.code) {\n      case '23502': {\n        throw new errors.NotNullError({\n          column: 'column' in error ? `${error.column}` : undefined,\n        });\n      }\n      default: {\n        super.transformErrors(error);\n      }\n    }\n  }\n}\n","import type { Column, ForeignKey, Index, Schema } from '../../schema/types';\nimport type { SchemaInspector } from '../dialect';\nimport type { Database } from '../..';\n\ninterface RawTable {\n  table_name: string;\n}\n\ninterface RawColumn {\n  data_type: string;\n  column_name: string;\n  character_maximum_length: number;\n  column_default: string;\n  is_nullable: string;\n  column_type: string;\n  column_key: string;\n}\n\ninterface RawIndex {\n  Key_name: string;\n  Column_name: string;\n  Non_unique: boolean;\n}\n\ninterface RawForeignKey {\n  constraint_name: string;\n}\n\nconst SQL_QUERIES = {\n  TABLE_LIST: /* sql */ `\n    SELECT\n      t.table_name as table_name\n    FROM information_schema.tables t\n    WHERE table_type = 'BASE TABLE'\n    AND table_schema = schema();\n  `,\n  LIST_COLUMNS: /* sql */ `\n    SELECT\n      c.data_type as data_type,\n      c.column_name as column_name,\n      c.character_maximum_length as character_maximum_length,\n      c.column_default as column_default,\n      c.is_nullable as is_nullable,\n      c.column_type as column_type,\n      c.column_key as column_key\n    FROM information_schema.columns c\n    WHERE table_schema = database()\n    AND table_name = ?;\n  `,\n  INDEX_LIST: /* sql */ `\n    show index from ??;\n  `,\n  FOREIGN_KEY_LIST: /* sql */ `\n    SELECT\n      tc.constraint_name as constraint_name\n    FROM information_schema.table_constraints tc\n    WHERE tc.constraint_type = 'FOREIGN KEY'\n    AND tc.table_schema = database()\n    AND tc.table_name = ?;\n  `,\n  FOREIGN_KEY_REFERENCES: /* sql */ `\n    SELECT\n      kcu.constraint_name as constraint_name,\n      kcu.column_name as column_name,\n      kcu.referenced_table_name as referenced_table_name,\n      kcu.referenced_column_name as referenced_column_name\n    FROM information_schema.key_column_usage kcu\n    WHERE kcu.constraint_name in (?)\n    AND kcu.table_schema = database()\n    AND kcu.table_name = ?;\n  `,\n  FOREIGN_KEY_REFERENTIALS_CONSTRAINTS: /* sql */ `\n    SELECT\n      rc.constraint_name as constraint_name,\n      rc.update_rule as on_update,\n      rc.delete_rule as on_delete\n    FROM information_schema.referential_constraints AS rc\n    WHERE rc.constraint_name in (?)\n    AND rc.constraint_schema = database()\n    AND rc.table_name = ?;\n  `,\n};\n\nconst toStrapiType = (column: RawColumn) => {\n  const rootType = column.data_type.toLowerCase().match(/[^(), ]+/)?.[0];\n\n  switch (rootType) {\n    case 'int': {\n      if (column.column_key === 'PRI') {\n        return { type: 'increments', args: [{ primary: true, primaryKey: true }], unsigned: false };\n      }\n\n      return { type: 'integer' };\n    }\n    case 'decimal': {\n      return { type: 'decimal', args: [10, 2] };\n    }\n    case 'double': {\n      return { type: 'double' };\n    }\n    case 'bigint': {\n      return { type: 'bigInteger' };\n    }\n    case 'enum': {\n      return { type: 'string' };\n    }\n    case 'tinyint': {\n      return { type: 'boolean' };\n    }\n    case 'longtext': {\n      return { type: 'text', args: ['longtext'] };\n    }\n    case 'varchar': {\n      return { type: 'string', args: [column.character_maximum_length] };\n    }\n    case 'datetime': {\n      return { type: 'datetime', args: [{ useTz: false, precision: 6 }] };\n    }\n    case 'date': {\n      return { type: 'date' };\n    }\n    case 'time': {\n      return { type: 'time', args: [{ precision: 3 }] };\n    }\n    case 'timestamp': {\n      return { type: 'timestamp', args: [{ useTz: false, precision: 6 }] };\n    }\n    case 'json': {\n      return { type: 'jsonb' };\n    }\n    default: {\n      return { type: 'specificType', args: [column.data_type] };\n    }\n  }\n};\n\nexport default class MysqlSchemaInspector implements SchemaInspector {\n  db: Database;\n\n  constructor(db: Database) {\n    this.db = db;\n  }\n\n  async getSchema() {\n    const schema: Schema = { tables: [] };\n\n    const tables = await this.getTables();\n\n    schema.tables = await Promise.all(\n      tables.map(async (tableName) => {\n        const columns = await this.getColumns(tableName);\n        const indexes = await this.getIndexes(tableName);\n        const foreignKeys = await this.getForeignKeys(tableName);\n\n        return {\n          name: tableName,\n          columns,\n          indexes,\n          foreignKeys,\n        };\n      })\n    );\n\n    return schema;\n  }\n\n  async getTables(): Promise<string[]> {\n    const [rows] = await this.db.connection.raw<[RawTable[]]>(SQL_QUERIES.TABLE_LIST);\n\n    return rows.map((row) => row.table_name);\n  }\n\n  async getColumns(tableName: string): Promise<Column[]> {\n    const [rows] = await this.db.connection.raw<[RawColumn[]]>(SQL_QUERIES.LIST_COLUMNS, [\n      tableName,\n    ]);\n\n    return rows.map((row) => {\n      const { type, args = [], ...rest } = toStrapiType(row);\n\n      return {\n        type,\n        args,\n        defaultTo: row.column_default,\n        name: row.column_name,\n        notNullable: row.is_nullable === 'NO',\n        unsigned: row.column_type.endsWith(' unsigned'),\n        ...rest,\n      };\n    });\n  }\n\n  async getIndexes(tableName: string): Promise<Index[]> {\n    const [rows] = await this.db.connection.raw<[RawIndex[]]>(SQL_QUERIES.INDEX_LIST, [tableName]);\n\n    const ret: Record<RawIndex['Key_name'], Index> = {};\n\n    for (const index of rows) {\n      if (index.Column_name === 'id') {\n        continue;\n      }\n\n      if (!ret[index.Key_name]) {\n        const indexInfo: Index = {\n          columns: [index.Column_name],\n          name: index.Key_name,\n        };\n        if (!index.Non_unique) {\n          indexInfo.type = 'unique';\n        }\n\n        ret[index.Key_name] = indexInfo;\n      } else {\n        ret[index.Key_name].columns.push(index.Column_name);\n      }\n    }\n\n    return Object.values(ret);\n  }\n\n  async getForeignKeys(tableName: string): Promise<ForeignKey[]> {\n    const [rows] = await this.db.connection.raw<[RawForeignKey[]]>(SQL_QUERIES.FOREIGN_KEY_LIST, [\n      tableName,\n    ]);\n\n    const ret: Record<RawForeignKey['constraint_name'], ForeignKey> = {};\n\n    for (const fk of rows) {\n      ret[fk.constraint_name] = {\n        name: fk.constraint_name,\n        columns: [],\n        referencedColumns: [],\n        referencedTable: null,\n        onUpdate: null,\n        onDelete: null,\n      } as unknown as ForeignKey;\n    }\n\n    const contraintNames = Object.keys(ret);\n\n    if (contraintNames.length > 0) {\n      const [fkReferences] = await this.db.connection.raw(SQL_QUERIES.FOREIGN_KEY_REFERENCES, [\n        contraintNames,\n        tableName,\n      ]);\n\n      for (const fkReference of fkReferences) {\n        ret[fkReference.constraint_name].referencedTable = fkReference.referenced_table_name;\n        ret[fkReference.constraint_name].columns.push(fkReference.column_name);\n        ret[fkReference.constraint_name].referencedColumns.push(fkReference.referenced_column_name);\n      }\n\n      const [fkReferentialConstraints] = await this.db.connection.raw(\n        SQL_QUERIES.FOREIGN_KEY_REFERENTIALS_CONSTRAINTS,\n        [contraintNames, tableName]\n      );\n\n      for (const fkReferentialConstraint of fkReferentialConstraints) {\n        ret[fkReferentialConstraint.constraint_name].onUpdate =\n          fkReferentialConstraint.on_update.toUpperCase();\n        ret[fkReferentialConstraint.constraint_name].onDelete =\n          fkReferentialConstraint.on_delete.toUpperCase();\n      }\n    }\n\n    return Object.values(ret);\n  }\n}\n","export const MYSQL = 'MYSQL';\nexport const MARIADB = 'MARIADB';\n","import { MARIADB, MYSQL } from './constants';\nimport type { Database } from '../..';\n\nexport interface Information {\n  database: typeof MARIADB | typeof MYSQL | null;\n  version: string | null;\n}\n\nconst SQL_QUERIES = {\n  VERSION: `SELECT version() as version`,\n};\n\nexport default class MysqlDatabaseInspector {\n  db: Database;\n\n  constructor(db: Database) {\n    this.db = db;\n  }\n\n  async getInformation(): Promise<Information> {\n    let database: Information['database'];\n    let versionNumber: Information['version'];\n    try {\n      const [results] = await this.db.connection.raw(SQL_QUERIES.VERSION);\n      const versionSplit = results[0].version.split('-');\n      const databaseName = versionSplit[1];\n      versionNumber = versionSplit[0];\n      database = databaseName && databaseName.toLowerCase() === 'mariadb' ? MARIADB : MYSQL;\n    } catch (e) {\n      return {\n        database: null,\n        version: null,\n      };\n    }\n\n    return {\n      database,\n      version: versionNumber,\n    };\n  }\n}\n","import semver from 'semver';\nimport type { Knex } from 'knex';\n\nimport Dialect from '../dialect';\nimport MysqlSchemaInspector from './schema-inspector';\nimport MysqlDatabaseInspector from './database-inspector';\nimport { MYSQL } from './constants';\nimport type { Database } from '../..';\n\nimport type { Information } from './database-inspector';\n\nexport default class MysqlDialect extends Dialect {\n  schemaInspector: MysqlSchemaInspector;\n\n  databaseInspector: MysqlDatabaseInspector;\n\n  info: Information | null = null;\n\n  constructor(db: Database) {\n    super(db, 'mysql');\n\n    this.schemaInspector = new MysqlSchemaInspector(db);\n    this.databaseInspector = new MysqlDatabaseInspector(db);\n  }\n\n  configure() {\n    const connection = this.db.config.connection.connection as Knex.MySqlConnectionConfig;\n\n    connection.supportBigNumbers = true;\n    // Only allow bigNumberStrings option set to be true if no connection option passed\n    // Otherwise bigNumberStrings option should be allowed to used from DB config\n    if (connection.bigNumberStrings === undefined) {\n      connection.bigNumberStrings = true;\n    }\n    connection.typeCast = (\n      field: { type: string; string: () => string; length: number },\n      next: () => void\n    ) => {\n      if (field.type === 'DECIMAL' || field.type === 'NEWDECIMAL') {\n        const value = field.string();\n        return value === null ? null : Number(value);\n      }\n\n      if (field.type === 'TINY' && field.length === 1) {\n        const value = field.string();\n        return value ? value === '1' : null;\n      }\n\n      if (field.type === 'DATE') {\n        return field.string();\n      }\n\n      return next();\n    };\n  }\n\n  async initialize() {\n    try {\n      await this.db.connection.raw(`set session sql_require_primary_key = 0;`);\n    } catch (err) {\n      // Ignore error due to lack of session permissions\n    }\n\n    this.info = await this.databaseInspector.getInformation();\n  }\n\n  async startSchemaUpdate() {\n    try {\n      await this.db.connection.raw(`set foreign_key_checks = 0;`);\n      await this.db.connection.raw(`set session sql_require_primary_key = 0;`);\n    } catch (err) {\n      // Ignore error due to lack of session permissions\n    }\n  }\n\n  async endSchemaUpdate() {\n    await this.db.connection.raw(`set foreign_key_checks = 1;`);\n  }\n\n  supportsUnsigned() {\n    return true;\n  }\n\n  supportsWindowFunctions() {\n    const isMysqlDB = !this.info?.database || this.info.database === MYSQL;\n    const isBeforeV8 =\n      !semver.valid(this.info?.version) || semver.lt(this.info?.version ?? '', '8.0.0');\n\n    if (isMysqlDB && isBeforeV8) {\n      return false;\n    }\n\n    return true;\n  }\n\n  usesForeignKeys() {\n    return true;\n  }\n\n  transformErrors(error: Error) {\n    super.transformErrors(error);\n  }\n}\n","import type { Database } from '../..';\nimport type { Schema, Column, Index, ForeignKey } from '../../schema/types';\nimport type { SchemaInspector } from '../dialect';\n\nconst SQL_QUERIES = {\n  TABLE_LIST: `select name from sqlite_master where type = 'table' and name NOT LIKE 'sqlite%'`,\n  TABLE_INFO: `pragma table_info(??)`,\n  INDEX_LIST: 'pragma index_list(??)',\n  INDEX_INFO: 'pragma index_info(??)',\n  FOREIGN_KEY_LIST: 'pragma foreign_key_list(??)',\n};\n\ninterface RawTable {\n  name: string;\n}\ninterface RawColumn {\n  type: string;\n  args?: unknown[];\n  name: string;\n  defaultTo?: unknown;\n  notNullable?: boolean;\n  unsigned?: boolean;\n  unique?: boolean;\n  primary?: boolean;\n  pk?: boolean;\n  foreign?: {\n    table: string;\n    column: string;\n    onUpdate: string;\n    onDelete: string;\n  };\n  data_type?: string;\n  dflt_value?: unknown;\n  notnull?: boolean;\n}\n\ninterface RawIndex {\n  name: string;\n  unique: boolean;\n}\n\ninterface RawIndexInfo {\n  name: string;\n}\n\ninterface RawForeignKey {\n  id: number;\n  seq: number;\n  table: string;\n  from: string;\n  to: string;\n  on_update: string;\n  on_delete: string;\n}\n\nconst toStrapiType = (column: RawColumn) => {\n  const { type } = column;\n\n  const rootType = type.toLowerCase().match(/[^(), ]+/)?.[0];\n\n  switch (rootType) {\n    case 'integer': {\n      if (column.pk) {\n        return { type: 'increments', args: [{ primary: true, primaryKey: true }] };\n      }\n\n      return { type: 'integer' };\n    }\n    case 'float': {\n      return { type: 'float', args: [10, 2] };\n    }\n    case 'bigint': {\n      return { type: 'bigInteger' };\n    }\n    case 'varchar': {\n      const length = type.slice(8, type.length - 1);\n\n      return { type: 'string', args: [Number(length)] };\n    }\n    case 'text': {\n      return { type: 'text', args: ['longtext'] };\n    }\n    case 'json': {\n      return { type: 'jsonb' };\n    }\n    case 'boolean': {\n      return { type: 'boolean' };\n    }\n    case 'datetime': {\n      return { type: 'datetime', args: [{ useTz: false, precision: 6 }] };\n    }\n    case 'date': {\n      return { type: 'date' };\n    }\n    case 'time': {\n      return { type: 'time', args: [{ precision: 3 }] };\n    }\n    default: {\n      return { type: 'specificType', args: [column.data_type] };\n    }\n  }\n};\n\nexport default class SqliteSchemaInspector implements SchemaInspector {\n  db: Database;\n\n  constructor(db: Database) {\n    this.db = db;\n  }\n\n  async getSchema() {\n    const schema: Schema = { tables: [] };\n    const tables = await this.getTables();\n\n    for (const tableName of tables) {\n      const columns = await this.getColumns(tableName);\n      const indexes = await this.getIndexes(tableName);\n      const foreignKeys = await this.getForeignKeys(tableName);\n\n      schema.tables.push({\n        name: tableName,\n        columns,\n        indexes,\n        foreignKeys,\n      });\n    }\n\n    return schema;\n  }\n\n  async getTables(): Promise<string[]> {\n    const rows = await this.db.connection.raw<RawTable[]>(SQL_QUERIES.TABLE_LIST);\n\n    return rows.map((row) => row.name);\n  }\n\n  async getColumns(tableName: string): Promise<Column[]> {\n    const rows = await this.db.connection.raw<RawColumn[]>(SQL_QUERIES.TABLE_INFO, [tableName]);\n\n    return rows.map((row) => {\n      const { type, args = [], ...rest } = toStrapiType(row);\n\n      return {\n        type,\n        args,\n        name: row.name,\n        defaultTo: row.dflt_value,\n        notNullable: row.notnull !== null ? Boolean(row.notnull) : null,\n        unsigned: false,\n        ...rest,\n      };\n    });\n  }\n\n  async getIndexes(tableName: string): Promise<Index[]> {\n    const indexes = await this.db.connection.raw<RawIndex[]>(SQL_QUERIES.INDEX_LIST, [tableName]);\n\n    const ret = [];\n\n    for (const index of indexes.filter((index) => !index.name.startsWith('sqlite_'))) {\n      const res = await this.db.connection.raw<RawIndexInfo[]>(SQL_QUERIES.INDEX_INFO, [\n        index.name,\n      ]);\n\n      const indexInfo: Index = {\n        columns: res.map((row) => row.name),\n        name: index.name,\n      };\n\n      if (index.unique) {\n        indexInfo.type = 'unique';\n      }\n\n      ret.push(indexInfo);\n    }\n\n    return ret;\n  }\n\n  async getForeignKeys(tableName: string): Promise<ForeignKey[]> {\n    const fks = await this.db.connection.raw<RawForeignKey[]>(SQL_QUERIES.FOREIGN_KEY_LIST, [\n      tableName,\n    ]);\n\n    const ret: Record<RawForeignKey['id'], ForeignKey> = {};\n\n    for (const fk of fks) {\n      if (!ret[fk.id]) {\n        ret[fk.id] = {\n          // TODO: name, //  find name\n          name: '',\n          columns: [fk.from],\n          referencedColumns: [fk.to],\n          referencedTable: fk.table,\n          onUpdate: fk.on_update.toUpperCase(),\n          onDelete: fk.on_delete.toUpperCase(),\n        };\n      } else {\n        ret[fk.id].columns.push(fk.from);\n        ret[fk.id].referencedColumns.push(fk.to);\n      }\n    }\n\n    return Object.values(ret);\n  }\n}\n","import path from 'path';\nimport fse from 'fs-extra';\nimport type { Knex } from 'knex';\n\nimport * as errors from '../../errors';\nimport Dialect from '../dialect';\nimport SqliteSchemaInspector from './schema-inspector';\nimport type { Database } from '../..';\n\nconst UNSUPPORTED_OPERATORS = ['$jsonSupersetOf'];\n\nexport default class SqliteDialect extends Dialect {\n  schemaInspector: SqliteSchemaInspector;\n\n  constructor(db: Database) {\n    super(db, 'sqlite');\n\n    this.schemaInspector = new SqliteSchemaInspector(db);\n  }\n\n  configure() {\n    const connection = this.db.config.connection.connection as Knex.Sqlite3ConnectionConfig;\n    if (typeof connection !== 'string') {\n      connection.filename = path.resolve(connection.filename);\n    }\n\n    const dbDir = path.dirname(connection.filename);\n\n    fse.ensureDirSync(dbDir);\n  }\n\n  useReturning() {\n    return true;\n  }\n\n  async initialize() {\n    await this.db.connection.raw('pragma foreign_keys = on');\n  }\n\n  canAlterConstraints() {\n    return false;\n  }\n\n  getSqlType(type: string) {\n    switch (type) {\n      case 'enum': {\n        return 'text';\n      }\n      case 'double':\n      case 'decimal': {\n        return 'float';\n      }\n      case 'timestamp': {\n        return 'datetime';\n      }\n      default: {\n        return type;\n      }\n    }\n  }\n\n  supportsOperator(operator: string) {\n    return !UNSUPPORTED_OPERATORS.includes(operator);\n  }\n\n  async startSchemaUpdate() {\n    await this.db.connection.raw(`pragma foreign_keys = off`);\n  }\n\n  async endSchemaUpdate() {\n    await this.db.connection.raw(`pragma foreign_keys = on`);\n  }\n\n  transformErrors(error: NodeJS.ErrnoException) {\n    switch (error.errno) {\n      case 19: {\n        throw new errors.NotNullError(); // TODO: extract column name\n      }\n      default: {\n        super.transformErrors(error);\n      }\n    }\n  }\n\n  canAddIncrements() {\n    return false;\n  }\n}\n","import type { Database } from '..';\nimport Dialect from './dialect';\nimport PostgresClass from './postgresql';\nimport MysqlClass from './mysql';\nimport SqliteClass from './sqlite';\n\n/**\n * Require our dialect-specific code\n */\nconst getDialectClass = (client: string): typeof Dialect => {\n  switch (client) {\n    case 'postgres':\n      return PostgresClass;\n    case 'mysql':\n      return MysqlClass;\n    case 'sqlite':\n      return SqliteClass;\n    default:\n      throw new Error(`Unknown dialect ${client}`);\n  }\n};\n\n/**\n * Get the dialect of a database client\n */\nconst getDialectName = (client: unknown) => {\n  switch (client) {\n    case 'postgres':\n      return 'postgres';\n    case 'mysql':\n    case 'mysql2':\n      return 'mysql';\n    case 'sqlite':\n    case 'sqlite-legacy':\n      return 'sqlite';\n    default:\n      throw new Error(`Unknown dialect ${client}`);\n  }\n};\n\nconst getDialect = (db: Database) => {\n  const { client } = db.config.connection;\n  const dialectName = getDialectName(client);\n\n  const constructor = getDialectClass(dialectName);\n  const dialect = new constructor(db, dialectName);\n\n  return dialect;\n};\n\nexport { Dialect, getDialect };\n","import { isNil, prop, omit, castArray } from 'lodash/fp';\nimport createDebug from 'debug';\n\nimport type { Knex } from 'knex';\nimport type { Database } from '..';\nimport type { Schema, Table, SchemaDiff, TableDiff, ForeignKey, Index, Column } from './types';\n\nconst debug = createDebug('strapi::database');\n\nexport default (db: Database) => {\n  const helpers = createHelpers(db);\n\n  return {\n    /**\n     * Returns a knex schema builder instance\n     * @param {string} table - table name\n     */\n    getSchemaBuilder(trx: Knex.Transaction) {\n      return db.getSchemaConnection(trx);\n    },\n\n    /**\n     * Creates schema in DB\n     */\n    async createSchema(schema: Schema) {\n      await db.connection.transaction(async (trx) => {\n        await this.createTables(schema.tables, trx);\n      });\n    },\n\n    /**\n     * Creates a list of tables in a schema\n     * @param {KnexInstance} trx\n     * @param {Table[]} tables\n     */\n    async createTables(tables: Table[], trx: Knex.Transaction) {\n      for (const table of tables) {\n        debug(`Creating table: ${table.name}`);\n        const schemaBuilder = this.getSchemaBuilder(trx);\n        await helpers.createTable(schemaBuilder, table);\n      }\n\n      // create FKs once all the tables exist\n      for (const table of tables) {\n        debug(`Creating table foreign keys: ${table.name}`);\n        const schemaBuilder = this.getSchemaBuilder(trx);\n        await helpers.createTableForeignKeys(schemaBuilder, table);\n      }\n    },\n    /**\n     * Drops schema from DB\n     */\n    async dropSchema(schema: Schema, { dropDatabase = false } = {}) {\n      if (dropDatabase) {\n        // TODO: drop database & return as it will drop everything\n        return;\n      }\n\n      await db.connection.transaction(async (trx) => {\n        for (const table of schema.tables.reverse()) {\n          const schemaBuilder = this.getSchemaBuilder(trx);\n          await helpers.dropTable(schemaBuilder, table);\n        }\n      });\n    },\n\n    /**\n     * Applies a schema diff update in the DB\n     * @param {*} schemaDiff\n     */\n    // TODO: implement force option to disable removal in DB\n    async updateSchema(schemaDiff: SchemaDiff['diff']) {\n      const forceMigration = db.config.settings?.forceMigration;\n\n      await db.dialect.startSchemaUpdate();\n      await db.connection.transaction(async (trx) => {\n        await this.createTables(schemaDiff.tables.added, trx);\n\n        if (forceMigration) {\n          // drop all delete table foreign keys then delete the tables\n          for (const table of schemaDiff.tables.removed) {\n            debug(`Removing table foreign keys: ${table.name}`);\n\n            const schemaBuilder = this.getSchemaBuilder(trx);\n            await helpers.dropTableForeignKeys(schemaBuilder, table);\n          }\n\n          for (const table of schemaDiff.tables.removed) {\n            debug(`Removing table: ${table.name}`);\n\n            const schemaBuilder = this.getSchemaBuilder(trx);\n            await helpers.dropTable(schemaBuilder, table);\n          }\n        }\n\n        for (const table of schemaDiff.tables.updated) {\n          debug(`Updating table: ${table.name}`);\n          // alter table\n          const schemaBuilder = this.getSchemaBuilder(trx);\n\n          await helpers.alterTable(schemaBuilder, table);\n        }\n      });\n\n      await db.dialect.endSchemaUpdate();\n    },\n  };\n};\n\nconst createHelpers = (db: Database) => {\n  /**\n   *  Creates a foreign key on a table\n   */\n  const createForeignKey = (tableBuilder: Knex.TableBuilder, foreignKey: ForeignKey) => {\n    const { name, columns, referencedColumns, referencedTable, onDelete, onUpdate } = foreignKey;\n\n    const constraint = tableBuilder\n      .foreign(columns, name)\n      .references(referencedColumns)\n      .inTable(db.getSchemaName() ? `${db.getSchemaName()}.${referencedTable}` : referencedTable);\n\n    if (onDelete) {\n      constraint.onDelete(onDelete);\n    }\n\n    if (onUpdate) {\n      constraint.onUpdate(onUpdate);\n    }\n  };\n\n  /**\n   * Drops a foreign key from a table\n   */\n  const dropForeignKey = (tableBuilder: Knex.TableBuilder, foreignKey: ForeignKey) => {\n    const { name, columns } = foreignKey;\n\n    tableBuilder.dropForeign(columns, name);\n  };\n\n  /**\n   * Creates an index on a table\n   */\n  const createIndex = (tableBuilder: Knex.TableBuilder, index: Index) => {\n    const { type, columns, name } = index;\n\n    switch (type) {\n      case 'primary': {\n        return tableBuilder.primary(columns, name);\n      }\n      case 'unique': {\n        return tableBuilder.unique(columns, name);\n      }\n      default: {\n        return tableBuilder.index(columns, name, type);\n      }\n    }\n  };\n\n  /**\n   * Drops an index from table\n   * @param {Knex.TableBuilder} tableBuilder\n   * @param {Index} index\n   */\n  const dropIndex = (tableBuilder: Knex.TableBuilder, index: Index) => {\n    if (!db.config.settings?.forceMigration) {\n      return;\n    }\n\n    const { type, columns, name } = index;\n\n    switch (type) {\n      case 'primary': {\n        return tableBuilder.dropPrimary(name);\n      }\n      case 'unique': {\n        return tableBuilder.dropUnique(columns, name);\n      }\n      default: {\n        return tableBuilder.dropIndex(columns, name);\n      }\n    }\n  };\n\n  /**\n   * Creates a column in a table\n   */\n  const createColumn = (tableBuilder: Knex.TableBuilder, column: Column) => {\n    const { type, name, args = [], defaultTo, unsigned, notNullable } = column;\n\n    const col = (tableBuilder[type as keyof Knex.TableBuilder] as any)(name, ...args);\n\n    if (unsigned === true) {\n      col.unsigned();\n    }\n\n    if (!isNil(defaultTo)) {\n      const [value, opts] = castArray(defaultTo);\n\n      if (prop('isRaw', opts)) {\n        col.defaultTo(db.connection.raw(value), omit('isRaw', opts));\n      } else {\n        col.defaultTo(value, opts);\n      }\n    }\n\n    if (notNullable === true) {\n      col.notNullable();\n    } else {\n      col.nullable();\n    }\n\n    return col;\n  };\n\n  /**\n   * Drops a column from a table\n   */\n  const dropColumn = (tableBuilder: Knex.TableBuilder, column: Column) => {\n    if (!db.config.settings?.forceMigration) {\n      return;\n    }\n\n    return tableBuilder.dropColumn(column.name);\n  };\n\n  /**\n   * Creates a table in a database\n   */\n  const createTable = async (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\n    await schemaBuilder.createTable(table.name, (tableBuilder) => {\n      // columns\n      (table.columns || []).forEach((column) => createColumn(tableBuilder, column));\n\n      // indexes\n      (table.indexes || []).forEach((index) => createIndex(tableBuilder, index));\n\n      // foreign keys\n\n      if (!db.dialect.canAlterConstraints()) {\n        (table.foreignKeys || []).forEach((foreignKey) =>\n          createForeignKey(tableBuilder, foreignKey)\n        );\n      }\n    });\n  };\n\n  const alterTable = async (schemaBuilder: Knex.SchemaBuilder, table: TableDiff['diff']) => {\n    await schemaBuilder.alterTable(table.name, (tableBuilder) => {\n      // Delete indexes / fks / columns\n\n      for (const removedIndex of table.indexes.removed) {\n        debug(`Dropping index ${removedIndex.name}`);\n        dropIndex(tableBuilder, removedIndex);\n      }\n\n      for (const updateddIndex of table.indexes.updated) {\n        debug(`Dropping updated index ${updateddIndex.name}`);\n        dropIndex(tableBuilder, updateddIndex.object);\n      }\n\n      for (const removedForeignKey of table.foreignKeys.removed) {\n        debug(`Dropping foreign key ${removedForeignKey.name}`);\n        dropForeignKey(tableBuilder, removedForeignKey);\n      }\n\n      for (const updatedForeignKey of table.foreignKeys.updated) {\n        debug(`Dropping updated foreign key ${updatedForeignKey.name}`);\n        dropForeignKey(tableBuilder, updatedForeignKey.object);\n      }\n\n      for (const removedColumn of table.columns.removed) {\n        debug(`Dropping column ${removedColumn.name}`);\n        dropColumn(tableBuilder, removedColumn);\n      }\n\n      // Update existing columns / foreign keys / indexes\n      for (const updatedColumn of table.columns.updated) {\n        debug(`Updating column ${updatedColumn.name}`);\n\n        const { object } = updatedColumn;\n\n        if (object.type === 'increments') {\n          createColumn(tableBuilder, { ...object, type: 'integer' }).alter();\n        } else {\n          createColumn(tableBuilder, object).alter();\n        }\n      }\n\n      for (const updatedForeignKey of table.foreignKeys.updated) {\n        debug(`Recreating updated foreign key ${updatedForeignKey.name}`);\n        createForeignKey(tableBuilder, updatedForeignKey.object);\n      }\n\n      for (const updatedIndex of table.indexes.updated) {\n        debug(`Recreating updated index ${updatedIndex.name}`);\n        createIndex(tableBuilder, updatedIndex.object);\n      }\n\n      for (const addedColumn of table.columns.added) {\n        debug(`Creating column ${addedColumn.name}`);\n\n        if (addedColumn.type === 'increments' && !db.dialect.canAddIncrements()) {\n          tableBuilder.integer(addedColumn.name).unsigned();\n          tableBuilder.primary([addedColumn.name]);\n        } else {\n          createColumn(tableBuilder, addedColumn);\n        }\n      }\n\n      for (const addedForeignKey of table.foreignKeys.added) {\n        debug(`Creating foreign keys ${addedForeignKey.name}`);\n        createForeignKey(tableBuilder, addedForeignKey);\n      }\n\n      for (const addedIndex of table.indexes.added) {\n        debug(`Creating index ${addedIndex.name}`);\n        createIndex(tableBuilder, addedIndex);\n      }\n    });\n  };\n\n  /**\n   * Drops a table from a database\n   */\n  const dropTable = (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\n    if (!db.config.settings.forceMigration) {\n      return;\n    }\n\n    return schemaBuilder.dropTableIfExists(table.name);\n  };\n\n  /**\n   * Creates a table foreign keys constraints\n   */\n  const createTableForeignKeys = async (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\n    // foreign keys\n    await schemaBuilder.table(table.name, (tableBuilder) => {\n      (table.foreignKeys || []).forEach((foreignKey) => createForeignKey(tableBuilder, foreignKey));\n    });\n  };\n\n  /**\n   * Drops a table foreign keys constraints\n   */\n  const dropTableForeignKeys = async (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\n    if (!db.config.settings.forceMigration) {\n      return;\n    }\n\n    // foreign keys\n    await schemaBuilder.table(table.name, (tableBuilder) => {\n      (table.foreignKeys || []).forEach((foreignKey) => dropForeignKey(tableBuilder, foreignKey));\n    });\n  };\n\n  return {\n    createTable,\n    alterTable,\n    dropTable,\n    createTableForeignKeys,\n    dropTableForeignKeys,\n  };\n};\n","import _ from 'lodash/fp';\nimport type {\n  Schema,\n  Table,\n  SchemaDiff,\n  Index,\n  ForeignKey,\n  Column,\n  IndexDiff,\n  IndexesDiff,\n  ForeignKeyDiff,\n  ForeignKeysDiff,\n  ColumnDiff,\n  TableDiff,\n  ColumnsDiff,\n} from './types';\nimport type { Database } from '..';\n\nconst RESERVED_TABLE_NAMES = ['strapi_migrations', 'strapi_database_schema'];\n\nconst statuses = {\n  CHANGED: 'CHANGED',\n  UNCHANGED: 'UNCHANGED',\n} as const;\n\n// NOTE:We could move the schema to use maps of tables & columns instead of arrays to make it easier to diff\n// => this will make the creation a bit more complicated (ordering, Object.values(tables | columns)) -> not a big pbl\n\nconst helpers = {\n  hasTable(schema: Schema, tableName: string) {\n    return schema.tables.findIndex((table) => table.name === tableName) !== -1;\n  },\n  findTable(schema: Schema, tableName: string) {\n    return schema.tables.find((table) => table.name === tableName);\n  },\n  hasColumn(table: Table, columnName: string) {\n    return table.columns.findIndex((column) => column.name === columnName) !== -1;\n  },\n  findColumn(table: Table, columnName: string) {\n    return table.columns.find((column) => column.name === columnName);\n  },\n\n  hasIndex(table: Table, columnName: string) {\n    return table.indexes.findIndex((column) => column.name === columnName) !== -1;\n  },\n  findIndex(table: Table, columnName: string) {\n    return table.indexes.find((column) => column.name === columnName);\n  },\n\n  hasForeignKey(table: Table, columnName: string) {\n    return table.foreignKeys.findIndex((column) => column.name === columnName) !== -1;\n  },\n  findForeignKey(table: Table, columnName: string) {\n    return table.foreignKeys.find((column) => column.name === columnName);\n  },\n};\n\nexport default (db: Database) => {\n  const hasChangedStatus = (diff: { status: 'CHANGED' | 'UNCHANGED' }) =>\n    diff.status === statuses.CHANGED;\n\n  /**\n   * Compares two indexes info\n   * @param {Object} oldIndex - index info read from DB\n   * @param {Object} index - newly generate index info\n   */\n  const diffIndexes = (oldIndex: Index, index: Index): IndexDiff => {\n    const changes = [];\n\n    if (!_.isEqual(oldIndex.columns, index.columns)) {\n      changes.push('columns');\n    }\n\n    if (oldIndex.type && index.type && _.toLower(oldIndex.type) !== _.toLower(index.type)) {\n      changes.push('type');\n    }\n\n    return {\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: index.name,\n        object: index,\n      },\n    };\n  };\n\n  /**\n   * Compares two foreign keys info\n   * @param {Object} oldForeignKey - foreignKey info read from DB\n   * @param {Object} foreignKey - newly generate foreignKey info\n   */\n  const diffForeignKeys = (oldForeignKey: ForeignKey, foreignKey: ForeignKey): ForeignKeyDiff => {\n    const changes = [];\n\n    if (_.difference(oldForeignKey.columns, foreignKey.columns).length > 0) {\n      changes.push('columns');\n    }\n\n    if (_.difference(oldForeignKey.referencedColumns, foreignKey.referencedColumns).length > 0) {\n      changes.push('referencedColumns');\n    }\n\n    if (oldForeignKey.referencedTable !== foreignKey.referencedTable) {\n      changes.push('referencedTable');\n    }\n\n    if (_.isNil(oldForeignKey.onDelete) || _.toUpper(oldForeignKey.onDelete) === 'NO ACTION') {\n      if (\n        !_.isNil(foreignKey.onDelete) &&\n        _.toUpper(oldForeignKey.onDelete ?? '') !== 'NO ACTION'\n      ) {\n        changes.push('onDelete');\n      }\n    } else if (_.toUpper(oldForeignKey.onDelete) !== _.toUpper(foreignKey.onDelete ?? '')) {\n      changes.push('onDelete');\n    }\n\n    if (_.isNil(oldForeignKey.onUpdate) || _.toUpper(oldForeignKey.onUpdate) === 'NO ACTION') {\n      if (\n        !_.isNil(foreignKey.onUpdate) &&\n        _.toUpper(oldForeignKey.onUpdate ?? '') !== 'NO ACTION'\n      ) {\n        changes.push('onUpdate');\n      }\n    } else if (_.toUpper(oldForeignKey.onUpdate) !== _.toUpper(foreignKey.onUpdate ?? '')) {\n      changes.push('onUpdate');\n    }\n\n    return {\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: foreignKey.name,\n        object: foreignKey,\n      },\n    };\n  };\n\n  const diffDefault = (oldColumn: Column, column: Column) => {\n    const oldDefaultTo = oldColumn.defaultTo;\n    const { defaultTo } = column;\n\n    if (oldDefaultTo === null || _.toLower(oldDefaultTo) === 'null') {\n      return _.isNil(defaultTo) || _.toLower(defaultTo) === 'null';\n    }\n\n    return (\n      _.toLower(oldDefaultTo) === _.toLower(column.defaultTo) ||\n      _.toLower(oldDefaultTo) === _.toLower(`'${column.defaultTo}'`)\n    );\n  };\n\n  /**\n   * Compares two columns info\n   * @param {Object} oldColumn - column info read from DB\n   * @param {Object} column - newly generate column info\n   */\n  const diffColumns = (oldColumn: Column, column: Column): ColumnDiff => {\n    const changes = [];\n\n    const isIgnoredType = ['increments'].includes(column.type);\n    const oldType = oldColumn.type;\n    const type = db.dialect.getSqlType(column.type);\n\n    if (oldType !== type && !isIgnoredType) {\n      changes.push('type');\n    }\n\n    // NOTE: compare args at some point and split them into specific properties instead\n\n    if (oldColumn.notNullable !== column.notNullable) {\n      changes.push('notNullable');\n    }\n\n    const hasSameDefault = diffDefault(oldColumn, column);\n    if (!hasSameDefault) {\n      changes.push('defaultTo');\n    }\n\n    if (oldColumn.unsigned !== column.unsigned && db.dialect.supportsUnsigned()) {\n      changes.push('unsigned');\n    }\n\n    return {\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: column.name,\n        object: column,\n      },\n    };\n  };\n\n  const diffTableColumns = (srcTable: Table, destTable: Table): ColumnsDiff => {\n    const addedColumns: Column[] = [];\n    const updatedColumns: ColumnDiff['diff'][] = [];\n    const unchangedColumns: Column[] = [];\n    const removedColumns: Column[] = [];\n\n    for (const destColumn of destTable.columns) {\n      const srcColumn = helpers.findColumn(srcTable, destColumn.name);\n      if (srcColumn) {\n        const { status, diff } = diffColumns(srcColumn, destColumn);\n\n        if (status === statuses.CHANGED) {\n          updatedColumns.push(diff);\n        } else {\n          unchangedColumns.push(srcColumn);\n        }\n      } else {\n        addedColumns.push(destColumn);\n      }\n    }\n\n    for (const srcColumn of srcTable.columns) {\n      if (!helpers.hasColumn(destTable, srcColumn.name)) {\n        removedColumns.push(srcColumn);\n      }\n    }\n\n    const hasChanged = [addedColumns, updatedColumns, removedColumns].some((arr) => arr.length > 0);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        added: addedColumns,\n        updated: updatedColumns,\n        unchanged: unchangedColumns,\n        removed: removedColumns,\n      },\n    };\n  };\n\n  const diffTableIndexes = (srcTable: Table, destTable: Table): IndexesDiff => {\n    const addedIndexes: Index[] = [];\n    const updatedIndexes: IndexDiff['diff'][] = [];\n    const unchangedIndexes: Index[] = [];\n    const removedIndexes: Index[] = [];\n\n    for (const destIndex of destTable.indexes) {\n      const srcIndex = helpers.findIndex(srcTable, destIndex.name);\n      if (srcIndex) {\n        const { status, diff } = diffIndexes(srcIndex, destIndex);\n\n        if (status === statuses.CHANGED) {\n          updatedIndexes.push(diff);\n        } else {\n          unchangedIndexes.push(srcIndex);\n        }\n      } else {\n        addedIndexes.push(destIndex);\n      }\n    }\n\n    for (const srcIndex of srcTable.indexes) {\n      if (!helpers.hasIndex(destTable, srcIndex.name)) {\n        removedIndexes.push(srcIndex);\n      }\n    }\n\n    const hasChanged = [addedIndexes, updatedIndexes, removedIndexes].some((arr) => arr.length > 0);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        added: addedIndexes,\n        updated: updatedIndexes,\n        unchanged: unchangedIndexes,\n        removed: removedIndexes,\n      },\n    };\n  };\n\n  const diffTableForeignKeys = (srcTable: Table, destTable: Table): ForeignKeysDiff => {\n    const addedForeignKeys: ForeignKey[] = [];\n    const updatedForeignKeys: ForeignKeyDiff['diff'][] = [];\n    const unchangedForeignKeys: ForeignKey[] = [];\n    const removedForeignKeys: ForeignKey[] = [];\n\n    if (!db.dialect.usesForeignKeys()) {\n      return {\n        status: statuses.UNCHANGED,\n        diff: {\n          added: addedForeignKeys,\n          updated: updatedForeignKeys,\n          unchanged: unchangedForeignKeys,\n          removed: removedForeignKeys,\n        },\n      };\n    }\n\n    for (const destForeignKey of destTable.foreignKeys) {\n      const srcForeignKey = helpers.findForeignKey(srcTable, destForeignKey.name);\n      if (srcForeignKey) {\n        const { status, diff } = diffForeignKeys(srcForeignKey, destForeignKey);\n\n        if (status === statuses.CHANGED) {\n          updatedForeignKeys.push(diff);\n        } else {\n          unchangedForeignKeys.push(srcForeignKey);\n        }\n      } else {\n        addedForeignKeys.push(destForeignKey);\n      }\n    }\n\n    for (const srcForeignKey of srcTable.foreignKeys) {\n      if (!helpers.hasForeignKey(destTable, srcForeignKey.name)) {\n        removedForeignKeys.push(srcForeignKey);\n      }\n    }\n\n    const hasChanged = [addedForeignKeys, updatedForeignKeys, removedForeignKeys].some(\n      (arr) => arr.length > 0\n    );\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        added: addedForeignKeys,\n        updated: updatedForeignKeys,\n        unchanged: unchangedForeignKeys,\n        removed: removedForeignKeys,\n      },\n    };\n  };\n\n  const diffTables = (srcTable: Table, destTable: Table): TableDiff => {\n    const columnsDiff = diffTableColumns(srcTable, destTable);\n    const indexesDiff = diffTableIndexes(srcTable, destTable);\n    const foreignKeysDiff = diffTableForeignKeys(srcTable, destTable);\n\n    const hasChanged = [columnsDiff, indexesDiff, foreignKeysDiff].some(hasChangedStatus);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        name: srcTable.name,\n        indexes: indexesDiff.diff,\n        foreignKeys: foreignKeysDiff.diff,\n        columns: columnsDiff.diff,\n      },\n    };\n  };\n\n  const diffSchemas = async (srcSchema: Schema, destSchema: Schema): Promise<SchemaDiff> => {\n    const addedTables: Table[] = [];\n    const updatedTables: TableDiff['diff'][] = [];\n    const unchangedTables: Table[] = [];\n    const removedTables = [];\n\n    for (const destTable of destSchema.tables) {\n      const srcTable = helpers.findTable(srcSchema, destTable.name);\n      if (srcTable) {\n        const { status, diff } = diffTables(srcTable, destTable);\n\n        if (status === statuses.CHANGED) {\n          updatedTables.push(diff);\n        } else {\n          unchangedTables.push(srcTable);\n        }\n      } else {\n        addedTables.push(destTable);\n      }\n    }\n\n    const parsePersistedTable = (persistedTable: string | Table) => {\n      if (typeof persistedTable === 'string') {\n        return persistedTable;\n      }\n      return persistedTable.name;\n    };\n\n    const persistedTables = helpers.hasTable(srcSchema, 'strapi_core_store_settings')\n      ? (await strapi.store.get({\n          type: 'core',\n          key: 'persisted_tables',\n        })) ?? []\n      : [];\n\n    const reservedTables = [...RESERVED_TABLE_NAMES, ...persistedTables.map(parsePersistedTable)];\n\n    type PersistedTable = {\n      name: string;\n      dependsOn?: Array<{ name: string }>;\n    };\n\n    for (const srcTable of srcSchema.tables) {\n      if (!helpers.hasTable(destSchema, srcTable.name) && !reservedTables.includes(srcTable.name)) {\n        const dependencies = persistedTables\n          .filter((table: PersistedTable) => {\n            const dependsOn = table?.dependsOn;\n\n            if (!_.isArray(dependsOn)) {\n              return;\n            }\n\n            return dependsOn.some((table) => table.name === srcTable.name);\n          })\n          .map((dependsOnTable: PersistedTable) => {\n            return srcSchema.tables.find((srcTable) => srcTable.name === dependsOnTable.name);\n          })\n          // In case the table is not found, filter undefined values\n          .filter((table: PersistedTable) => !_.isNil(table));\n\n        removedTables.push(srcTable, ...dependencies);\n      }\n    }\n\n    const hasChanged = [addedTables, updatedTables, removedTables].some((arr) => arr.length > 0);\n\n    return {\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\n      diff: {\n        tables: {\n          added: addedTables,\n          updated: updatedTables,\n          unchanged: unchangedTables,\n          removed: removedTables,\n        },\n      },\n    };\n  };\n\n  return {\n    diff: diffSchemas,\n  };\n};\n","import crypto from 'crypto';\n\nimport type { Database } from '..';\nimport type { Schema } from './types';\n\nconst TABLE_NAME = 'strapi_database_schema';\n\nexport default (db: Database) => {\n  const hasSchemaTable = () => db.getSchemaConnection().hasTable(TABLE_NAME);\n\n  const createSchemaTable = () => {\n    return db.getSchemaConnection().createTable(TABLE_NAME, (t) => {\n      t.increments('id');\n      t.json('schema');\n      t.datetime('time', { useTz: false });\n      t.string('hash');\n    });\n  };\n\n  const checkTableExists = async () => {\n    if (!(await hasSchemaTable())) {\n      await createSchemaTable();\n    }\n  };\n\n  return {\n    async read() {\n      await checkTableExists();\n\n      const res = await db\n        .getConnection()\n        .select('*')\n        .from(TABLE_NAME)\n        .orderBy('time', 'DESC')\n        .first();\n\n      if (!res) {\n        return null;\n      }\n\n      const parsedSchema = typeof res.schema === 'object' ? res.schema : JSON.parse(res.schema);\n\n      return {\n        ...res,\n        schema: parsedSchema,\n      };\n    },\n\n    hashSchema(schema: Schema) {\n      return crypto.createHash('md5').update(JSON.stringify(schema)).digest('hex');\n    },\n\n    async add(schema: Schema) {\n      await checkTableExists();\n\n      // NOTE: we can remove this to add history\n      await db.getConnection(TABLE_NAME).delete();\n\n      const time = new Date();\n\n      await db\n        .getConnection()\n        .insert({\n          schema: JSON.stringify(schema),\n          hash: this.hashSchema(schema),\n          time,\n        })\n        .into(TABLE_NAME);\n    },\n\n    async clear() {\n      await checkTableExists();\n\n      await db.getConnection(TABLE_NAME).truncate();\n    },\n  };\n};\n","import type { Attribute, ScalarAttribute, RelationalAttribute } from '../types';\n\nconst SCALAR_TYPES = [\n  'increments',\n  'password',\n  'email',\n  'string',\n  'uid',\n  'richtext',\n  'text',\n  'json',\n  'enumeration',\n  'integer',\n  'biginteger',\n  'float',\n  'decimal',\n  'date',\n  'time',\n  'datetime',\n  'timestamp',\n  'boolean',\n  'blocks',\n];\n\nconst STRING_TYPES = ['string', 'text', 'uid', 'email', 'enumeration', 'richtext'];\nconst NUMBER_TYPES = ['biginteger', 'integer', 'decimal', 'float'];\n\nexport const isString = (type: string) => STRING_TYPES.includes(type);\nexport const isNumber = (type: string) => NUMBER_TYPES.includes(type);\nexport const isScalar = (type: string) => SCALAR_TYPES.includes(type);\nexport const isComponent = (type: string) => type === 'component';\nexport const isDynamicZone = (type: string) => type === 'dynamiczone';\nexport const isRelation = (type: string) => type === 'relation';\nexport const isScalarAttribute = (attribute: Attribute): attribute is ScalarAttribute =>\n  isScalar(attribute.type);\nexport const isRelationalAttribute = (attribute: Attribute): attribute is RelationalAttribute =>\n  isRelation(attribute.type);\n","import * as types from '../utils/types';\n\nimport type { Metadata, Meta } from '../metadata';\nimport type { Column, Schema, Table } from './types';\nimport type { Attribute } from '../types';\n\nconst createColumn = (name: string, attribute: Attribute): Column => {\n  const { type, args = [], ...opts } = getColumnType(attribute);\n\n  return {\n    name,\n    type,\n    args,\n    defaultTo: null,\n    notNullable: false,\n    unsigned: false,\n    ...opts,\n    ...('column' in attribute ? attribute.column ?? {} : {}),\n  };\n};\n\nconst createTable = (meta: Meta): Table => {\n  const table: Table = {\n    name: meta.tableName,\n    indexes: meta.indexes || [],\n    foreignKeys: meta.foreignKeys || [],\n    columns: [],\n  };\n\n  for (const key of Object.keys(meta.attributes)) {\n    const attribute = meta.attributes[key];\n\n    // if (types.isRelation(attribute.type)) {\n    if (attribute.type === 'relation') {\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\n        const { idColumn, typeColumn } = attribute.morphColumn;\n\n        table.columns.push(\n          createColumn(idColumn.name, {\n            type: 'integer',\n            column: {\n              unsigned: true,\n            },\n          })\n        );\n\n        table.columns.push(createColumn(typeColumn.name, { type: 'string' }));\n      } else if (\n        'joinColumn' in attribute &&\n        attribute.joinColumn &&\n        attribute.owner &&\n        attribute.joinColumn.referencedTable\n      ) {\n        // NOTE: we could pass uniquness for oneToOne to avoid creating more than one to one\n\n        const { name: columnName, referencedColumn, referencedTable } = attribute.joinColumn;\n\n        const column = createColumn(columnName, {\n          type: 'integer',\n          column: {\n            unsigned: true,\n          },\n        });\n\n        table.columns.push(column);\n\n        table.foreignKeys.push({\n          name: `${table.name}_${columnName}_fk`,\n          columns: [columnName],\n          referencedTable,\n          referencedColumns: [referencedColumn],\n          // NOTE: could allow configuration\n          onDelete: 'SET NULL',\n        });\n\n        table.indexes.push({\n          name: `${table.name}_${columnName}_fk`,\n          columns: [columnName],\n        });\n      }\n    } else if (types.isScalarAttribute(attribute)) {\n      const column = createColumn(attribute.columnName || key, attribute);\n\n      if (column.unique) {\n        table.indexes.push({\n          type: 'unique',\n          name: `${table.name}_${column.name}_unique`,\n          columns: [column.name],\n        });\n      }\n\n      if (column.primary) {\n        table.indexes.push({\n          type: 'primary',\n          name: `${table.name}_${column.name}_primary`,\n          columns: [column.name],\n        });\n      }\n\n      table.columns.push(column);\n    }\n  }\n\n  return table;\n};\n\nconst getColumnType = (attribute: Attribute) => {\n  if ('columnType' in attribute && attribute.columnType) {\n    return attribute.columnType;\n  }\n\n  switch (attribute.type) {\n    case 'increments': {\n      return {\n        type: 'increments',\n        args: [{ primary: true, primaryKey: true }],\n        notNullable: true,\n      };\n    }\n\n    // We might want to convert email/password to string types before going into the orm with specific validators & transformers\n    case 'password':\n    case 'email':\n    case 'string':\n    case 'enumeration': {\n      return { type: 'string' };\n    }\n    case 'uid': {\n      return {\n        type: 'string',\n        unique: true,\n      };\n    }\n    case 'richtext':\n    case 'text': {\n      return {\n        type: 'text',\n        args: ['longtext'],\n      };\n    }\n    case 'blocks':\n    case 'json': {\n      return { type: 'jsonb' };\n    }\n    case 'integer': {\n      return { type: 'integer' };\n    }\n    case 'biginteger': {\n      return { type: 'bigInteger' };\n    }\n    case 'float': {\n      return { type: 'double' };\n    }\n    case 'decimal': {\n      return { type: 'decimal', args: [10, 2] };\n    }\n    case 'date': {\n      return { type: 'date' };\n    }\n    case 'time': {\n      return { type: 'time', args: [{ precision: 3 }] };\n    }\n    case 'datetime': {\n      return {\n        type: 'datetime',\n        args: [\n          {\n            useTz: false,\n            precision: 6,\n          },\n        ],\n      };\n    }\n    case 'timestamp': {\n      return {\n        type: 'timestamp',\n        args: [\n          {\n            useTz: false,\n            precision: 6,\n          },\n        ],\n      };\n    }\n    case 'boolean': {\n      return { type: 'boolean' };\n    }\n    default: {\n      throw new Error(`Unknown type ${attribute.type}`);\n    }\n  }\n};\n\nexport const metadataToSchema = (metadata: Metadata): Schema => {\n  const schema: Schema = {\n    tables: [],\n  };\n\n  metadata.forEach((metadata) => {\n    schema.tables.push(createTable(metadata));\n  });\n\n  return schema;\n};\n","import createDebug from 'debug';\n\nimport createSchemaBuilder from './builder';\nimport createSchemaDiff from './diff';\nimport createSchemaStorage from './storage';\nimport { metadataToSchema } from './schema';\n\nimport type { Database } from '..';\n\nexport type * from './types';\n\nconst debug = createDebug('strapi::database');\n\nexport interface SchemaProvider {\n  builder: ReturnType<typeof createSchemaBuilder>;\n  schemaDiff: ReturnType<typeof createSchemaDiff>;\n  schemaStorage: ReturnType<typeof createSchemaStorage>;\n  sync(): Promise<void>;\n  syncSchema(): Promise<void>;\n  reset(): Promise<void>;\n  create(): Promise<void>;\n  drop(): Promise<void>;\n}\n\n/**\n * @type {import('.').default}\n */\nexport const createSchemaProvider = (db: Database): SchemaProvider => {\n  const schema = metadataToSchema(db.metadata);\n\n  return {\n    builder: createSchemaBuilder(db),\n    schemaDiff: createSchemaDiff(db),\n    schemaStorage: createSchemaStorage(db),\n\n    /**\n     * Drops the database schema\n     */\n    async drop() {\n      debug('Dropping database schema');\n\n      const DBSchema = await db.dialect.schemaInspector.getSchema();\n      await this.builder.dropSchema(DBSchema);\n    },\n\n    /**\n     * Creates the database schema\n     */\n    async create() {\n      debug('Created database schema');\n      await this.builder.createSchema(schema);\n    },\n\n    /**\n     * Resets the database schema\n     */\n    async reset() {\n      debug('Resetting database schema');\n      await this.drop();\n      await this.create();\n    },\n\n    async syncSchema() {\n      debug('Synchronizing database schema');\n\n      const DBSchema = await db.dialect.schemaInspector.getSchema();\n\n      const { status, diff } = await this.schemaDiff.diff(DBSchema, schema);\n\n      if (status === 'CHANGED') {\n        await this.builder.updateSchema(diff);\n      }\n\n      await this.schemaStorage.add(schema);\n    },\n\n    // TODO: support options to migrate softly or forcefully\n    // TODO: support option to disable auto migration & run a CLI command instead to avoid doing it at startup\n    // TODO: Allow keeping extra indexes / extra tables / extra columns (globally or on a per table basis)\n    async sync() {\n      if (await db.migrations.shouldRun()) {\n        debug('Found migrations to run');\n        await db.migrations.up();\n\n        return this.syncSchema();\n      }\n\n      const oldSchema = await this.schemaStorage.read();\n\n      if (!oldSchema) {\n        debug('Schema not persisted yet');\n        return this.syncSchema();\n      }\n\n      const { hash: oldHash } = oldSchema;\n      const hash = await this.schemaStorage.hashSchema(schema);\n\n      if (oldHash !== hash) {\n        debug('Schema changed');\n\n        return this.syncSchema();\n      }\n\n      debug('Schema unchanged');\n    },\n  };\n};\n","import _ from 'lodash/fp';\n\nimport type { Meta, Metadata } from './metadata';\nimport type { RelationalAttribute, Relation, MorphJoinTable } from '../types';\n\ninterface JoinColumnOptions {\n  attribute: (Relation.OneToOne | Relation.ManyToOne) & Relation.Owner;\n  attributeName: string;\n  meta: Meta;\n}\n\ninterface JoinTableOptions {\n  attribute: RelationalAttribute & Relation.WithTarget & Relation.Bidirectional;\n  attributeName: string;\n  meta: Meta;\n}\n\nconst hasInversedBy = (\n  attr: RelationalAttribute\n): attr is RelationalAttribute & { inversedBy: boolean } => 'inversedBy' in attr;\nconst hasMappedBy = (\n  attr: RelationalAttribute\n): attr is RelationalAttribute & { inversedBy: boolean } => 'mappedBy' in attr;\n\nexport const isPolymorphic = (attribute: RelationalAttribute): attribute is Relation.Morph =>\n  ['morphOne', 'morphMany', 'morphToOne', 'morphToMany'].includes(attribute.relation);\n\nexport const isOneToAny = (\n  attribute: RelationalAttribute\n): attribute is Relation.OneToOne | Relation.OneToMany =>\n  ['oneToOne', 'oneToMany'].includes(attribute.relation);\n\nexport const isManyToAny = (\n  attribute: RelationalAttribute\n): attribute is Relation.ManyToOne | Relation.ManyToMany =>\n  ['manyToMany', 'manyToOne'].includes(attribute.relation);\n\nexport const isAnyToOne = (\n  attribute: RelationalAttribute\n): attribute is Relation.OneToOne | Relation.ManyToOne =>\n  ['oneToOne', 'manyToOne'].includes(attribute.relation);\n\nexport const isAnyToMany = (\n  attribute: RelationalAttribute\n): attribute is Relation.OneToMany | Relation.ManyToMany =>\n  ['oneToMany', 'manyToMany'].includes(attribute.relation);\n\nexport const isBidirectional = (\n  attribute: RelationalAttribute\n): attribute is Relation.Bidirectional => hasInversedBy(attribute) || hasMappedBy(attribute);\n\nconst isOwner = (\n  attribute: RelationalAttribute\n): attribute is RelationalAttribute & Relation.Owner =>\n  !isBidirectional(attribute) || hasInversedBy(attribute);\n\nconst shouldUseJoinTable = (attribute: RelationalAttribute) =>\n  !('useJoinTable' in attribute) || attribute.useJoinTable !== false;\n\nexport const getJoinTableName = (tableName: string, attributeName: string) =>\n  _.snakeCase(`${tableName}_${attributeName}_links`);\n\nexport const hasOrderColumn = (attribute: RelationalAttribute) => isAnyToMany(attribute);\nexport const hasInverseOrderColumn = (attribute: RelationalAttribute) =>\n  isBidirectional(attribute) && isManyToAny(attribute);\n\n/**\n * Creates a oneToOne relation metadata\n *\n * if owner then\n *   if with join table then\n *     create join table\n *   else\n *     create joinColumn\n *   if bidirectional then\n *     set inverse attribute joinCol or joinTable info correctly\n * else\n *   this property must be set by the owner side\n *   verify the owner side is valid // should be done before or at the same time ?\n */\nconst createOneToOne = (\n  attributeName: string,\n  attribute: Relation.OneToOne,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (isOwner(attribute)) {\n    if (shouldUseJoinTable(attribute)) {\n      createJoinTable(metadata, {\n        attribute,\n        attributeName,\n        meta,\n      });\n    } else {\n      createJoinColum(metadata, {\n        attribute,\n        attributeName,\n        meta,\n      });\n    }\n  } else {\n    // TODO: verify other side is valid\n  }\n};\n\n/**\n * Creates a oneToMany relation metadata\n *\n * if unidirectional then\n *   create join table\n * if bidirectional then\n *   cannot be owning side\n *   do nothing\n */\nconst createOneToMany = (\n  attributeName: string,\n  attribute: Relation.OneToMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (!isBidirectional(attribute)) {\n    createJoinTable(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  } else if (isOwner(attribute)) {\n    throw new Error('one side of a oneToMany cannot be the owner side in a bidirectional relation');\n  }\n};\n\n/**\n * Creates a manyToOne relation metadata\n *\n * if unidirectional then\n *   if with join table then\n *     create join table\n *   else\n *     create join column\n * else\n *   must be the owner side\n *   if with join table then\n *     create join table\n *   else\n *     create join column\n *   set inverse attribute joinCol or joinTable info correctly\n */\nconst createManyToOne = (\n  attributeName: string,\n  attribute: Relation.ManyToOne,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (isBidirectional(attribute) && !isOwner(attribute)) {\n    throw new Error('The many side of a manyToOne must be the owning side');\n  }\n\n  if (shouldUseJoinTable(attribute)) {\n    createJoinTable(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  } else {\n    createJoinColum(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  }\n};\n\n/**\n * Creates a manyToMany relation metadata\n *\n * if unidirectional\n *   create join table\n * else\n *   if owner then\n *     if with join table then\n *       create join table\n *   else\n *     do nothing\n */\nconst createManyToMany = (\n  attributeName: string,\n  attribute: Relation.ManyToMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  if (!isBidirectional(attribute) || isOwner(attribute)) {\n    createJoinTable(metadata, {\n      attribute,\n      attributeName,\n      meta,\n    });\n  }\n};\n\n/**\n * Creates a morphToOne relation metadata\n *\n * if with join table then\n *   create join table\n * else\n *  create join columnsa\n *\n * if bidirectionnal\n *  set info in the traget\n */\nconst createMorphToOne = (attributeName: string, attribute: Relation.MorphToOne) => {\n  const idColumnName = 'target_id';\n  const typeColumnName = 'target_type';\n\n  Object.assign(attribute, {\n    owner: true,\n    morphColumn: {\n      // TODO: add referenced column\n      typeColumn: {\n        name: typeColumnName,\n      },\n      idColumn: {\n        name: idColumnName,\n        referencedColumn: 'id',\n      },\n    },\n  });\n\n  // TODO: implement bidirectional\n};\n\n/**\n * Creates a morphToMany relation metadata\n */\nconst createMorphToMany = (\n  attributeName: string,\n  attribute: Relation.MorphToMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  const joinTableName = _.snakeCase(`${meta.tableName}_${attributeName}_morphs`);\n\n  const joinColumnName = _.snakeCase(`${meta.singularName}_id`);\n  const morphColumnName = _.snakeCase(`${attributeName}`);\n  const idColumnName = `${morphColumnName}_id`;\n  const typeColumnName = `${morphColumnName}_type`;\n\n  metadata.add({\n    singularName: joinTableName,\n    uid: joinTableName,\n    tableName: joinTableName,\n    attributes: {\n      id: {\n        type: 'increments',\n      },\n      [joinColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [idColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [typeColumnName]: {\n        type: 'string',\n      },\n      field: {\n        type: 'string',\n      },\n      order: {\n        type: 'float',\n        column: {\n          unsigned: true,\n        },\n      },\n    },\n    indexes: [\n      {\n        name: `${joinTableName}_fk`,\n        columns: [joinColumnName],\n      },\n      {\n        name: `${joinTableName}_order_index`,\n        columns: ['order'],\n      },\n      {\n        name: `${joinTableName}_id_column_index`,\n        columns: [idColumnName],\n      },\n    ],\n    foreignKeys: [\n      {\n        name: `${joinTableName}_fk`,\n        columns: [joinColumnName],\n        referencedColumns: ['id'],\n        referencedTable: meta.tableName,\n        onDelete: 'CASCADE',\n      },\n    ],\n    lifecycles: {},\n    columnToAttribute: {},\n  });\n\n  const joinTable: MorphJoinTable = {\n    name: joinTableName,\n    joinColumn: {\n      name: joinColumnName,\n      referencedColumn: 'id',\n    },\n    morphColumn: {\n      typeColumn: {\n        name: typeColumnName,\n      },\n      idColumn: {\n        name: idColumnName,\n        referencedColumn: 'id',\n      },\n    },\n    orderBy: {\n      order: 'asc' as const,\n    },\n    pivotColumns: [joinColumnName, typeColumnName, idColumnName],\n  };\n\n  attribute.joinTable = joinTable;\n};\n\n/**\n * Creates a morphOne relation metadata\n */\nconst createMorphOne = (\n  attributeName: string,\n  attribute: Relation.MorphOne,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Morph target not found. Looking for ${attribute.target}`);\n  }\n\n  if (attribute.morphBy && !_.has(attribute.morphBy, targetMeta.attributes)) {\n    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);\n  }\n};\n\n/**\n * Creates a morphMany relation metadata\n */\nconst createMorphMany = (\n  attributeName: string,\n  attribute: Relation.MorphMany,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Morph target not found. Looking for ${attribute.target}`);\n  }\n\n  if (attribute.morphBy && !_.has(attribute.morphBy, targetMeta.attributes)) {\n    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);\n  }\n};\n\n/**\n * Creates a join column info and add them to the attribute meta\n */\nconst createJoinColum = (metadata: Metadata, { attribute, attributeName }: JoinColumnOptions) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Unknown target ${attribute.target}`);\n  }\n\n  const joinColumnName = _.snakeCase(`${attributeName}_id`);\n  const joinColumn = {\n    name: joinColumnName,\n    referencedColumn: 'id',\n    referencedTable: targetMeta.tableName,\n  };\n\n  Object.assign(attribute, { owner: true, joinColumn });\n\n  if (isBidirectional(attribute)) {\n    const inverseAttribute = targetMeta.attributes[attribute.inversedBy];\n\n    Object.assign(inverseAttribute, {\n      joinColumn: {\n        name: joinColumn.referencedColumn,\n        referencedColumn: joinColumn.name,\n      },\n    });\n  }\n};\n\n/**\n * Creates a join table and add it to the attribute meta\n */\nconst createJoinTable = (\n  metadata: Metadata,\n  { attributeName, attribute, meta }: JoinTableOptions\n) => {\n  const targetMeta = metadata.get(attribute.target);\n\n  if (!targetMeta) {\n    throw new Error(`Unknown target ${attribute.target}`);\n  }\n\n  const joinTableName = getJoinTableName(meta.tableName, attributeName);\n\n  const joinColumnName = _.snakeCase(`${meta.singularName}_id`);\n  let inverseJoinColumnName = _.snakeCase(`${targetMeta.singularName}_id`);\n\n  // if relation is self referencing\n  if (joinColumnName === inverseJoinColumnName) {\n    inverseJoinColumnName = `inv_${inverseJoinColumnName}`;\n  }\n\n  const orderColumnName = _.snakeCase(`${targetMeta.singularName}_order`);\n  let inverseOrderColumnName = _.snakeCase(`${meta.singularName}_order`);\n\n  // if relation is self referencing\n  if (attribute.relation === 'manyToMany' && orderColumnName === inverseOrderColumnName) {\n    inverseOrderColumnName = `inv_${inverseOrderColumnName}`;\n  }\n\n  const metadataSchema: Meta = {\n    singularName: joinTableName,\n    uid: joinTableName,\n    tableName: joinTableName,\n    attributes: {\n      id: {\n        type: 'increments',\n      },\n      [joinColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [inverseJoinColumnName]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      // TODO: add extra pivot attributes -> user should use an intermediate entity\n    },\n    indexes: [\n      {\n        name: `${joinTableName}_fk`,\n        columns: [joinColumnName],\n      },\n      {\n        name: `${joinTableName}_inv_fk`,\n        columns: [inverseJoinColumnName],\n      },\n      {\n        name: `${joinTableName}_unique`,\n        columns: [joinColumnName, inverseJoinColumnName],\n        type: 'unique',\n      },\n    ],\n    foreignKeys: [\n      {\n        name: `${joinTableName}_fk`,\n        columns: [joinColumnName],\n        referencedColumns: ['id'],\n        referencedTable: meta.tableName,\n        onDelete: 'CASCADE',\n      },\n      {\n        name: `${joinTableName}_inv_fk`,\n        columns: [inverseJoinColumnName],\n        referencedColumns: ['id'],\n        referencedTable: targetMeta.tableName,\n        onDelete: 'CASCADE',\n      },\n    ],\n    lifecycles: {},\n    columnToAttribute: {},\n  };\n\n  const joinTable = {\n    name: joinTableName,\n    joinColumn: {\n      name: joinColumnName,\n      referencedColumn: 'id',\n    },\n    inverseJoinColumn: {\n      name: inverseJoinColumnName,\n      referencedColumn: 'id',\n    },\n    pivotColumns: [joinColumnName, inverseJoinColumnName],\n  } as any;\n\n  // order\n  if (isAnyToMany(attribute)) {\n    metadataSchema.attributes[orderColumnName] = {\n      type: 'float',\n      column: {\n        unsigned: true,\n        defaultTo: null,\n      },\n    };\n    metadataSchema.indexes.push({\n      name: `${joinTableName}_order_fk`,\n      columns: [orderColumnName],\n    });\n    joinTable.orderColumnName = orderColumnName;\n    joinTable.orderBy = { [orderColumnName]: 'asc' };\n  }\n\n  // inv order\n  if (isBidirectional(attribute) && isManyToAny(attribute)) {\n    metadataSchema.attributes[inverseOrderColumnName] = {\n      type: 'float',\n      column: {\n        unsigned: true,\n        defaultTo: null,\n      },\n    };\n\n    metadataSchema.indexes.push({\n      name: `${joinTableName}_order_inv_fk`,\n      columns: [inverseOrderColumnName],\n    });\n\n    joinTable.inverseOrderColumnName = inverseOrderColumnName;\n  }\n\n  metadata.add(metadataSchema);\n\n  attribute.joinTable = joinTable;\n\n  if (isBidirectional(attribute)) {\n    const inverseAttribute = attribute.inversedBy\n      ? (targetMeta.attributes[attribute.inversedBy] as Relation.Bidirectional)\n      : null;\n\n    if (!inverseAttribute) {\n      throw new Error(\n        `inversedBy attribute ${attribute.inversedBy} not found target ${targetMeta.uid}`\n      );\n    }\n\n    if (inverseAttribute.type !== 'relation') {\n      throw new Error(\n        `inversedBy attribute ${attribute.inversedBy} targets non relational attribute in ${targetMeta.uid}`\n      );\n    }\n\n    inverseAttribute.joinTable = {\n      name: joinTableName,\n      joinColumn: joinTable.inverseJoinColumn,\n      inverseJoinColumn: joinTable.joinColumn,\n      pivotColumns: joinTable.pivotColumns,\n    } as any;\n\n    if (isManyToAny(attribute)) {\n      inverseAttribute.joinTable.orderColumnName = inverseOrderColumnName;\n      inverseAttribute.joinTable.orderBy = { [inverseOrderColumnName]: 'asc' };\n    }\n    if (isAnyToMany(attribute)) {\n      inverseAttribute.joinTable.inverseOrderColumnName = orderColumnName;\n    }\n  }\n};\n\n/**\n * Creates a relation metadata\n */\nexport const createRelation = (\n  attributeName: string,\n  attribute: RelationalAttribute,\n  meta: Meta,\n  metadata: Metadata\n) => {\n  switch (attribute.relation) {\n    case 'oneToOne':\n      return createOneToOne(attributeName, attribute, meta, metadata);\n    case 'oneToMany':\n      return createOneToMany(attributeName, attribute, meta, metadata);\n    case 'manyToOne':\n      return createManyToOne(attributeName, attribute, meta, metadata);\n    case 'manyToMany':\n      return createManyToMany(attributeName, attribute, meta, metadata);\n    case 'morphToOne':\n      return createMorphToOne(attributeName, attribute);\n    case 'morphToMany':\n      return createMorphToMany(attributeName, attribute, meta, metadata);\n    case 'morphOne':\n      return createMorphOne(attributeName, attribute, meta, metadata);\n    case 'morphMany':\n      return createMorphMany(attributeName, attribute, meta, metadata);\n    default: {\n      throw new Error(`Unknown relation`);\n    }\n  }\n};\n","import type { Model } from '../types';\nimport type { ForeignKey, Index } from '../schema/types';\nimport type { Action, SubscriberFn } from '../lifecycles';\n\nexport interface ComponentLinkMeta extends Meta {\n  componentLink: Meta;\n}\n\nexport interface Meta extends Model {\n  columnToAttribute: Record<string, string>;\n  componentLink?: Meta;\n  indexes: Index[];\n  foreignKeys: ForeignKey[];\n  lifecycles: Partial<Record<Action, SubscriberFn>>;\n}\n\nexport class Metadata extends Map<string, Meta> {\n  get(key: string): Meta {\n    if (!super.has(key)) {\n      throw new Error(`Metadata for \"${key}\" not found`);\n    }\n\n    return super.get(key) as Meta;\n  }\n\n  add(meta: Meta) {\n    return this.set(meta.uid, meta);\n  }\n\n  /**\n   * Validate the DB metadata, throwing an error if a duplicate DB table name is detected\n   */\n  validate() {\n    const seenTables = new Map();\n    for (const meta of this.values()) {\n      if (seenTables.get(meta.tableName)) {\n        throw new Error(\n          `DB table \"${meta.tableName}\" already exists. Change the collectionName of the related content type.`\n        );\n      }\n      seenTables.set(meta.tableName, true);\n    }\n  }\n}\n","import _ from 'lodash/fp';\n\nimport * as types from '../utils/types';\nimport {\n  createRelation,\n  getJoinTableName,\n  isPolymorphic,\n  isBidirectional,\n  isAnyToOne,\n  isOneToAny,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n  isManyToAny,\n} from './relations';\nimport { Metadata, Meta, ComponentLinkMeta } from './metadata';\nimport type { Attribute, Model, Relation } from '../types';\n\nexport type { Metadata, Meta };\nexport {\n  getJoinTableName,\n  isPolymorphic,\n  isBidirectional,\n  isAnyToOne,\n  isOneToAny,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n  isManyToAny,\n};\n\n// TODO: check if there isn't an attribute with an id already\n/**\n * Create Metadata from models configurations\n */\nexport const createMetadata = (models: Model[] = []): Metadata => {\n  const metadata = new Metadata();\n\n  // init pass\n  for (const model of _.cloneDeep(models)) {\n    if ('id' in model.attributes) {\n      throw new Error('The attribute \"id\" is reserved and cannot be used in a model');\n    }\n\n    metadata.add({\n      ...model,\n      attributes: {\n        id: {\n          type: 'increments',\n        },\n        ...model.attributes,\n      },\n      lifecycles: model.lifecycles ?? {},\n      indexes: model.indexes || [],\n      foreignKeys: model.foreignKeys || [],\n      columnToAttribute: {},\n    });\n  }\n\n  // build compos / relations\n  for (const meta of metadata.values()) {\n    if (hasComponentsOrDz(meta)) {\n      const compoLinkModelMeta = createCompoLinkModelMeta(meta);\n      meta.componentLink = compoLinkModelMeta;\n      metadata.add(compoLinkModelMeta);\n    }\n\n    for (const [attributeName, attribute] of Object.entries(meta.attributes)) {\n      try {\n        if (types.isComponent(attribute.type) && hasComponentsOrDz(meta)) {\n          createComponent(attributeName, attribute, meta);\n          continue;\n        }\n\n        if (types.isDynamicZone(attribute.type) && hasComponentsOrDz(meta)) {\n          createDynamicZone(attributeName, attribute, meta);\n          continue;\n        }\n\n        if (types.isRelationalAttribute(attribute)) {\n          createRelation(attributeName, attribute, meta, metadata);\n          continue;\n        }\n\n        createAttribute(attributeName, attribute);\n      } catch (error) {\n        console.log(error);\n        if (error instanceof Error) {\n          throw new Error(\n            `Error on attribute ${attributeName} in model ${meta.singularName}(${meta.uid}): ${error.message}`\n          );\n        }\n      }\n    }\n  }\n\n  for (const meta of metadata.values()) {\n    const columnToAttribute = Object.keys(meta.attributes).reduce((acc, key) => {\n      const attribute = meta.attributes[key];\n      if ('columnName' in attribute) {\n        return Object.assign(acc, { [attribute.columnName || key]: key });\n      }\n\n      return Object.assign(acc, { [key]: key });\n    }, {});\n\n    meta.columnToAttribute = columnToAttribute;\n  }\n\n  metadata.validate();\n  return metadata;\n};\n\nconst hasComponentsOrDz = (model: Meta): model is ComponentLinkMeta => {\n  return Object.values(model.attributes).some(\n    ({ type }) => types.isComponent(type) || types.isDynamicZone(type)\n  );\n};\n\n// NOTE: we might just move the compo logic outside this layer too at some point\nconst createCompoLinkModelMeta = (baseModelMeta: Meta): Meta => {\n  const name = `${baseModelMeta.tableName}_components`;\n\n  return {\n    // TODO: make sure there can't be any conflicts with a prefix\n    singularName: name,\n    uid: name,\n    tableName: name,\n    attributes: {\n      id: {\n        type: 'increments',\n      },\n      entity_id: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      component_id: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      component_type: {\n        type: 'string',\n      },\n      field: {\n        type: 'string',\n      },\n      order: {\n        type: 'float',\n        column: {\n          unsigned: true,\n          defaultTo: null,\n        },\n      },\n    },\n    indexes: [\n      {\n        name: `${baseModelMeta.tableName}_field_index`,\n        columns: ['field'],\n      },\n      {\n        name: `${baseModelMeta.tableName}_component_type_index`,\n        columns: ['component_type'],\n      },\n      {\n        name: `${baseModelMeta.tableName}_entity_fk`,\n        columns: ['entity_id'],\n      },\n      {\n        name: `${baseModelMeta.tableName}_unique`,\n        columns: ['entity_id', 'component_id', 'field', 'component_type'],\n        type: 'unique',\n      },\n    ],\n    foreignKeys: [\n      {\n        name: `${baseModelMeta.tableName}_entity_fk`,\n        columns: ['entity_id'],\n        referencedColumns: ['id'],\n        referencedTable: baseModelMeta.tableName,\n        onDelete: 'CASCADE',\n      },\n    ],\n    lifecycles: {},\n    columnToAttribute: {},\n  };\n};\n\nconst createDynamicZone = (\n  attributeName: string,\n  attribute: Attribute,\n  meta: ComponentLinkMeta\n) => {\n  Object.assign(attribute, {\n    type: 'relation',\n    relation: 'morphToMany',\n    // TODO: handle restrictions at some point\n    // target: attribute.components,\n    joinTable: {\n      name: meta.componentLink.tableName,\n      joinColumn: {\n        name: 'entity_id',\n        referencedColumn: 'id',\n      },\n      morphColumn: {\n        idColumn: {\n          name: 'component_id',\n          referencedColumn: 'id',\n        },\n        typeColumn: {\n          name: 'component_type',\n        },\n        typeField: '__component',\n      },\n      on: {\n        field: attributeName,\n      },\n      orderBy: {\n        order: 'asc',\n      },\n      pivotColumns: ['entity_id', 'component_id', 'field', 'component_type'],\n    },\n  } satisfies Relation.MorphToMany);\n};\n\nconst createComponent = (attributeName: string, attribute: Attribute, meta: ComponentLinkMeta) => {\n  Object.assign(attribute, {\n    type: 'relation',\n    relation: 'repeatable' in attribute && attribute.repeatable === true ? 'oneToMany' : 'oneToOne',\n    target: 'component' in attribute && attribute.component,\n    joinTable: {\n      name: meta.componentLink.tableName,\n      joinColumn: {\n        name: 'entity_id',\n        referencedColumn: 'id',\n      },\n      inverseJoinColumn: {\n        name: 'component_id',\n        referencedColumn: 'id',\n      },\n      on: {\n        field: attributeName,\n      },\n      orderColumnName: 'order',\n      orderBy: {\n        order: 'asc',\n      },\n      pivotColumns: ['entity_id', 'component_id', 'field', 'component_type'],\n    },\n  });\n};\n\nconst createAttribute = (attributeName: string, attribute: Attribute) => {\n  const columnName = _.snakeCase(attributeName);\n  Object.assign(attribute, { columnName });\n};\n","export default class Field {\n  config: unknown;\n\n  constructor(config: unknown) {\n    this.config = config;\n  }\n\n  toDB(value: unknown) {\n    return value;\n  }\n\n  fromDB(value: unknown) {\n    return value;\n  }\n}\n","import { toString } from 'lodash/fp';\nimport Field from './field';\n\nexport default class StringField extends Field {\n  toDB(value: unknown) {\n    return toString(value);\n  }\n\n  fromDB(value: unknown) {\n    return toString(value);\n  }\n}\n","import Field from './field';\n\nexport default class JSONField extends Field {\n  toDB(value: unknown) {\n    return JSON.stringify(value);\n  }\n\n  fromDB(value: unknown) {\n    try {\n      if (typeof value === 'string') {\n        return JSON.parse(value);\n      }\n    } catch (error) {\n      // Just return the value if it's not a valid JSON string\n      return value;\n    }\n    return value;\n  }\n}\n","import StringField from './string';\n\nexport default class BigIntegerField extends StringField {}\n","import { toNumber } from 'lodash/fp';\nimport Field from './field';\n\nexport default class NumberField extends Field {\n  toDB(value: unknown) {\n    const numberValue = toNumber(value);\n\n    if (Number.isNaN(numberValue)) {\n      throw new Error(`Expected a valid Number, got ${value}`);\n    }\n\n    return numberValue;\n  }\n\n  fromDB(value: unknown) {\n    return toNumber(value);\n  }\n}\n","import { padCharsEnd, isString, toString } from 'lodash/fp';\nimport * as dateFns from 'date-fns';\n\nimport { InvalidDateTimeError, InvalidDateError, InvalidTimeError } from '../../errors';\n\nconst isDate = (value: unknown): value is Date => {\n  return dateFns.isDate(value);\n};\n\nconst DATE_REGEX = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\nconst PARTIAL_DATE_REGEX = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/g;\nconst TIME_REGEX = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\n\nexport const parseDateTimeOrTimestamp = (value: unknown): Date => {\n  if (isDate(value)) {\n    return value;\n  }\n\n  try {\n    const date = dateFns.parseISO(toString(value));\n    if (dateFns.isValid(date)) {\n      return date;\n    }\n\n    const milliUnixDate = dateFns.parse(toString(value), 'T', new Date());\n    if (dateFns.isValid(milliUnixDate)) {\n      return milliUnixDate;\n    }\n\n    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);\n  } catch (error) {\n    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);\n  }\n};\n\nexport const parseDate = (value: unknown) => {\n  if (isDate(value)) {\n    return dateFns.format(value, 'yyyy-MM-dd');\n  }\n\n  const found = isString(value) ? value.match(PARTIAL_DATE_REGEX) || [] : [];\n  const extractedValue = found[0];\n\n  if (extractedValue && !DATE_REGEX.test(toString(value))) {\n    // TODO V5: throw an error when format yyyy-MM-dd is not respected\n    // throw new InvalidDateError(`Invalid format, expected yyyy-MM-dd`);\n    process.emitWarning(\n      `[deprecated] Using a date format other than YYYY-MM-DD will be removed in future versions. Date received: ${value}. Date stored: ${extractedValue}.`\n    );\n  }\n\n  if (!extractedValue) {\n    throw new InvalidDateError(`Invalid format, expected yyyy-MM-dd`);\n  }\n\n  const date = dateFns.parseISO(extractedValue);\n  if (!dateFns.isValid(date)) {\n    throw new InvalidDateError(`Invalid date`);\n  }\n\n  return extractedValue;\n};\n\nexport const parseTime = (value: unknown) => {\n  if (isDate(value)) {\n    return dateFns.format(value, 'HH:mm:ss.SSS');\n  }\n\n  if (typeof value !== 'string') {\n    throw new InvalidTimeError(`Expected a string, got a ${typeof value}`);\n  }\n\n  const result = value.match(TIME_REGEX);\n\n  if (result === null) {\n    throw new InvalidTimeError('Invalid time format, expected HH:mm:ss.SSS');\n  }\n\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\n  const fractionPart = padCharsEnd('0', 3, fraction.slice(1));\n\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\n};\n","import { parseDate } from './shared/parsers';\nimport Field from './field';\n\nexport default class DateField extends Field {\n  toDB(value: unknown) {\n    return parseDate(value);\n  }\n\n  fromDB(value: unknown) {\n    return value;\n  }\n}\n","import { parseTime } from './shared/parsers';\nimport Field from './field';\n\nexport default class TimeField extends Field {\n  toDB(value: unknown) {\n    return parseTime(value);\n  }\n\n  fromDB(value: unknown) {\n    // make sure that's a string with valid format ?\n    return value;\n  }\n}\n","import * as dateFns from 'date-fns';\n\nimport { parseDateTimeOrTimestamp } from './shared/parsers';\nimport Field from './field';\n\nexport default class DatetimeField extends Field {\n  toDB(value: unknown) {\n    return parseDateTimeOrTimestamp(value);\n  }\n\n  fromDB(value: unknown) {\n    const cast = new Date(value as any);\n    return dateFns.isValid(cast) ? cast.toISOString() : null;\n  }\n}\n","import * as dateFns from 'date-fns';\n\nimport { parseDateTimeOrTimestamp } from './shared/parsers';\nimport Field from './field';\n\nexport default class TimestampField extends Field {\n  toDB(value: unknown) {\n    return parseDateTimeOrTimestamp(value);\n  }\n\n  fromDB(value: unknown) {\n    const cast = new Date(value as any);\n    return dateFns.isValid(cast) ? dateFns.format(cast, 'T') : null;\n  }\n}\n","import { toString } from 'lodash/fp';\nimport Field from './field';\n\nfunction isStringOrNumber(value: unknown): value is string | number {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\nexport default class BooleanField extends Field {\n  toDB(value: unknown) {\n    if (typeof value === 'boolean') {\n      return value;\n    }\n\n    if (isStringOrNumber(value) && ['true', 't', '1', 1].includes(value)) {\n      return true;\n    }\n\n    if (isStringOrNumber(value) && ['false', 'f', '0', 0].includes(value)) {\n      return false;\n    }\n\n    return Boolean(value);\n  }\n\n  fromDB(value: unknown) {\n    if (typeof value === 'boolean') {\n      return value;\n    }\n\n    const strVal = toString(value);\n\n    if (strVal === '1') {\n      return true;\n    }\n    if (strVal === '0') {\n      return false;\n    }\n    return null;\n  }\n}\n","import _ from 'lodash/fp';\n\nimport Field from './field';\nimport StringField from './string';\nimport JSONField from './json';\nimport BigIntegerField from './biginteger';\nimport NumberField from './number';\nimport DateField from './date';\nimport TimeField from './time';\nimport DatetimeField from './datetime';\nimport TimestampField from './timestamp';\nimport BooleanField from './boolean';\n\nimport type { Attribute } from '../types';\n\nconst typeToFieldMap: Record<string, typeof Field> = {\n  increments: Field,\n  password: StringField,\n  email: StringField,\n  string: StringField,\n  uid: StringField,\n  richtext: StringField,\n  text: StringField,\n  enumeration: StringField,\n  json: JSONField,\n  biginteger: BigIntegerField,\n  integer: NumberField,\n  float: NumberField,\n  decimal: NumberField,\n  date: DateField,\n  time: TimeField,\n  datetime: DatetimeField,\n  timestamp: TimestampField,\n  boolean: BooleanField,\n  blocks: JSONField,\n};\n\nexport const createField = (attribute: Attribute): Field => {\n  const { type } = attribute;\n\n  if (_.has(type, typeToFieldMap)) {\n    return new typeToFieldMap[type]({});\n  }\n\n  throw new Error(`Undefined field for type ${type}`);\n};\n","import _ from 'lodash/fp';\n\nimport * as types from '../../utils/types';\nimport { createField } from '../../fields';\n\nimport type { Meta } from '../../metadata';\n\ntype Row = Record<string, unknown> | null;\nexport type Rec = Record<string, unknown> | null;\n\nconst fromSingleRow = (meta: Meta, row: Row): Rec => {\n  const { attributes } = meta;\n\n  if (_.isNil(row)) {\n    return null;\n  }\n\n  const obj: Rec = {};\n\n  for (const column in row) {\n    if (!_.has(column, meta.columnToAttribute)) {\n      continue;\n    }\n\n    const attributeName = meta.columnToAttribute[column];\n    const attribute = attributes[attributeName];\n\n    if (types.isScalar(attribute.type)) {\n      const field = createField(attribute);\n\n      const val = row[column] === null ? null : field.fromDB(row[column]);\n\n      obj[attributeName] = val;\n    }\n\n    if (types.isRelation(attribute.type)) {\n      obj[attributeName] = row[column];\n    }\n  }\n\n  return obj;\n};\n\nconst fromRow = (meta: Meta, row: Row | Row[] | undefined) => {\n  if (_.isNil(row)) {\n    return null;\n  }\n\n  if (Array.isArray(row)) {\n    return row.map((singleRow) => fromSingleRow(meta, singleRow));\n  }\n\n  return fromSingleRow(meta, row);\n};\n\nconst toSingleRow = (meta: Meta, data: Rec = {}): Row => {\n  if (_.isNil(data)) {\n    return data;\n  }\n\n  const { attributes } = meta;\n\n  for (const key of Object.keys(data)) {\n    const attribute = attributes[key];\n\n    if (\n      !attribute ||\n      !('columnName' in attribute) ||\n      !attribute.columnName ||\n      attribute.columnName === key\n    ) {\n      continue;\n    }\n\n    data[attribute.columnName] = data[key];\n    delete data[key];\n  }\n\n  return data;\n};\n\nfunction toRow<TData extends Rec | Rec[] | null>(\n  meta: Meta,\n  data: TData\n): TData extends null ? null : TData extends Rec[] ? Row[] : Rec;\nfunction toRow(meta: Meta, data: Rec | Rec[] | null): Row | Row[] | null {\n  if (_.isNil(data)) {\n    return data;\n  }\n\n  if (_.isArray(data)) {\n    return data.map((datum) => toSingleRow(meta, datum));\n  }\n\n  return toSingleRow(meta, data);\n}\n\nconst toColumnName = (meta: Meta, name: null | string) => {\n  if (!name) {\n    throw new Error('Name cannot be null');\n  }\n\n  const attribute = meta.attributes[name];\n\n  if (!attribute) {\n    return name;\n  }\n\n  return ('columnName' in attribute && attribute.columnName) || name;\n};\n\nexport { toRow, fromRow, toColumnName };\n","import _ from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport * as types from '../../utils/types';\nimport { toColumnName } from './transform';\nimport type { Ctx } from '../types';\n\nexport const applySearch = (knex: Knex.QueryBuilder, query: string, ctx: Ctx) => {\n  const { qb, uid, db } = ctx;\n  const meta = db.metadata.get(uid);\n\n  const { attributes } = meta;\n\n  const searchColumns = ['id'];\n\n  const stringColumns = Object.keys(attributes).filter((attributeName) => {\n    const attribute = attributes[attributeName];\n    return (\n      types.isScalarAttribute(attribute) &&\n      types.isString(attribute.type) &&\n      attribute.searchable !== false\n    );\n  });\n\n  searchColumns.push(...stringColumns);\n\n  if (!_.isNaN(_.toNumber(query))) {\n    const numberColumns = Object.keys(attributes).filter((attributeName) => {\n      const attribute = attributes[attributeName];\n      return (\n        types.isScalarAttribute(attribute) &&\n        types.isNumber(attribute.type) &&\n        attribute.searchable !== false\n      );\n    });\n\n    searchColumns.push(...numberColumns);\n  }\n\n  switch (db.dialect.client) {\n    case 'postgres': {\n      searchColumns.forEach((attr) => {\n        const columnName = toColumnName(meta, attr);\n        return knex.orWhereRaw(`??::text ILIKE ?`, [\n          qb.aliasColumn(columnName),\n          `%${escapeQuery(query, '*%\\\\')}%`,\n        ]);\n      });\n\n      break;\n    }\n    case 'sqlite': {\n      searchColumns.forEach((attr) => {\n        const columnName = toColumnName(meta, attr);\n        return knex.orWhereRaw(`?? LIKE ? ESCAPE '\\\\'`, [\n          qb.aliasColumn(columnName),\n          `%${escapeQuery(query, '*%\\\\')}%`,\n        ]);\n      });\n      break;\n    }\n    case 'mysql': {\n      searchColumns.forEach((attr) => {\n        const columnName = toColumnName(meta, attr);\n        return knex.orWhereRaw(`?? LIKE ?`, [\n          qb.aliasColumn(columnName),\n          `%${escapeQuery(query, '*%\\\\')}%`,\n        ]);\n      });\n      break;\n    }\n    default: {\n      // do nothing\n    }\n  }\n};\n\nconst escapeQuery = (query: string, charsToEscape: string, escapeChar = '\\\\') => {\n  return query\n    .split('')\n    .reduce(\n      (escapedQuery, char) =>\n        charsToEscape.includes(char)\n          ? `${escapedQuery}${escapeChar}${char}`\n          : `${escapedQuery}${char}`,\n      ''\n    );\n};\n","import type { Knex } from 'knex';\nimport type { Ctx } from '../types';\n\nexport interface Join {\n  method?: 'leftJoin' | 'innerJoin';\n  alias: string;\n  referencedTable: string;\n  referencedColumn: string;\n  rootColumn: string;\n  rootTable?: string;\n  on?: Record<string, any>;\n  orderBy?: Record<string, 'asc' | 'desc'>;\n}\n\ninterface JoinOptions {\n  alias: string;\n  refAlias?: string;\n  attributeName: string;\n  attribute: any;\n}\n\ninterface PivotJoinOptions {\n  alias: string;\n  refAlias?: string;\n  joinTable: any;\n  targetMeta: any;\n}\n\nconst createPivotJoin = (\n  ctx: Ctx,\n  { alias, refAlias, joinTable, targetMeta }: PivotJoinOptions\n) => {\n  const { qb } = ctx;\n  const joinAlias = qb.getAlias();\n  qb.join({\n    alias: joinAlias,\n    referencedTable: joinTable.name,\n    referencedColumn: joinTable.joinColumn.name,\n    rootColumn: joinTable.joinColumn.referencedColumn,\n    rootTable: alias,\n    on: joinTable.on,\n  });\n\n  const subAlias = refAlias || qb.getAlias();\n  qb.join({\n    alias: subAlias,\n    referencedTable: targetMeta.tableName,\n    referencedColumn: joinTable.inverseJoinColumn.referencedColumn,\n    rootColumn: joinTable.inverseJoinColumn.name,\n    rootTable: joinAlias,\n  });\n\n  return subAlias;\n};\n\nconst createJoin = (ctx: Ctx, { alias, refAlias, attributeName, attribute }: JoinOptions) => {\n  const { db, qb } = ctx;\n\n  if (attribute.type !== 'relation') {\n    throw new Error(`Cannot join on non relational field ${attributeName}`);\n  }\n\n  const targetMeta = db.metadata.get(attribute.target);\n\n  const { joinColumn } = attribute;\n\n  if (joinColumn) {\n    const subAlias = refAlias || qb.getAlias();\n    qb.join({\n      alias: subAlias,\n      referencedTable: targetMeta.tableName,\n      referencedColumn: joinColumn.referencedColumn,\n      rootColumn: joinColumn.name,\n      rootTable: alias,\n    });\n    return subAlias;\n  }\n\n  const { joinTable } = attribute;\n  if (joinTable) {\n    return createPivotJoin(ctx, { alias, refAlias, joinTable, targetMeta });\n  }\n\n  return alias;\n};\n\n// TODO: toColumnName for orderBy & on\nconst applyJoin = (qb: Knex.QueryBuilder, join: Join) => {\n  const {\n    method = 'leftJoin',\n    alias,\n    referencedTable,\n    referencedColumn,\n    rootColumn,\n    // FIXME: qb.alias can't exist here\n    rootTable, // = qb.alias\n    on,\n    orderBy,\n  } = join;\n\n  qb[method](`${referencedTable} as ${alias}`, (inner) => {\n    inner.on(`${rootTable}.${rootColumn}`, `${alias}.${referencedColumn}`);\n\n    if (on) {\n      for (const key of Object.keys(on)) {\n        inner.onVal(`${alias}.${key}`, on[key]);\n      }\n    }\n  });\n\n  if (orderBy) {\n    Object.keys(orderBy).forEach((column) => {\n      const direction = orderBy[column];\n      qb.orderBy(`${alias}.${column}`, direction);\n    });\n  }\n};\n\nconst applyJoins = (qb: Knex.QueryBuilder, joins: Join[]) => {\n  return joins.forEach((join) => applyJoin(qb, join));\n};\n\nexport { createJoin, createPivotJoin, applyJoins, applyJoin };\n","import _ from 'lodash/fp';\n\nimport * as types from '../../utils/types';\nimport { createJoin } from './join';\nimport { toColumnName } from './transform';\n\nimport type { Ctx } from '../types';\n\ntype OrderByCtx = Ctx & { alias?: string };\ntype OrderBy = string | { [key: string]: 'asc' | 'desc' } | OrderBy[];\ntype OrderByValue = { column: unknown; order?: 'asc' | 'desc' };\n\nexport const processOrderBy = (orderBy: OrderBy, ctx: OrderByCtx): OrderByValue[] => {\n  const { db, uid, qb, alias } = ctx;\n  const meta = db.metadata.get(uid);\n  const { attributes } = meta;\n\n  if (typeof orderBy === 'string') {\n    const attribute = attributes[orderBy];\n\n    if (!attribute) {\n      throw new Error(`Attribute ${orderBy} not found on model ${uid}`);\n    }\n\n    const columnName = toColumnName(meta, orderBy);\n\n    return [{ column: qb.aliasColumn(columnName, alias) }];\n  }\n\n  if (Array.isArray(orderBy)) {\n    return orderBy.flatMap((value) => processOrderBy(value, ctx));\n  }\n\n  if (_.isPlainObject(orderBy)) {\n    return Object.entries(orderBy).flatMap(([key, direction]) => {\n      const value = orderBy[key];\n      const attribute = attributes[key];\n\n      if (!attribute) {\n        throw new Error(`Attribute ${key} not found on model ${uid}`);\n      }\n\n      if (types.isScalar(attribute.type)) {\n        const columnName = toColumnName(meta, key);\n\n        return { column: qb.aliasColumn(columnName, alias), order: direction };\n      }\n\n      if (attribute.type === 'relation' && 'target' in attribute) {\n        const subAlias = createJoin(ctx, {\n          alias: alias || qb.alias,\n          attributeName: key,\n          attribute,\n        });\n\n        return processOrderBy(value, {\n          db,\n          qb,\n          alias: subAlias,\n          uid: attribute.target,\n        });\n      }\n\n      throw new Error(`You cannot order on ${attribute.type} types`);\n    });\n  }\n\n  throw new Error('Invalid orderBy syntax');\n};\n","import _ from 'lodash/fp';\n\nimport { fromRow } from '../transform';\nimport type { QueryBuilder } from '../../query-builder';\nimport type { Database } from '../../..';\nimport type { Meta } from '../../../metadata';\nimport { ID, RelationalAttribute, Relation } from '../../../types';\n\ntype Context = {\n  db: Database;\n  qb: QueryBuilder;\n  uid: string;\n};\n\ntype Input<TRelationAttribute extends RelationalAttribute = RelationalAttribute> = {\n  attribute: TRelationAttribute;\n  attributeName: string;\n  results: Row[];\n  populateValue: {\n    on?: Record<string, Record<string, unknown>>;\n  } & Record<string, unknown>;\n\n  isCount: boolean;\n};\n\ntype InputWithTarget<TRelationAttribute extends RelationalAttribute = RelationalAttribute> =\n  Input<TRelationAttribute> & {\n    targetMeta: Meta;\n  };\n\ntype MorphIdMap = Record<string, Record<ID, Row[]>>;\n\ntype Row = Record<string, unknown>;\n\n/**\n * Populate oneToOne and manyToOne relation\n * @param {*} input\n * @param {*} ctx\n * @returns\n */\nconst XtoOne = async (\n  input: InputWithTarget<Relation.OneToOne | Relation.ManyToOne>,\n  ctx: Context\n) => {\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\n  const { db, qb } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  if ('joinColumn' in attribute && attribute.joinColumn) {\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = attribute.joinColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[joinColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n\n      return;\n    }\n\n    const rows = await db.entityManager\n      .createQueryBuilder(targetMeta.uid)\n      .init(populateValue)\n      .addSelect(`${qb.alias}.${referencedColumnName}`)\n      .where({ [referencedColumnName]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row[]>(referencedColumnName)(rows);\n\n    results.forEach((result) => {\n      result[attributeName] = fromTargetRow(_.first(map[result[joinColumnName] as string]));\n    });\n\n    return;\n  }\n\n  if ('joinTable' in attribute && attribute.joinTable) {\n    const { joinTable } = attribute;\n\n    const qb = db.entityManager.createQueryBuilder(targetMeta.uid);\n\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\n\n    const alias = qb.getAlias();\n    const joinColAlias = `${alias}.${joinColumnName}`;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (isCount) {\n      if (_.isEmpty(referencedValues)) {\n        results.forEach((result) => {\n          result[attributeName] = { count: 0 };\n        });\n        return;\n      }\n\n      const rows = await qb\n        .init(populateValue)\n        .join({\n          alias,\n          referencedTable: joinTable.name,\n          referencedColumn: joinTable.inverseJoinColumn.name,\n          rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n          rootTable: qb.alias,\n          on: joinTable.on,\n        })\n        .select([joinColAlias, qb.raw('count(*) AS count')])\n        .where({ [joinColAlias]: referencedValues })\n        .groupBy(joinColAlias)\n        .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\n\n      const map = rows.reduce((map, row) => {\n        map[row[joinColumnName]] = { count: Number(row.count) };\n        return map;\n      }, {} as Record<string, { count: number }>);\n\n      results.forEach((result) => {\n        result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\n      });\n\n      return;\n    }\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n\n      return;\n    }\n\n    const rows = await qb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinTable.inverseJoinColumn.name,\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n        rootTable: qb.alias,\n        on: joinTable.on,\n        orderBy: joinTable.orderBy,\n      })\n      .addSelect(joinColAlias)\n      .where({ [joinColAlias]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(joinColumnName)(rows);\n\n    results.forEach((result) => {\n      result[attributeName] = fromTargetRow(_.first(map[result[referencedColumnName] as string]));\n    });\n  }\n};\n\nconst oneToMany = async (input: InputWithTarget<Relation.OneToMany>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\n  const { db, qb } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  if ('joinColumn' in attribute && attribute.joinColumn) {\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = attribute.joinColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[joinColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n      return;\n    }\n\n    const rows = await db.entityManager\n      .createQueryBuilder(targetMeta.uid)\n      .init(populateValue)\n      .addSelect(`${qb.alias}.${referencedColumnName}`)\n      .where({ [referencedColumnName]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(referencedColumnName)(rows);\n\n    results.forEach((result) => {\n      result[attributeName] = fromTargetRow(map[result[joinColumnName] as string] || []);\n    });\n\n    return;\n  }\n\n  if ('joinTable' in attribute && attribute.joinTable) {\n    const { joinTable } = attribute;\n\n    const qb = db.entityManager.createQueryBuilder(targetMeta.uid);\n\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\n\n    const alias = qb.getAlias();\n    const joinColAlias = `${alias}.${joinColumnName}`;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\n    );\n\n    if (isCount) {\n      if (_.isEmpty(referencedValues)) {\n        results.forEach((result) => {\n          result[attributeName] = { count: 0 };\n        });\n        return;\n      }\n\n      const rows = await qb\n        .init(populateValue)\n        .join({\n          alias,\n          referencedTable: joinTable.name,\n          referencedColumn: joinTable.inverseJoinColumn.name,\n          rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n          rootTable: qb.alias,\n          on: joinTable.on,\n        })\n        .select([joinColAlias, qb.raw('count(*) AS count')])\n        .where({ [joinColAlias]: referencedValues })\n        .groupBy(joinColAlias)\n        .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\n\n      const map = rows.reduce((map, row) => {\n        map[row[joinColumnName]] = { count: Number(row.count) };\n        return map;\n      }, {} as Record<string, { count: number }>);\n\n      results.forEach((result) => {\n        result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\n      });\n\n      return;\n    }\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = [];\n      });\n      return;\n    }\n\n    const rows = await qb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinTable.inverseJoinColumn.name,\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n        rootTable: qb.alias,\n        on: joinTable.on,\n        orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\n      })\n      .addSelect(joinColAlias)\n      .where({ [joinColAlias]: referencedValues })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(joinColumnName)(rows);\n\n    results.forEach((r) => {\n      r[attributeName] = fromTargetRow(map[r[referencedColumnName] as string] || []);\n    });\n  }\n};\n\nconst manyToMany = async (input: InputWithTarget<Relation.ManyToMany>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\n  const { db } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  const { joinTable } = attribute;\n\n  const populateQb = db.entityManager.createQueryBuilder(targetMeta.uid);\n\n  const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\n\n  const alias = populateQb.getAlias();\n  const joinColAlias = `${alias}.${joinColumnName}`;\n  const referencedValues = _.uniq(\n    results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\n  );\n\n  if (isCount) {\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = { count: 0 };\n      });\n      return;\n    }\n\n    const rows = await populateQb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinTable.inverseJoinColumn.name,\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n        rootTable: populateQb.alias,\n        on: joinTable.on,\n      })\n      .select([joinColAlias, populateQb.raw('count(*) AS count')])\n      .where({ [joinColAlias]: referencedValues })\n      .groupBy(joinColAlias)\n      .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\n\n    const map = rows.reduce((map, row) => {\n      map[row[joinColumnName]] = { count: Number(row.count) };\n      return map;\n    }, {} as Record<string, { count: number }>);\n\n    results.forEach((result) => {\n      result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\n    });\n\n    return;\n  }\n\n  if (_.isEmpty(referencedValues)) {\n    results.forEach((result) => {\n      result[attributeName] = [];\n    });\n    return;\n  }\n\n  const rows = await populateQb\n    .init(populateValue)\n    .join({\n      alias,\n      referencedTable: joinTable.name,\n      referencedColumn: joinTable.inverseJoinColumn.name,\n      rootColumn: joinTable.inverseJoinColumn.referencedColumn,\n      rootTable: populateQb.alias,\n      on: joinTable.on,\n      orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\n    })\n    .addSelect(joinColAlias)\n    .where({ [joinColAlias]: referencedValues })\n    .execute<Row[]>({ mapResults: false });\n\n  const map = _.groupBy<Row>(joinColumnName)(rows);\n\n  results.forEach((result) => {\n    result[attributeName] = fromTargetRow(map[result[referencedColumnName] as string] || []);\n  });\n};\n\nconst morphX = async (\n  input: InputWithTarget<Relation.MorphMany | Relation.MorphOne>,\n  ctx: Context\n) => {\n  const { attribute, attributeName, results, populateValue, targetMeta } = input;\n  const { db, uid } = ctx;\n\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n  const { target, morphBy } = attribute;\n\n  const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n  if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n    const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = null;\n      });\n\n      return;\n    }\n\n    const rows = await db.entityManager\n      .createQueryBuilder(target)\n      .init(populateValue)\n      // .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\n      .where({ [idColumn.name]: referencedValues, [typeColumn.name]: uid })\n      .execute<Row>({ mapResults: false });\n\n    const map = _.groupBy<Row>(idColumn.name)(rows);\n\n    results.forEach((result) => {\n      const matchingRows = map[result[idColumn.referencedColumn] as string];\n\n      const matchingValue =\n        attribute.relation === 'morphOne' ? _.first(matchingRows) : matchingRows;\n\n      result[attributeName] = fromTargetRow(matchingValue);\n    });\n  } else if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToMany') {\n    const { joinTable } = targetAttribute;\n\n    const { joinColumn, morphColumn } = joinTable;\n\n    const { idColumn, typeColumn } = morphColumn;\n\n    const referencedValues = _.uniq(\n      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !_.isNil(value))\n    );\n\n    if (_.isEmpty(referencedValues)) {\n      results.forEach((result) => {\n        result[attributeName] = attribute.relation === 'morphOne' ? null : [];\n      });\n\n      return;\n    }\n\n    // find with join table\n    const qb = db.entityManager.createQueryBuilder(target);\n\n    const alias = qb.getAlias();\n\n    const rows = await qb\n      .init(populateValue)\n      .join({\n        alias,\n        referencedTable: joinTable.name,\n        referencedColumn: joinColumn.name,\n        rootColumn: joinColumn.referencedColumn,\n        rootTable: qb.alias,\n        on: {\n          ...(joinTable.on || {}),\n          field: attributeName,\n        },\n        orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\n      })\n      .addSelect([`${alias}.${idColumn.name}`, `${alias}.${typeColumn.name}`])\n      .where({\n        [`${alias}.${idColumn.name}`]: referencedValues,\n        [`${alias}.${typeColumn.name}`]: uid,\n      })\n      .execute<Row[]>({ mapResults: false });\n\n    const map = _.groupBy<Row>(idColumn.name)(rows);\n\n    results.forEach((result) => {\n      const matchingRows = map[result[idColumn.referencedColumn] as string];\n\n      const matchingValue =\n        attribute.relation === 'morphOne' ? _.first(matchingRows) : matchingRows;\n\n      result[attributeName] = fromTargetRow(matchingValue);\n    });\n  }\n};\n\nconst morphToMany = async (input: Input<Relation.MorphToMany>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue } = input;\n  const { db } = ctx;\n\n  // find with join table\n  const { joinTable } = attribute;\n\n  const { joinColumn, morphColumn } = joinTable;\n  const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n  // fetch join table to create the ids map then do the same as morphToOne without the first\n\n  const referencedValues = _.uniq(\n    results.map((r) => r[joinColumn.referencedColumn]).filter((value) => !_.isNil(value))\n  );\n\n  const qb = db.entityManager.createQueryBuilder(joinTable.name);\n\n  const joinRows = await qb\n    .where({\n      [joinColumn.name]: referencedValues,\n      ...(joinTable.on || {}),\n      // If the populateValue contains an \"on\" property,\n      // only populate the types defined in it\n      ...('on' in populateValue\n        ? { [morphColumn.typeColumn.name]: Object.keys(populateValue.on ?? {}) }\n        : {}),\n    })\n    .orderBy([joinColumn.name, 'order'])\n    .execute<Row[]>({ mapResults: false });\n\n  const joinMap = _.groupBy(joinColumn.name, joinRows);\n\n  const idsByType = joinRows.reduce<Record<string, ID[]>>((acc, result) => {\n    const idValue = result[morphColumn.idColumn.name] as ID;\n    const typeValue = result[morphColumn.typeColumn.name] as string;\n\n    if (!idValue || !typeValue) {\n      return acc;\n    }\n\n    if (!_.has(typeValue, acc)) {\n      acc[typeValue] = [];\n    }\n\n    acc[typeValue].push(idValue);\n\n    return acc;\n  }, {});\n\n  const map: MorphIdMap = {};\n  const { on, ...typePopulate } = populateValue;\n\n  for (const type of Object.keys(idsByType)) {\n    const ids = idsByType[type];\n\n    // type was removed but still in morph relation\n    if (!db.metadata.get(type)) {\n      map[type] = {};\n\n      continue;\n    }\n\n    const qb = db.entityManager.createQueryBuilder(type);\n\n    const rows = await qb\n      .init(on?.[type] ?? typePopulate)\n      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\n      .where({ [idColumn.referencedColumn]: ids })\n      .execute<Row[]>({ mapResults: false });\n\n    map[type] = _.groupBy<Row>(idColumn.referencedColumn)(rows);\n  }\n\n  results.forEach((result) => {\n    const joinResults = joinMap[result[joinColumn.referencedColumn] as string] || [];\n\n    const matchingRows = joinResults.flatMap((joinResult) => {\n      const id = joinResult[idColumn.name] as ID;\n      const type = joinResult[typeColumn.name] as string;\n\n      const targetMeta = db.metadata.get(type);\n\n      const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\n\n      return (map[type][id] || []).map((row) => {\n        return {\n          [typeField]: type,\n          ...fromTargetRow(row),\n        };\n      });\n    });\n\n    result[attributeName] = matchingRows;\n  });\n};\n\nconst morphToOne = async (input: Input<Relation.MorphToOne>, ctx: Context) => {\n  const { attribute, attributeName, results, populateValue } = input;\n  const { db } = ctx;\n\n  const { morphColumn } = attribute;\n  const { idColumn, typeColumn } = morphColumn;\n\n  // make a map for each type what ids to return\n  // make a nested map per id\n\n  const idsByType = results.reduce<Record<string, ID[]>>((acc, result) => {\n    const idValue = result[morphColumn.idColumn.name] as ID;\n    const typeValue = result[morphColumn.typeColumn.name] as string;\n\n    if (!idValue || !typeValue) {\n      return acc;\n    }\n\n    if (!(typeValue in acc)) {\n      acc[typeValue] = [];\n    }\n\n    acc[typeValue].push(idValue);\n\n    return acc;\n  }, {});\n\n  const map: MorphIdMap = {};\n  const { on, ...typePopulate } = populateValue;\n\n  for (const type of Object.keys(idsByType)) {\n    const ids = idsByType[type];\n\n    // type was removed but still in morph relation\n    if (!db.metadata.get(type)) {\n      map[type] = {};\n      return;\n    }\n\n    const qb = db.entityManager.createQueryBuilder(type);\n\n    const rows = await qb\n      .init(on?.[type] ?? typePopulate)\n      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\n      .where({ [idColumn.referencedColumn]: ids })\n      .execute<Row[]>({ mapResults: false });\n\n    map[type] = _.groupBy<Row>(idColumn.referencedColumn)(rows);\n  }\n\n  results.forEach((result) => {\n    const id = result[idColumn.name] as ID;\n    const type = result[typeColumn.name] as string;\n\n    if (!type || !id) {\n      result[attributeName] = null;\n      return;\n    }\n\n    const matchingRows = map[type][id];\n\n    const fromTargetRow = (rowOrRows: Row | Row[] | undefined) =>\n      fromRow(db.metadata.get(type), rowOrRows);\n\n    result[attributeName] = fromTargetRow(_.first(matchingRows));\n  });\n};\n\n//  TODO: Omit limit & offset to avoid needing a query per result to avoid making too many queries\nconst pickPopulateParams = (populate: Record<string, unknown>) => {\n  const fieldsToPick = [\n    'select',\n    'count',\n    'where',\n    'populate',\n    'orderBy',\n    'filters',\n    'ordering',\n    'on',\n  ];\n\n  if (populate.count !== true) {\n    fieldsToPick.push('limit', 'offset');\n  }\n\n  return _.pick(fieldsToPick, populate);\n};\n\nconst applyPopulate = async (results: Row[], populate: Record<string, any>, ctx: Context) => {\n  const { db, uid, qb } = ctx;\n  const meta = db.metadata.get(uid);\n\n  if (_.isEmpty(results)) {\n    return results;\n  }\n\n  for (const attributeName of Object.keys(populate)) {\n    const attribute = meta.attributes[attributeName];\n\n    if (attribute.type !== 'relation') {\n      throw new Error(`Invalid populate attribute ${attributeName}`);\n    }\n\n    const populateValue = {\n      filters: qb.state.filters,\n      ...pickPopulateParams(populate[attributeName]),\n    };\n\n    const isCount = 'count' in populateValue && populateValue.count === true;\n\n    switch (attribute.relation) {\n      case 'oneToOne':\n      case 'manyToOne': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await XtoOne(input, ctx);\n        break;\n      }\n      case 'oneToMany': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await oneToMany(input, ctx);\n        break;\n      }\n      case 'manyToMany': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await manyToMany(input, ctx);\n        break;\n      }\n      case 'morphOne':\n      case 'morphMany': {\n        const targetMeta = db.metadata.get(attribute.target);\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\n        await morphX(input, ctx);\n        break;\n      }\n      case 'morphToMany': {\n        const input = { attribute, attributeName, results, populateValue, isCount };\n        await morphToMany(input, ctx);\n        break;\n      }\n      case 'morphToOne': {\n        const input = { attribute, attributeName, results, populateValue, isCount };\n        await morphToOne(input, ctx);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n};\n\nexport default applyPopulate;\n","import _ from 'lodash/fp';\n\nimport * as types from '../../../utils/types';\nimport type { Meta } from '../../../metadata';\nimport type { QueryBuilder } from '../../query-builder';\nimport type { Database } from '../../..';\n\nconst getRootLevelPopulate = (meta: Meta) => {\n  const populate: PopulateMap = {};\n\n  for (const attributeName of Object.keys(meta.attributes)) {\n    const attribute = meta.attributes[attributeName];\n    if (attribute.type === 'relation') {\n      populate[attributeName] = true;\n    }\n  }\n\n  return populate;\n};\n\ntype Context = {\n  qb: QueryBuilder;\n  db: Database;\n  uid: string;\n};\n\ntype PopulateMap = {\n  [key: string]:\n    | true\n    | {\n        populate?: PopulateMap | true | string[];\n      };\n};\n\n/**\n * Converts and prepares the query for populate\n *\n * @param {boolean|string[]|object} populate populate param\n * @param {object} ctx query context\n * @param {object} ctx.db database instance\n * @param {object} ctx.qb query builder instance\n * @param {string} ctx.uid model uid\n */\nconst processPopulate = (populate: unknown, ctx: Context) => {\n  const { qb, db, uid } = ctx;\n  const meta = db.metadata.get(uid);\n\n  let populateMap: PopulateMap = {};\n\n  if (populate === false || _.isNil(populate)) {\n    return null;\n  }\n\n  if (populate === true) {\n    populateMap = getRootLevelPopulate(meta);\n  } else if (Array.isArray(populate)) {\n    for (const key of populate) {\n      const [root, ...rest] = key.split('.');\n\n      if (rest.length > 0) {\n        const subPopulate = rest.join('.');\n        if (populateMap[root]) {\n          const populateValue = populateMap[root];\n\n          if (populateValue === true) {\n            populateMap[root] = {\n              populate: [subPopulate],\n            };\n          } else {\n            populateValue.populate = [subPopulate].concat(populateValue.populate ?? []);\n          }\n        } else {\n          populateMap[root] = {\n            populate: [subPopulate],\n          };\n        }\n      } else {\n        populateMap[root] = populateMap[root] ? populateMap[root] : true;\n      }\n    }\n  } else {\n    populateMap = populate as PopulateMap;\n  }\n\n  if (!_.isPlainObject(populateMap)) {\n    throw new Error('Populate must be an object');\n  }\n\n  const finalPopulate: PopulateMap = {};\n  for (const key of Object.keys(populateMap)) {\n    const attribute = meta.attributes[key];\n\n    if (!attribute) {\n      continue;\n    }\n\n    if (!types.isRelation(attribute.type)) {\n      continue;\n    }\n\n    // Make sure to query the join column value if needed,\n    // so that we can apply the populate later on\n    if ('joinColumn' in attribute && attribute.joinColumn) {\n      qb.addSelect(attribute.joinColumn.name);\n    }\n\n    // Make sure id is present for future populate queries\n    if (_.has('id', meta.attributes)) {\n      qb.addSelect('id');\n    }\n\n    finalPopulate[key] = populateMap[key];\n  }\n\n  return finalPopulate;\n};\n\nexport default processPopulate;\n","import type { Knex } from 'knex';\n\nimport KnexBuilder from 'knex/lib/query/querybuilder';\nimport KnexRaw from 'knex/lib/raw';\n\nimport type { Database } from '..';\n\n/**\n * @internal\n */\nexport function isKnexQuery(value: unknown): value is Knex.Raw | Knex.QueryBuilder {\n  return value instanceof KnexBuilder || value instanceof KnexRaw;\n}\n\n/**\n * Adds the name of the schema to the table name if the schema was defined by the user.\n * Users can set the db schema only for Postgres in strapi database config.\n */\nexport const addSchema = (db: Database, tableName: string): string => {\n  const schemaName = db.getSchemaName();\n  return schemaName ? `${schemaName}.${tableName}` : tableName;\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { isArray, castArray, keys, isPlainObject } from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport { isOperatorOfType } from '@strapi/utils';\nimport * as types from '../../utils/types';\nimport { createField } from '../../fields';\nimport { createJoin } from './join';\nimport { toColumnName } from './transform';\nimport { isKnexQuery } from '../../utils/knex';\n\nimport type { Ctx } from '../types';\nimport type { Attribute } from '../../types';\n\nconst isRecord = (value: unknown): value is Record<string, unknown> => isPlainObject(value);\n\nconst castValue = (value: unknown, attribute: Attribute | null) => {\n  if (!attribute) {\n    return value;\n  }\n\n  if (types.isScalar(attribute.type) && !isKnexQuery(value)) {\n    const field = createField(attribute);\n\n    return value === null ? null : field.toDB(value);\n  }\n\n  return value;\n};\n\nconst processSingleAttributeWhere = (\n  attribute: Attribute | null,\n  where: unknown,\n  operator = '$eq'\n) => {\n  if (!isRecord(where)) {\n    if (isOperatorOfType('cast', operator)) {\n      return castValue(where, attribute);\n    }\n\n    return where;\n  }\n\n  const filters: Record<string, unknown> = {};\n\n  for (const key of Object.keys(where)) {\n    const value = where[key];\n\n    if (!isOperatorOfType('where', key)) {\n      throw new Error(`Undefined attribute level operator ${key}`);\n    }\n\n    filters[key] = processAttributeWhere(attribute, value, key);\n  }\n\n  return filters;\n};\n\nconst processAttributeWhere = (attribute: Attribute | null, where: unknown, operator = '$eq') => {\n  if (isArray(where)) {\n    return where.map((sub) => processSingleAttributeWhere(attribute, sub, operator));\n  }\n\n  return processSingleAttributeWhere(attribute, where, operator);\n};\n\nconst processNested = (where: unknown, ctx: WhereCtx) => {\n  if (!isRecord(where)) {\n    return where;\n  }\n\n  return processWhere(where, ctx);\n};\n\ntype WhereCtx = Ctx & { alias?: string };\n\n/**\n * Process where parameter\n */\nfunction processWhere(where: Record<string, unknown>, ctx: WhereCtx): Record<string, unknown>;\nfunction processWhere(where: Record<string, unknown>[], ctx: WhereCtx): Record<string, unknown>[];\nfunction processWhere(\n  where: Record<string, unknown> | Record<string, unknown>[],\n  ctx: WhereCtx\n): Record<string, unknown> | Record<string, unknown>[] {\n  if (!isArray(where) && !isRecord(where)) {\n    throw new Error('Where must be an array or an object');\n  }\n\n  if (isArray(where)) {\n    return where.map((sub) => processWhere(sub, ctx));\n  }\n\n  const { db, uid, qb, alias } = ctx;\n  const meta = db.metadata.get(uid);\n\n  const filters: Record<string, unknown> = {};\n\n  // for each key in where\n  for (const key of Object.keys(where)) {\n    const value = where[key];\n\n    // if operator $and $or then loop over them\n    if (isOperatorOfType('group', key) && Array.isArray(value)) {\n      filters[key] = value.map((sub) => processNested(sub, ctx));\n      continue;\n    }\n\n    if (key === '$not') {\n      filters[key] = processNested(value, ctx);\n      continue;\n    }\n\n    if (isOperatorOfType('where', key)) {\n      throw new Error(\n        `Only $and, $or and $not can only be used as root level operators. Found ${key}.`\n      );\n    }\n\n    const attribute = meta.attributes[key];\n\n    if (!attribute) {\n      filters[qb.aliasColumn(key, alias)] = processAttributeWhere(null, value);\n      continue;\n    }\n\n    if (types.isRelation(attribute.type) && 'target' in attribute) {\n      // attribute\n      const subAlias = createJoin(ctx, {\n        alias: alias || qb.alias,\n        attributeName: key,\n        attribute,\n      });\n\n      let nestedWhere = processNested(value, {\n        db,\n        qb,\n        alias: subAlias,\n        uid: attribute.target,\n      });\n\n      if (!isRecord(nestedWhere) || isOperatorOfType('where', keys(nestedWhere)[0])) {\n        nestedWhere = { [qb.aliasColumn('id', subAlias)]: nestedWhere };\n      }\n\n      // TODO: use a better merge logic (push to $and when collisions)\n      Object.assign(filters, nestedWhere);\n\n      continue;\n    }\n\n    if (types.isScalar(attribute.type)) {\n      const columnName = toColumnName(meta, key);\n      const aliasedColumnName = qb.aliasColumn(columnName, alias);\n\n      filters[aliasedColumnName] = processAttributeWhere(attribute, value);\n\n      continue;\n    }\n\n    throw new Error(`You cannot filter on ${attribute.type} types`);\n  }\n\n  return filters;\n}\n\ntype Operator =\n  | '$eq'\n  | '$ne'\n  | '$nei'\n  | '$in'\n  | '$notIn'\n  | '$lt'\n  | '$lte'\n  | '$gt'\n  | '$gte'\n  | '$between'\n  | '$contains'\n  | '$notContains'\n  | '$containsi'\n  | '$notContainsi'\n  | '$startsWith'\n  | '$endsWith'\n  | '$null'\n  | '$notNull'\n  | '$not'\n  | '$eqi'\n  | '$startsWithi'\n  | '$endsWithi'\n  | '$jsonSupersetOf';\n\n// TODO: add type casting per operator at some point\nconst applyOperator = (qb: Knex.QueryBuilder, column: any, operator: Operator, value: any) => {\n  if (Array.isArray(value) && !isOperatorOfType('array', operator)) {\n    return qb.where((subQB) => {\n      value.forEach((subValue) =>\n        subQB.orWhere((innerQB) => {\n          applyOperator(innerQB, column, operator, subValue);\n        })\n      );\n    });\n  }\n\n  switch (operator) {\n    case '$not': {\n      qb.whereNot((qb) => applyWhereToColumn(qb, column, value));\n      break;\n    }\n\n    case '$in': {\n      // @ts-ignore\n      // TODO: fix in v5\n      qb.whereIn(column, isKnexQuery(value) ? value : castArray(value));\n      break;\n    }\n\n    case '$notIn': {\n      // @ts-ignore\n      // TODO: fix in v5\n      qb.whereNotIn(column, isKnexQuery(value) ? value : castArray(value));\n      break;\n    }\n\n    case '$eq': {\n      if (value === null) {\n        qb.whereNull(column);\n        break;\n      }\n\n      qb.where(column, value);\n      break;\n    }\n\n    case '$eqi': {\n      if (value === null) {\n        qb.whereNull(column);\n        break;\n      }\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `${value}`]);\n      break;\n    }\n    case '$ne': {\n      if (value === null) {\n        qb.whereNotNull(column);\n        break;\n      }\n\n      qb.where(column, '<>', value);\n      break;\n    }\n    case '$nei': {\n      if (value === null) {\n        qb.whereNotNull(column);\n        break;\n      }\n      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `${value}`]);\n      break;\n    }\n    case '$gt': {\n      qb.where(column, '>', value);\n      break;\n    }\n    case '$gte': {\n      qb.where(column, '>=', value);\n      break;\n    }\n    case '$lt': {\n      qb.where(column, '<', value);\n      break;\n    }\n    case '$lte': {\n      qb.where(column, '<=', value);\n      break;\n    }\n    case '$null': {\n      if (value) {\n        qb.whereNull(column);\n      } else {\n        qb.whereNotNull(column);\n      }\n      break;\n    }\n    case '$notNull': {\n      if (value) {\n        qb.whereNotNull(column);\n      } else {\n        qb.whereNull(column);\n      }\n      break;\n    }\n    case '$between': {\n      qb.whereBetween(column, value);\n      break;\n    }\n    case '$startsWith': {\n      qb.where(column, 'like', `${value}%`);\n      break;\n    }\n    case '$startsWithi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `${value}%`]);\n      break;\n    }\n    case '$endsWith': {\n      qb.where(column, 'like', `%${value}`);\n      break;\n    }\n    case '$endsWithi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `%${value}`]);\n      break;\n    }\n    case '$contains': {\n      qb.where(column, 'like', `%${value}%`);\n      break;\n    }\n\n    case '$notContains': {\n      qb.whereNot(column, 'like', `%${value}%`);\n      break;\n    }\n\n    case '$containsi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `%${value}%`]);\n      break;\n    }\n\n    case '$notContainsi': {\n      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `%${value}%`]);\n      break;\n    }\n\n    // Experimental, only for internal use\n    // Only on MySQL, PostgreSQL and CockroachDB.\n    // https://knexjs.org/guide/query-builder.html#wherejsonsupersetof\n    case '$jsonSupersetOf': {\n      qb.whereJsonSupersetOf(column, value);\n      break;\n    }\n\n    // TODO: Add more JSON operators: whereJsonObject, whereJsonPath, whereJsonSubsetOf\n\n    // TODO: relational operators every/some/exists/size ...\n\n    default: {\n      throw new Error(`Undefined attribute level operator ${operator}`);\n    }\n  }\n};\n\nconst applyWhereToColumn = (\n  qb: Knex.QueryBuilder,\n  column: string,\n  columnWhere: Record<Operator, unknown> | Array<Record<Operator, unknown>>\n) => {\n  if (!isRecord(columnWhere)) {\n    if (Array.isArray(columnWhere)) {\n      return qb.whereIn(column, columnWhere);\n    }\n\n    return qb.where(column, columnWhere);\n  }\n\n  const keys = Object.keys(columnWhere) as Operator[];\n\n  keys.forEach((operator) => {\n    const value = columnWhere[operator];\n\n    applyOperator(qb, column, operator, value);\n  });\n};\n\ntype Where =\n  | {\n      $and?: Where[];\n      $or?: Where[];\n      $not?: Where;\n      [key: string]: any;\n    }\n  | Array<Where>;\n\nconst applyWhere = (qb: Knex.QueryBuilder, where: Where) => {\n  if (!isArray(where) && !isRecord(where)) {\n    throw new Error('Where must be an array or an object');\n  }\n\n  if (isArray(where)) {\n    return qb.where((subQB: Knex.QueryBuilder) =>\n      where.forEach((subWhere) => applyWhere(subQB, subWhere))\n    );\n  }\n\n  Object.keys(where).forEach((key) => {\n    if (key === '$and') {\n      const value = where[key] ?? [];\n\n      return qb.where((subQB: Knex.QueryBuilder) => {\n        value.forEach((v) => applyWhere(subQB, v));\n      });\n    }\n\n    if (key === '$or') {\n      const value = where[key] ?? [];\n\n      return qb.where((subQB: Knex.QueryBuilder) => {\n        value.forEach((v) => subQB.orWhere((inner) => applyWhere(inner, v)));\n      });\n    }\n\n    if (key === '$not') {\n      const value = where[key] ?? {};\n\n      return qb.whereNot((qb) => applyWhere(qb, value));\n    }\n\n    applyWhereToColumn(qb, key, where[key]);\n  });\n};\n\nconst fieldLowerFn = (qb: Knex.QueryBuilder) => {\n  // Postgres requires string to be passed\n  if (qb.client.config.client === 'postgres') {\n    return 'LOWER(CAST(?? AS VARCHAR))';\n  }\n\n  return 'LOWER(??)';\n};\n\nexport { applyWhere, processWhere };\n","import { Readable } from 'stream';\nimport { isFinite } from 'lodash/fp';\nimport type { Knex } from 'knex';\nimport type { QueryBuilder } from '../../query-builder';\nimport type { Database } from '../../..';\n\nimport { applyPopulate } from '../populate';\nimport { fromRow } from '../transform';\nimport { Meta } from '../../../metadata';\n\nconst knexQueryDone = Symbol('knexQueryDone');\nconst knexPerformingQuery = Symbol('knexPerformingQuery');\n\ninterface ReadableStrapiQueryOptions {\n  qb: QueryBuilder;\n  uid: string;\n  db: Database;\n  mapResults?: boolean;\n  batchSize?: number;\n}\n\nclass ReadableStrapiQuery extends Readable {\n  _offset: number;\n\n  _limit: number | null;\n\n  _fetched: number;\n\n  _query: Knex.QueryBuilder;\n\n  _qb: QueryBuilder;\n\n  _db: Database;\n\n  _uid: string;\n\n  _meta: Meta;\n\n  _batchSize: number;\n\n  _mapResults: boolean;\n\n  [knexPerformingQuery]: boolean;\n\n  constructor({ qb, db, uid, mapResults = true, batchSize = 500 }: ReadableStrapiQueryOptions) {\n    super({ objectMode: true, highWaterMark: batchSize });\n\n    // Extract offset & limit from the query-builder's state\n    const { offset, limit } = qb.state;\n\n    // Original offset value\n    this._offset = isFinite(offset) ? Number(offset) : 0;\n\n    // Max amount of entities to fetch, force null as undefined value\n    this._limit = isFinite(limit) ? Number(limit) : null;\n\n    // Total amount of entities fetched\n    this._fetched = 0;\n\n    /**\n     * Original query\n     */\n    this._query = qb.getKnexQuery();\n\n    // Query Builder instance\n    this._qb = qb;\n\n    // Database related properties\n    this._db = db;\n    this._uid = uid;\n    this._meta = db.metadata.get(uid);\n\n    // Stream params\n    this._batchSize = batchSize;\n    this._mapResults = mapResults;\n\n    // States\n    this[knexPerformingQuery] = false;\n  }\n\n  _destroy(err: Error, cb: (err?: Error) => void) {\n    // If the stream is destroyed while a query is being made, then wait for a\n    // kQueryDone event to be emitted before actually destroying the stream\n    if (this[knexPerformingQuery]) {\n      this.once(knexQueryDone, (er) => cb(err || er));\n    } else {\n      cb(err);\n    }\n  }\n\n  /**\n   * Custom ._read() implementation\n   *\n   *  NOTE: Here \"size\" means the number of entities to be read from the database.\n   *  Not the actual byte size, as it would means that we need to return partial entities.\n   *\n   */\n  async _read(size: number) {\n    const query = this._query;\n\n    // Remove the original offset & limit properties from the query\n    // Theoretically, they would be replaced by calling them again, but this is just to be sure\n    query.clear('limit').clear('offset');\n\n    // Define the maximum read size based on the limit and the requested size\n    // NOTE: size is equal to _batchSize by default. Since we want to allow customizing it on\n    // the fly, we need to use its value instead of batchSize when computing the maxReadSize value\n    const maxReadSize =\n      // if no limit is defined in the query, use the given size,\n      // otherwise, use the smallest value between the two\n      this._limit === null ? size : Math.min(size, this._limit);\n\n    // Compute the limit for the next query\n    const limit =\n      // If a limit is defined\n      this._limit !== null &&\n      // And reading `maxReadSize` would fetch too many entities (> _limit)\n      this._fetched + maxReadSize > this._limit\n        ? // Then adjust the limit so that it only get the remaining entities\n          this._limit - this._fetched\n        : // Else, use the max read size\n          maxReadSize;\n\n    // If we don't have anything left to read (_limit === _fetched),\n    // don't bother making the query and end the stream by pushing null\n    if (limit <= 0) {\n      this.push(null);\n      return;\n    }\n\n    // Compute the offset (base offset + number of entities already fetched)\n    const offset = this._offset + this._fetched;\n\n    // Update the query with the new values (offset + limit)\n    query.offset(offset).limit(limit);\n\n    // Lock the ._destroy()\n    this[knexPerformingQuery] = true;\n\n    let results;\n    let count;\n    let err;\n\n    try {\n      // Execute the query and store the results & count\n      results = await query;\n\n      const { populate } = this._qb.state;\n\n      // Apply populate if needed\n      if (populate) {\n        await applyPopulate(results, populate, { qb: this._qb, uid: this._uid, db: this._db });\n      }\n\n      // Map results if asked to\n      if (this._mapResults) {\n        results = fromRow(this._meta, results);\n      }\n\n      count = results.length;\n    } catch (e) {\n      err = e;\n    }\n\n    // Unlock the ._destroy()\n    this[knexPerformingQuery] = false;\n\n    // Tell ._destroy() that it's now safe to close the db connection\n    if (this.destroyed) {\n      this.emit(knexQueryDone);\n      return;\n    }\n\n    // If there is an error, destroy with the given error\n    if (err) {\n      this.destroy(err as Error);\n      return;\n    }\n\n    // Update the amount of fetched entities\n    this._fetched += count;\n\n    // While there is at least one value to unpack\n    for (const result of results) {\n      this.push(result);\n    }\n\n    // If the amount of fetched entities is smaller than the\n    // maximum read size, Then push null to close the stream\n    if (this._fetched === this._limit || count < this._batchSize) {\n      this.push(null);\n    }\n  }\n}\n\nexport default ReadableStrapiQuery;\n","import { AsyncLocalStorage } from 'node:async_hooks';\nimport { Knex } from 'knex';\n\nexport type Callback = (...args: any[]) => Promise<any> | any;\n\nexport interface TransactionObject {\n  commit: () => Promise<void>;\n  rollback: () => Promise<void>;\n  get: () => Knex.Transaction;\n}\nexport interface Store {\n  trx: Knex.Transaction | null;\n  commitCallbacks: Callback[];\n  rollbackCallbacks: Callback[];\n}\n\nconst storage = new AsyncLocalStorage<Store>();\n\nconst transactionCtx = {\n  async run<TCallback extends Callback>(trx: Knex.Transaction, cb: TCallback) {\n    const store = storage.getStore();\n    return storage.run<ReturnType<TCallback>, void[]>(\n      {\n        trx,\n        // Fill with existing callbacks if nesting transactions\n        commitCallbacks: store?.commitCallbacks || [],\n        rollbackCallbacks: store?.rollbackCallbacks || [],\n      },\n      cb\n    );\n  },\n\n  get() {\n    const store = storage.getStore();\n    return store?.trx;\n  },\n\n  async commit(trx: Knex.Transaction) {\n    const store = storage.getStore();\n\n    // Clear transaction from store\n    if (store?.trx) {\n      store.trx = null;\n    }\n\n    // Commit transaction\n    await trx.commit();\n\n    if (!store?.commitCallbacks.length) {\n      return;\n    }\n\n    // Run callbacks\n    store.commitCallbacks.forEach((cb) => cb());\n    store.commitCallbacks = [];\n  },\n\n  async rollback(trx: Knex.Transaction) {\n    const store = storage.getStore();\n\n    // Clear transaction from store\n    if (store?.trx) {\n      store.trx = null;\n    }\n\n    // Rollback transaction\n    await trx.rollback();\n\n    if (!store?.rollbackCallbacks.length) {\n      return;\n    }\n\n    // Run callbacks\n    store.rollbackCallbacks.forEach((cb) => cb());\n    store.rollbackCallbacks = [];\n  },\n\n  onCommit(cb: Callback) {\n    const store = storage.getStore();\n    if (store?.commitCallbacks) {\n      store.commitCallbacks.push(cb);\n    }\n  },\n\n  onRollback(cb: Callback) {\n    const store = storage.getStore();\n    if (store?.rollbackCallbacks) {\n      store.rollbackCallbacks.push(cb);\n    }\n  },\n};\n\nexport { transactionCtx };\n","import _ from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport { DatabaseError } from '../errors';\nimport * as helpers from './helpers';\nimport { transactionCtx } from '../transaction-context';\nimport type { Join } from './helpers/join';\n\nimport type { Database } from '..';\nimport { isKnexQuery } from '../utils/knex';\n\ninterface State {\n  type: 'select' | 'insert' | 'update' | 'delete' | 'count' | 'max' | 'truncate';\n  select: Array<string | Knex.Raw>;\n  count: string | null;\n  max: string | null;\n  first: boolean;\n  data: Record<string, unknown> | (null | Record<string, unknown>)[] | null;\n  where: Record<string, unknown>[];\n  joins: Join[];\n  populate: object | null;\n  limit: number | null;\n  offset: number | null;\n  transaction: any;\n  forUpdate: boolean;\n  onConflict: any;\n  merge: any;\n  ignore: boolean;\n  orderBy: any[];\n  groupBy: any[];\n  increments: any[];\n  decrements: any[];\n  aliasCounter: number;\n  filters: any;\n  search: string;\n}\n\nexport interface QueryBuilder {\n  alias: string;\n  state: State;\n  getAlias(): string;\n  clone(): QueryBuilder;\n  select(args: string | Array<string | Knex.Raw>): QueryBuilder;\n  addSelect(args: string | string[]): QueryBuilder;\n  insert<TData extends Record<string, unknown> | Record<string, unknown>[]>(\n    data: TData\n  ): QueryBuilder;\n  onConflict(args: any): QueryBuilder;\n  merge(args: any): QueryBuilder;\n  ignore(): QueryBuilder;\n  delete(): QueryBuilder;\n  ref(name: string): any;\n  update<TData extends Record<string, unknown>>(data: TData): QueryBuilder;\n  increment(column: string, amount?: number): QueryBuilder;\n  decrement(column: string, amount?: number): QueryBuilder;\n  count(count?: string): QueryBuilder;\n  max(column: string): QueryBuilder;\n  where(where?: object): QueryBuilder;\n  limit(limit: number): QueryBuilder;\n  offset(offset: number): QueryBuilder;\n  orderBy(orderBy: any): QueryBuilder;\n  groupBy(groupBy: any): QueryBuilder;\n  populate(populate: any): QueryBuilder;\n  search(query: string): QueryBuilder;\n  transacting(transaction: any): QueryBuilder;\n  forUpdate(): QueryBuilder;\n  init(params?: any): QueryBuilder;\n  filters(filters: any): void;\n  first(): QueryBuilder;\n  join(join: any): QueryBuilder;\n  mustUseAlias(): boolean;\n\n  aliasColumn(key: any, alias?: string): any;\n\n  raw: Knex.RawBuilder;\n  shouldUseSubQuery(): boolean;\n  runSubQuery(): any;\n  processState(): void;\n  shouldUseDistinct(): boolean;\n  processSelect(): void;\n  getKnexQuery(): Knex.QueryBuilder;\n  execute<T>(options?: { mapResults?: boolean }): Promise<T>;\n  stream(options?: { mapResults?: boolean }): helpers.ReadableQuery;\n}\n\nconst createQueryBuilder = (\n  uid: string,\n  db: Database,\n  initialState: Partial<State> = {}\n): QueryBuilder => {\n  const meta = db.metadata.get(uid);\n  const { tableName } = meta;\n\n  const state: State = _.defaults(\n    {\n      type: 'select',\n      select: [],\n      count: null,\n      max: null,\n      first: false,\n      data: null,\n      where: [],\n      joins: [],\n      populate: null,\n      limit: null,\n      offset: null,\n      transaction: null,\n      forUpdate: false,\n      onConflict: null,\n      merge: null,\n      ignore: false,\n      orderBy: [],\n      groupBy: [],\n      increments: [],\n      decrements: [],\n      aliasCounter: 0,\n      filters: null,\n      search: null,\n    },\n    initialState\n  );\n\n  const getAlias = () => {\n    const alias = `t${state.aliasCounter}`;\n\n    state.aliasCounter += 1;\n\n    return alias;\n  };\n\n  return {\n    alias: getAlias(),\n    getAlias,\n    state,\n\n    clone() {\n      return createQueryBuilder(uid, db, state);\n    },\n\n    select(args) {\n      state.type = 'select';\n      state.select = _.uniq(_.castArray(args));\n\n      return this;\n    },\n\n    addSelect(args) {\n      state.select = _.uniq([...state.select, ..._.castArray(args)]);\n\n      return this;\n    },\n\n    insert(data) {\n      state.type = 'insert';\n      state.data = data;\n\n      return this;\n    },\n\n    onConflict(args) {\n      state.onConflict = args;\n\n      return this;\n    },\n\n    merge(args) {\n      state.merge = args;\n\n      return this;\n    },\n\n    ignore() {\n      state.ignore = true;\n\n      return this;\n    },\n\n    delete() {\n      state.type = 'delete';\n\n      return this;\n    },\n\n    ref(name) {\n      return db.connection.ref(helpers.toColumnName(meta, name));\n    },\n\n    update(data) {\n      state.type = 'update';\n      state.data = data;\n\n      return this;\n    },\n\n    increment(column, amount = 1) {\n      state.type = 'update';\n      state.increments.push({ column, amount });\n\n      return this;\n    },\n\n    decrement(column, amount = 1) {\n      state.type = 'update';\n      state.decrements.push({ column, amount });\n\n      return this;\n    },\n\n    count(count = 'id') {\n      state.type = 'count';\n      state.count = count;\n\n      return this;\n    },\n\n    max(column: string) {\n      state.type = 'max';\n      state.max = column;\n\n      return this;\n    },\n\n    where(where: Record<string, unknown> = {}) {\n      if (!_.isPlainObject(where)) {\n        throw new Error('Where must be an object');\n      }\n\n      state.where.push(where);\n\n      return this;\n    },\n\n    limit(limit) {\n      state.limit = limit;\n      return this;\n    },\n\n    offset(offset) {\n      state.offset = offset;\n      return this;\n    },\n\n    orderBy(orderBy) {\n      state.orderBy = orderBy;\n      return this;\n    },\n\n    groupBy(groupBy) {\n      state.groupBy = groupBy;\n      return this;\n    },\n\n    populate(populate) {\n      state.populate = populate;\n      return this;\n    },\n\n    search(query) {\n      state.search = query;\n      return this;\n    },\n\n    transacting(transaction) {\n      state.transaction = transaction;\n      return this;\n    },\n\n    forUpdate() {\n      state.forUpdate = true;\n      return this;\n    },\n\n    init(params = {}) {\n      const { _q, filters, where, select, limit, offset, orderBy, groupBy, populate } = params;\n\n      if (!_.isNil(where)) {\n        this.where(where);\n      }\n\n      if (!_.isNil(_q)) {\n        this.search(_q);\n      }\n\n      if (!_.isNil(select)) {\n        this.select(select);\n      } else {\n        this.select('*');\n      }\n\n      if (!_.isNil(limit)) {\n        this.limit(limit);\n      }\n\n      if (!_.isNil(offset)) {\n        this.offset(offset);\n      }\n\n      if (!_.isNil(orderBy)) {\n        this.orderBy(orderBy);\n      }\n\n      if (!_.isNil(groupBy)) {\n        this.groupBy(groupBy);\n      }\n\n      if (!_.isNil(populate)) {\n        this.populate(populate);\n      }\n\n      if (!_.isNil(filters)) {\n        this.filters(filters);\n      }\n\n      return this;\n    },\n\n    filters(filters) {\n      state.filters = filters;\n    },\n\n    first() {\n      state.first = true;\n      return this;\n    },\n\n    join(join) {\n      if (!join.targetField) {\n        state.joins.push(join);\n        return this;\n      }\n\n      const model = db.metadata.get(uid);\n      const attribute = model.attributes[join.targetField];\n\n      helpers.createJoin(\n        { db, qb: this, uid },\n        {\n          alias: this.alias,\n          refAlias: join.alias,\n          attributeName: join.targetField,\n          attribute,\n        }\n      );\n\n      return this;\n    },\n\n    mustUseAlias() {\n      return ['select', 'count'].includes(state.type);\n    },\n\n    aliasColumn(key: string | unknown, alias: string): string | unknown {\n      if (typeof key !== 'string') {\n        return key;\n      }\n\n      if (key.indexOf('.') >= 0) {\n        return key;\n      }\n\n      if (!_.isNil(alias)) {\n        return `${alias}.${key}`;\n      }\n\n      return this.mustUseAlias() ? `${this.alias}.${key}` : key;\n    },\n\n    raw: db.connection.raw.bind(db.connection),\n\n    shouldUseSubQuery() {\n      return ['delete', 'update'].includes(state.type) && state.joins.length > 0;\n    },\n\n    runSubQuery() {\n      this.select('id');\n      const subQB = this.getKnexQuery();\n\n      const nestedSubQuery = db.getConnection().select('id').from(subQB.as('subQuery'));\n      const connection = db.getConnection(tableName);\n\n      return (connection[state.type] as Knex)().whereIn('id', nestedSubQuery);\n    },\n\n    processState() {\n      state.orderBy = helpers.processOrderBy(state.orderBy, { qb: this, uid, db });\n\n      if (!_.isNil(state.filters)) {\n        if (_.isFunction(state.filters)) {\n          const filters = state.filters({ qb: this, uid, meta, db });\n\n          if (!_.isNil(filters)) {\n            state.where.push(filters);\n          }\n        } else {\n          state.where.push(state.filters);\n        }\n      }\n\n      state.where = helpers.processWhere(state.where, { qb: this, uid, db });\n      state.populate = helpers.processPopulate(state.populate, { qb: this, uid, db });\n\n      state.data = helpers.toRow(meta, state.data);\n\n      this.processSelect();\n    },\n\n    shouldUseDistinct() {\n      return state.joins.length > 0 && _.isEmpty(state.groupBy);\n    },\n\n    processSelect() {\n      state.select = state.select.map((field) => {\n        if (isKnexQuery(field)) {\n          return field;\n        }\n\n        return helpers.toColumnName(meta, field);\n      });\n\n      if (this.shouldUseDistinct()) {\n        const joinsOrderByColumns = state.joins.flatMap((join) => {\n          return _.keys(join.orderBy).map((key) => this.aliasColumn(key, join.alias));\n        });\n        const orderByColumns = state.orderBy.map(({ column }) => column);\n\n        state.select = _.uniq([...joinsOrderByColumns, ...orderByColumns, ...state.select]);\n      }\n    },\n\n    getKnexQuery() {\n      if (!state.type) {\n        this.select('*');\n      }\n\n      const aliasedTableName = this.mustUseAlias() ? `${tableName} as ${this.alias}` : tableName;\n\n      const qb = db.getConnection(aliasedTableName);\n\n      if (this.shouldUseSubQuery()) {\n        return this.runSubQuery();\n      }\n\n      this.processState();\n\n      switch (state.type) {\n        case 'select': {\n          qb.select(state.select.map((column) => this.aliasColumn(column)));\n\n          if (this.shouldUseDistinct()) {\n            qb.distinct();\n          }\n\n          break;\n        }\n        case 'count': {\n          const dbColumnName = this.aliasColumn(helpers.toColumnName(meta, state.count));\n\n          if (this.shouldUseDistinct()) {\n            qb.countDistinct({ count: dbColumnName });\n          } else {\n            qb.count({ count: dbColumnName });\n          }\n          break;\n        }\n        case 'max': {\n          const dbColumnName = this.aliasColumn(helpers.toColumnName(meta, state.max));\n          qb.max({ max: dbColumnName });\n          break;\n        }\n        case 'insert': {\n          qb.insert(state.data);\n\n          if (db.dialect.useReturning() && _.has('id', meta.attributes)) {\n            qb.returning('id');\n          }\n\n          break;\n        }\n        case 'update': {\n          if (state.data) {\n            qb.update(state.data);\n          }\n          break;\n        }\n        case 'delete': {\n          qb.delete();\n\n          break;\n        }\n        case 'truncate': {\n          qb.truncate();\n          break;\n        }\n        default: {\n          throw new Error('Unknown query type');\n        }\n      }\n\n      if (state.transaction) {\n        qb.transacting(state.transaction);\n      }\n\n      if (state.forUpdate) {\n        qb.forUpdate();\n      }\n\n      if (!_.isEmpty(state.increments)) {\n        state.increments.forEach((incr) => qb.increment(incr.column, incr.amount));\n      }\n\n      if (!_.isEmpty(state.decrements)) {\n        state.decrements.forEach((decr) => qb.decrement(decr.column, decr.amount));\n      }\n\n      if (state.onConflict) {\n        if (state.merge) {\n          qb.onConflict(state.onConflict).merge(state.merge);\n        } else if (state.ignore) {\n          qb.onConflict(state.onConflict).ignore();\n        }\n      }\n\n      if (state.limit) {\n        qb.limit(state.limit);\n      }\n\n      if (state.offset) {\n        qb.offset(state.offset);\n      }\n\n      if (state.orderBy.length > 0) {\n        qb.orderBy(state.orderBy);\n      }\n\n      if (state.first) {\n        qb.first();\n      }\n\n      if (state.groupBy.length > 0) {\n        qb.groupBy(state.groupBy);\n      }\n\n      // if there are joins and it is a delete or update use a sub query\n      if (state.where) {\n        helpers.applyWhere(qb, state.where);\n      }\n\n      // if there are joins and it is a delete or update use a sub query\n      if (state.search) {\n        qb.where((subQb) => {\n          helpers.applySearch(subQb, state.search, { qb: this, db, uid });\n        });\n      }\n\n      if (state.joins.length > 0) {\n        helpers.applyJoins(qb, state.joins);\n      }\n\n      return qb;\n    },\n\n    async execute({ mapResults = true } = {}) {\n      try {\n        const qb = this.getKnexQuery();\n\n        const transaction = transactionCtx.get();\n        if (transaction) {\n          qb.transacting(transaction);\n        }\n\n        const rows = await qb;\n\n        if (state.populate && !_.isNil(rows)) {\n          await helpers.applyPopulate(_.castArray(rows), state.populate, {\n            qb: this,\n            uid,\n            db,\n          });\n        }\n\n        let results = rows;\n        if (mapResults && state.type === 'select') {\n          results = helpers.fromRow(meta, rows);\n        }\n\n        return results;\n      } catch (error) {\n        if (error instanceof Error) {\n          db.dialect.transformErrors(error);\n        } else {\n          throw error;\n        }\n      }\n    },\n\n    stream({ mapResults = true } = {}) {\n      if (state.type === 'select') {\n        return new helpers.ReadableQuery({ qb: this, db, uid, mapResults });\n      }\n\n      throw new DatabaseError(\n        `query-builder.stream() has been called with an unsupported query type: \"${state.type}\"`\n      );\n    },\n  };\n};\n\nexport default createQueryBuilder;\n","import { isString } from 'lodash/fp';\nimport type { Database } from '..';\nimport type { Repository, Params } from './types';\n\nconst withDefaultPagination = (params: Params) => {\n  const { page = 1, pageSize = 10, ...rest } = params;\n\n  return {\n    page: Number(page),\n    pageSize: Number(pageSize),\n    ...rest,\n  };\n};\n\ntype ParamsWithLimits = Omit<Params, 'page' | 'pageSize'> & {\n  limit: number;\n  offset: number;\n};\n\nconst withOffsetLimit = (\n  params: Params\n): [ParamsWithLimits, { page: number; pageSize: number }] => {\n  const { page, pageSize, ...rest } = withDefaultPagination(params);\n\n  const offset = Math.max(page - 1, 0) * pageSize;\n  const limit = pageSize;\n\n  const query = {\n    ...rest,\n    limit,\n    offset,\n  };\n\n  return [query, { page, pageSize }];\n};\n\nexport const createRepository = (uid: string, db: Database): Repository => {\n  return {\n    findOne(params = {}) {\n      return db.entityManager.findOne(uid, params);\n    },\n\n    findMany(params = {}) {\n      return db.entityManager.findMany(uid, params);\n    },\n\n    findWithCount(params = {}) {\n      return Promise.all([\n        db.entityManager.findMany(uid, params),\n        db.entityManager.count(uid, params),\n      ]);\n    },\n\n    async findPage(params) {\n      const [query, { page, pageSize }] = withOffsetLimit(params);\n\n      const [results, total] = await Promise.all([\n        db.entityManager.findMany(uid, query),\n        db.entityManager.count(uid, query),\n      ]);\n\n      return {\n        results,\n        pagination: {\n          page,\n          pageSize,\n          pageCount: Math.ceil(total / pageSize),\n          total,\n        },\n      };\n    },\n\n    create(params) {\n      return db.entityManager.create(uid, params);\n    },\n\n    createMany(params) {\n      return db.entityManager.createMany(uid, params);\n    },\n\n    update(params) {\n      return db.entityManager.update(uid, params);\n    },\n\n    updateMany(params) {\n      return db.entityManager.updateMany(uid, params);\n    },\n\n    clone(id, params) {\n      return db.entityManager.clone(uid, id, params);\n    },\n\n    delete(params) {\n      return db.entityManager.delete(uid, params);\n    },\n\n    deleteMany(params = {}) {\n      return db.entityManager.deleteMany(uid, params);\n    },\n\n    count(params) {\n      return db.entityManager.count(uid, params);\n    },\n\n    attachRelations(id, data) {\n      return db.entityManager.attachRelations(uid, id, data);\n    },\n\n    async updateRelations(id, data) {\n      const trx = await db.transaction();\n      try {\n        await db.entityManager.updateRelations(uid, id, data, { transaction: trx.get() });\n        return await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        throw e;\n      }\n    },\n\n    deleteRelations(id) {\n      return db.entityManager.deleteRelations(uid, id);\n    },\n\n    cloneRelations(targetId, sourceId, params: Params) {\n      return db.entityManager.cloneRelations(uid, targetId, sourceId, params);\n    },\n\n    populate(entity, populate) {\n      return db.entityManager.populate(uid, entity, populate);\n    },\n\n    load(entity, fields, params) {\n      return db.entityManager.load(uid, entity, fields, params);\n    },\n\n    async loadPages(entity, field, params) {\n      if (!isString(field)) {\n        throw new Error(`Invalid load. Expected ${field} to be a string`);\n      }\n\n      const { attributes } = db.metadata.get(uid);\n      const attribute = attributes[field];\n\n      if (\n        !attribute ||\n        attribute.type !== 'relation' ||\n        !attribute.relation ||\n        !['oneToMany', 'manyToMany'].includes(attribute.relation)\n      ) {\n        throw new Error(`Invalid load. Expected ${field} to be an anyToMany relational attribute`);\n      }\n\n      const [query, { page, pageSize }] = withOffsetLimit(params);\n\n      const [results, { count: total }] = await Promise.all([\n        db.entityManager.load(uid, entity, field, query),\n        db.entityManager.load(uid, entity, field, { ...query, count: true }),\n      ]);\n\n      return {\n        results,\n        pagination: {\n          page,\n          pageSize,\n          pageCount: Math.ceil(total / pageSize),\n          total,\n        },\n      };\n    },\n  };\n};\n","import { groupBy, pipe, mapValues, map, isEmpty } from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport { createQueryBuilder } from '../query';\nimport type { Database } from '..';\nimport type { MorphJoinTable, Relation } from '../types';\n\ntype Rows = Record<string, unknown>[];\n\nconst getMorphToManyRowsLinkedToMorphOne = (\n  rows: Rows,\n  {\n    uid,\n    attributeName,\n    typeColumn,\n    db,\n  }: {\n    uid: string;\n    attributeName: string;\n    typeColumn: { name: string };\n    db: Database;\n  }\n) =>\n  rows.filter((row) => {\n    const relatedType = row[typeColumn.name] as string;\n    const field = row.field as any;\n\n    const targetAttribute = db.metadata.get(relatedType).attributes[field] as Relation.MorphOne;\n\n    // ensure targeted field is the right one + check if it is a morphOne\n    return (\n      targetAttribute?.target === uid &&\n      targetAttribute?.morphBy === attributeName &&\n      targetAttribute?.relation === 'morphOne'\n    );\n  });\n\nexport const deleteRelatedMorphOneRelationsAfterMorphToManyUpdate = async (\n  rows: Rows,\n  {\n    uid,\n    attributeName,\n    joinTable,\n    db,\n    transaction: trx,\n  }: {\n    uid: string;\n    attributeName: string;\n    joinTable: MorphJoinTable;\n    db: Database;\n    transaction?: Knex.Transaction;\n  }\n) => {\n  const { morphColumn } = joinTable;\n  const { idColumn, typeColumn } = morphColumn;\n\n  const morphOneRows = getMorphToManyRowsLinkedToMorphOne(rows, {\n    uid,\n    attributeName,\n    typeColumn,\n    db,\n  });\n\n  const groupByType = groupBy(typeColumn.name);\n  const groupByField = groupBy('field');\n\n  const typeAndFieldIdsGrouped = pipe(groupByType, mapValues(groupByField))(morphOneRows);\n\n  const orWhere = [];\n\n  for (const [type, v] of Object.entries(typeAndFieldIdsGrouped)) {\n    for (const [field, arr] of Object.entries(v)) {\n      orWhere.push({\n        [typeColumn.name]: type,\n        field,\n        [idColumn.name]: { $in: map(idColumn.name, arr) },\n      });\n    }\n  }\n\n  if (!isEmpty(orWhere)) {\n    await createQueryBuilder(joinTable.name, db)\n      .delete()\n      .where({ $or: orWhere })\n      .transacting(trx)\n      .execute();\n  }\n};\n","/* eslint-disable @typescript-eslint/no-namespace */\nimport { randomBytes } from 'crypto';\nimport { map, isEmpty } from 'lodash/fp';\nimport type { Knex } from 'knex';\n\nimport {\n  isBidirectional,\n  isOneToAny,\n  isManyToAny,\n  isAnyToOne,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n} from '../metadata';\nimport { createQueryBuilder } from '../query';\nimport { addSchema } from '../utils/knex';\nimport type { Database } from '..';\nimport type { ID, Relation } from '../types';\n\ndeclare module 'knex' {\n  namespace Knex {\n    interface ChainableInterface {\n      transacting(trx?: Knex.Transaction): this;\n    }\n  }\n}\n\n/**\n * If some relations currently exist for this oneToX relation, on the one side, this function removes them and update the inverse order if needed.\n */\nconst deletePreviousOneToAnyRelations = async ({\n  id,\n  attribute,\n  relIdsToadd,\n  db,\n  transaction: trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  relIdsToadd: ID[];\n  db: Database;\n  transaction?: Knex.Transaction;\n}) => {\n  if (!(isBidirectional(attribute) && isOneToAny(attribute))) {\n    throw new Error(\n      'deletePreviousOneToAnyRelations can only be called for bidirectional oneToAny relations'\n    );\n  }\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn } = joinTable;\n\n  await createQueryBuilder(joinTable.name, db)\n    .delete()\n    .where({\n      [inverseJoinColumn.name]: relIdsToadd,\n      [joinColumn.name]: { $ne: id },\n    })\n    .where(joinTable.on || {})\n    .transacting(trx)\n    .execute();\n\n  await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToadd, transaction: trx });\n};\n\n/**\n * If a relation currently exists for this xToOne relations, this function removes it and update the inverse order if needed.\n */\nconst deletePreviousAnyToOneRelations = async ({\n  id,\n  attribute,\n  relIdToadd,\n  db,\n  transaction: trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  relIdToadd: ID;\n  db: Database;\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn } = joinTable;\n\n  if (!isAnyToOne(attribute)) {\n    throw new Error('deletePreviousAnyToOneRelations can only be called for anyToOne relations');\n  }\n  // handling manyToOne\n  if (isManyToAny(attribute)) {\n    // if the database integrity was not broken relsToDelete is supposed to be of length 1\n    const relsToDelete = await createQueryBuilder(joinTable.name, db)\n      .select(inverseJoinColumn.name)\n      .where({\n        [joinColumn.name]: id,\n        [inverseJoinColumn.name]: { $ne: relIdToadd },\n      })\n      .where(joinTable.on || {})\n      .transacting(trx)\n      .execute<{ [key: string]: ID }[]>();\n\n    const relIdsToDelete = map(inverseJoinColumn.name, relsToDelete);\n\n    await createQueryBuilder(joinTable.name, db)\n      .delete()\n      .where({\n        [joinColumn.name]: id,\n        [inverseJoinColumn.name]: { $in: relIdsToDelete },\n      })\n      .where(joinTable.on || {})\n      .transacting(trx)\n      .execute();\n\n    await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToDelete, transaction: trx });\n\n    // handling oneToOne\n  } else {\n    await createQueryBuilder(joinTable.name, db)\n      .delete()\n      .where({\n        [joinColumn.name]: id,\n        [inverseJoinColumn.name]: { $ne: relIdToadd },\n      })\n      .where(joinTable.on || {})\n      .transacting(trx)\n      .execute();\n  }\n};\n\n/**\n * Delete all or some relations of entity field\n */\nconst deleteRelations = async ({\n  id,\n  attribute,\n  db,\n  relIdsToNotDelete = [],\n  relIdsToDelete = [],\n  transaction: trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  db: Database;\n  relIdsToNotDelete?: ID[];\n  relIdsToDelete?: ID[] | 'all';\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn } = joinTable;\n  const all = relIdsToDelete === 'all';\n\n  if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\n    let lastId: ID = 0;\n    let done = false;\n    const batchSize = 100;\n\n    while (!done) {\n      const batchToDelete: { id: ID }[] = await createQueryBuilder(joinTable.name, db)\n        .select(inverseJoinColumn.name)\n        .where({\n          [joinColumn.name]: id,\n          id: { $gt: lastId },\n          [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },\n          ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),\n        })\n        .where(joinTable.on || {})\n        .orderBy('id')\n        .limit(batchSize)\n        .transacting(trx)\n        .execute();\n\n      done = batchToDelete.length < batchSize;\n      lastId = batchToDelete[batchToDelete.length - 1]?.id || 0;\n\n      const batchIds = map(inverseJoinColumn.name, batchToDelete);\n\n      await createQueryBuilder(joinTable.name, db)\n        .delete()\n        .where({\n          [joinColumn.name]: id,\n          [inverseJoinColumn.name]: { $in: batchIds },\n        })\n        .where(joinTable.on || {})\n        .transacting(trx)\n        .execute();\n\n      await cleanOrderColumns({ attribute, db, id, inverseRelIds: batchIds, transaction: trx });\n    }\n  } else {\n    await createQueryBuilder(joinTable.name, db)\n      .delete()\n      .where({\n        [joinColumn.name]: id,\n        [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },\n        ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),\n      })\n      .where(joinTable.on || {})\n      .transacting(trx)\n      .execute();\n  }\n};\n\n/**\n * Clean the order columns by ensuring the order value are continuous (ex: 1, 2, 3 and not 1, 5, 10)\n */\nconst cleanOrderColumns = async ({\n  id,\n  attribute,\n  db,\n  inverseRelIds = [],\n  transaction: trx,\n}: {\n  id?: ID;\n  attribute: Relation.Bidirectional;\n  db: Database;\n  inverseRelIds?: ID[];\n  transaction?: Knex.Transaction;\n}) => {\n  if (\n    !(hasOrderColumn(attribute) && id) &&\n    !(hasInverseOrderColumn(attribute) && !isEmpty(inverseRelIds))\n  ) {\n    return;\n  }\n\n  // Handle databases that don't support window function ROW_NUMBER (here it's MySQL 5)\n  if (!strapi.db.dialect.supportsWindowFunctions()) {\n    await cleanOrderColumnsForOldDatabases({ id, attribute, db, inverseRelIds, transaction: trx });\n    return;\n  }\n\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;\n\n  /**\n  UPDATE :joinTable: as a,\n  (\n    SELECT\n      id,\n      ROW_NUMBER() OVER ( PARTITION BY :joinColumn: ORDER BY :orderColumn:) AS src_order,\n    FROM :joinTable:\n    WHERE :joinColumn: = :id\n  ) AS b\n  SET :orderColumn: = b.src_order\n  WHERE b.id = a.id;\n  */\n  const updateOrderColumn = async () => {\n    if (!hasOrderColumn(attribute) || !id) {\n      return;\n    }\n\n    const selectRowsToOrder = (joinTableName: string) =>\n      db\n        .connection(joinTableName)\n        .select('id')\n        .rowNumber('src_order', orderColumnName, joinColumn.name)\n        .where(joinColumn.name, id)\n        .toSQL();\n\n    switch (strapi.db.dialect.client) {\n      case 'mysql': {\n        // Here it's MariaDB and MySQL 8\n        const select = selectRowsToOrder(joinTable.name);\n\n        await db\n          .getConnection()\n          .raw(\n            `UPDATE ?? as a, ( ${select.sql} ) AS b\n            SET ?? = b.src_order\n            WHERE b.id = a.id`,\n            [joinTable.name, ...select.bindings, orderColumnName]\n          )\n          .transacting(trx);\n\n        break;\n      }\n      default: {\n        const joinTableName = addSchema(db, joinTable.name);\n        const select = selectRowsToOrder(joinTableName);\n\n        // raw query as knex doesn't allow updating from a subquery\n        await db.connection\n          .raw(\n            `UPDATE ?? as a\n            SET ?? = b.src_order\n            FROM ( ${select.sql} ) AS b\n            WHERE b.id = a.id`,\n            [joinTableName, orderColumnName, ...select.bindings]\n          )\n          .transacting(trx);\n      }\n    }\n  };\n\n  /**\n  UPDATE :joinTable: as a,\n  (\n    SELECT\n      id,\n      ROW_NUMBER() OVER ( PARTITION BY :inverseJoinColumn: ORDER BY :inverseOrderColumn:) AS inv_order\n    FROM :joinTable:\n    WHERE :inverseJoinColumn: IN (:inverseRelIds)\n  ) AS b\n  SET :inverseOrderColumn: = b.inv_order\n  WHERE b.id = a.id;\n  */\n  const updateInverseOrderColumn = async () => {\n    if (!hasInverseOrderColumn(attribute) || isEmpty(inverseRelIds)) return;\n\n    const selectRowsToOrder = (joinTableName: string) =>\n      db\n        .connection(joinTableName)\n        .select('id')\n        .rowNumber('inv_order', inverseOrderColumnName, inverseJoinColumn.name)\n        .where(inverseJoinColumn.name, 'in', inverseRelIds)\n        .toSQL();\n\n    switch (strapi.db.dialect.client) {\n      case 'mysql': {\n        // Here it's MariaDB and MySQL 8\n        const select = selectRowsToOrder(joinTable.name);\n\n        await db\n          .getConnection()\n          .raw(\n            `UPDATE ?? as a, ( ${select.sql} ) AS b\n            SET ?? = b.inv_order\n            WHERE b.id = a.id`,\n            [joinTable.name, ...select.bindings, inverseOrderColumnName]\n          )\n          .transacting(trx);\n        break;\n      }\n      default: {\n        const joinTableName = addSchema(db, joinTable.name);\n        const select = selectRowsToOrder(joinTableName);\n\n        // raw query as knex doesn't allow updating from a subquery\n        await db.connection\n          .raw(\n            `UPDATE ?? as a\n            SET ?? = b.inv_order\n            FROM ( ${select.sql} ) AS b\n            WHERE b.id = a.id`,\n            [joinTableName, inverseOrderColumnName, ...select.bindings]\n          )\n          .transacting(trx);\n      }\n    }\n  };\n\n  return Promise.all([updateOrderColumn(), updateInverseOrderColumn()]);\n};\n\n/*\n * Ensure that orders are following a 1, 2, 3 sequence, without gap.\n * The use of a session variable instead of a window function makes the query compatible with MySQL 5\n */\nconst cleanOrderColumnsForOldDatabases = async ({\n  id,\n  attribute,\n  db,\n  inverseRelIds,\n  transaction: trx,\n}: {\n  id?: ID;\n  attribute: Relation.Bidirectional;\n  db: Database;\n  inverseRelIds: ID[];\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;\n\n  const randomSuffix = `${new Date().valueOf()}_${randomBytes(16).toString('hex')}`;\n\n  if (hasOrderColumn(attribute) && id) {\n    // raw query as knex doesn't allow updating from a subquery\n    // https://github.com/knex/knex/issues/2504\n    const orderVar = `order_${randomSuffix}`;\n    await db.connection.raw(`SET @${orderVar} = 0;`).transacting(trx);\n    await db.connection\n      .raw(\n        `UPDATE :joinTableName: as a, (\n          SELECT id, (@${orderVar}:=@${orderVar} + 1) AS src_order\n          FROM :joinTableName:\n\t        WHERE :joinColumnName: = :id\n\t        ORDER BY :orderColumnName:\n        ) AS b\n        SET :orderColumnName: = b.src_order\n        WHERE a.id = b.id\n        AND a.:joinColumnName: = :id`,\n        {\n          joinTableName: joinTable.name,\n          orderColumnName,\n          joinColumnName: joinColumn.name,\n          id,\n        }\n      )\n      .transacting(trx);\n  }\n\n  if (hasInverseOrderColumn(attribute) && !isEmpty(inverseRelIds)) {\n    const orderVar = `order_${randomSuffix}`;\n    const columnVar = `col_${randomSuffix}`;\n    await db.connection.raw(`SET @${orderVar} = 0;`).transacting(trx);\n    await db.connection\n      .raw(\n        `UPDATE ?? as a, (\n          SELECT\n          \tid,\n            @${orderVar}:=CASE WHEN @${columnVar} = ?? THEN @${orderVar} + 1 ELSE 1 END AS inv_order,\n        \t  @${columnVar}:=?? ??\n        \tFROM ?? a\n        \tWHERE ?? IN(${inverseRelIds.map(() => '?').join(', ')})\n        \tORDER BY ??, ??\n        ) AS b\n        SET ?? = b.inv_order\n        WHERE a.id = b.id\n        AND a.?? IN(${inverseRelIds.map(() => '?').join(', ')})`,\n        [\n          joinTable.name,\n          inverseJoinColumn.name,\n          inverseJoinColumn.name,\n          inverseJoinColumn.name,\n          joinTable.name,\n          inverseJoinColumn.name,\n          ...inverseRelIds,\n          inverseJoinColumn.name,\n          joinColumn.name,\n          inverseOrderColumnName,\n          inverseJoinColumn.name,\n          ...inverseRelIds,\n        ]\n      )\n      .transacting(trx);\n  }\n};\n\n/**\n * Use this when a relation is added or removed and its inverse order column\n * needs to be re-calculated\n *\n * Example: In this following table\n *\n *   | joinColumn      | inverseJoinColumn | order       | inverseOrder       |\n *   | --------------- | --------          | ----------- | ------------------ |\n *   | 1               | 1                 | 1           | 1                  |\n *   | 2               | 1                 | 3           | 2                  |\n *   | 2               | 2                 | 3           | 1                  |\n *\n * You add a new relation { joinColumn: 1, inverseJoinColumn: 2 }\n *\n *   | joinColumn      | inverseJoinColumn | order       | inverseOrder       |\n *   | --------------- | --------          | ----------- | ------------------ |\n *   | 1               | 1                 | 1           | 1                  |\n *   | 1               | 2                 | 2           | 1                  | <- inverseOrder should be 2\n *   | 2               | 1                 | 3           | 2                  |\n *   | 2               | 2                 | 3           | 1                  |\n *\n * This function would make such update, so all inverse order columns related\n * to the given id (1 in this example) are following a 1, 2, 3 sequence, without gap.\n *\n */\nconst cleanInverseOrderColumn = async ({\n  id,\n  attribute,\n  trx,\n}: {\n  id: ID;\n  attribute: Relation.Bidirectional;\n  trx: Knex.Transaction;\n}) => {\n  const con = strapi.db.connection;\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn, inverseOrderColumnName } = joinTable;\n\n  switch (strapi.db.dialect.client) {\n    /*\n      UPDATE `:joinTableName` AS `t1`\n      JOIN (\n          SELECT\n            `inverseJoinColumn`,\n            MAX(`:inverseOrderColumnName`) AS `max_inv_order`\n          FROM `:joinTableName`\n          GROUP BY `:inverseJoinColumn`\n      ) AS `t2`\n      ON `t1`.`:inverseJoinColumn` = `t2`.`:inverseJoinColumn`\n      SET `t1`.`:inverseOrderColumnNAme` = `t2`.`max_inv_order` + 1\n      WHERE `t1`.`:joinColumnName` = :id;\n    */\n    case 'mysql': {\n      // Group by the inverse join column and get the max value of the inverse order column\n      const subQuery = con(joinTable.name)\n        .select(inverseJoinColumn.name)\n        .max(inverseOrderColumnName, { as: 'max_inv_order' })\n        .groupBy(inverseJoinColumn.name)\n        .as('t2');\n\n      //  Update ids with the new inverse order\n      await con(`${joinTable.name} as t1`)\n        .join(subQuery, `t1.${inverseJoinColumn.name}`, '=', `t2.${inverseJoinColumn.name}`)\n        .where(joinColumn.name, id)\n        .update({\n          [inverseOrderColumnName]: con.raw('t2.max_inv_order + 1'),\n        })\n        .transacting(trx);\n      break;\n    }\n    default: {\n      /*\n        UPDATE `:joinTableName` as `t1`\n        SET `:inverseOrderColumnName` = (\n          SELECT max(`:inverseOrderColumnName`) + 1\n          FROM `:joinTableName` as `t2`\n          WHERE t2.:inverseJoinColumn = t1.:inverseJoinColumn\n        )\n        WHERE `t1`.`:joinColumnName` = :id\n      */\n      // New inverse order will be the max value + 1\n      const selectMaxInverseOrder = con.raw(`max(${inverseOrderColumnName}) + 1`);\n\n      const subQuery = con(`${joinTable.name} as t2`)\n        .select(selectMaxInverseOrder)\n        .whereRaw(`t2.${inverseJoinColumn.name} = t1.${inverseJoinColumn.name}`);\n\n      await con(`${joinTable.name} as t1`)\n        .where(`t1.${joinColumn.name}`, id)\n        .update({ [inverseOrderColumnName]: subQuery })\n        .transacting(trx);\n    }\n  }\n};\n\nexport {\n  deletePreviousOneToAnyRelations,\n  deletePreviousAnyToOneRelations,\n  deleteRelations,\n  cleanOrderColumns,\n  cleanInverseOrderColumn,\n};\n","import { castArray, maxBy } from 'lodash/fp';\nimport _ from 'lodash';\n\nimport { InvalidRelationError } from '../errors';\nimport type { ID } from '../types';\n\ninterface Link {\n  id: ID;\n  position?: { before?: ID; after?: ID; start?: true; end?: true };\n  order?: number;\n}\n\ninterface OrderedLink extends Link {\n  init?: boolean;\n  order: number;\n}\n\n/**\n * When connecting relations, the order you connect them matters.\n *\n * Example, if you connect the following relations:\n *   { id: 5, position: { before: 1 } }\n *   { id: 1, position: { before: 2 } }\n *   { id: 2, position: { end: true } }\n *\n * Going through the connect array, id 5 has to be connected before id 1,\n * so the order of id5 = id1 - 1. But the order value of id 1 is unknown.\n * The only way to know the order of id 1 is to connect it first.\n *\n * This function makes sure the relations are connected in the right order:\n *   { id: 2, position: { end: true } }\n *   { id: 1, position: { before: 2 } }\n *   { id: 5, position: { before: 1 } }\n *\n */\nconst sortConnectArray = (connectArr: Link[], initialArr: Link[] = [], strictSort = true) => {\n  const sortedConnect: Link[] = [];\n  // Boolean to know if we have to recalculate the order of the relations\n  let needsSorting = false;\n  // Map to validate if relation is already in sortedConnect or DB.\n  const relationInInitialArray = initialArr.reduce(\n    (acc, rel) => ({ ...acc, [rel.id]: true }),\n    {} as Record<ID, boolean>\n  );\n  // Map to store the first index where a relation id is connected\n  const mappedRelations = connectArr.reduce((mapper, relation: Link) => {\n    const adjacentRelId = relation.position?.before || relation.position?.after;\n\n    if (!adjacentRelId || (!relationInInitialArray[adjacentRelId] && !mapper[adjacentRelId])) {\n      needsSorting = true;\n    }\n\n    // If the relation is already in the array, throw an error\n    if (mapper[relation.id]) {\n      throw new InvalidRelationError(\n        `The relation with id ${relation.id} is already connected. ` +\n          'You cannot connect the same relation twice.'\n      );\n    }\n\n    return {\n      [relation.id]: { ...relation, computed: false },\n      ...mapper,\n    };\n  }, {} as Record<ID, Link & { computed: boolean }>);\n\n  // If we don't need to sort the connect array, we can return it as is\n  if (!needsSorting) return connectArr;\n\n  // Recursively compute in which order the relation should be connected\n  const computeRelation = (relation: Link, relationsSeenInBranch: Record<ID, boolean>) => {\n    const adjacentRelId = relation.position?.before || relation.position?.after;\n    const adjacentRelation = mappedRelations[adjacentRelId as ID];\n\n    // If the relation has already been seen in the current branch,\n    // it means there is a circular reference\n    if (adjacentRelId && relationsSeenInBranch[adjacentRelId]) {\n      throw new InvalidRelationError(\n        'A circular reference was found in the connect array. ' +\n          'One relation is trying to connect before/after another one that is trying to connect before/after it'\n      );\n    }\n\n    // This relation has already been computed\n    if (mappedRelations[relation.id]?.computed) {\n      return;\n    }\n\n    mappedRelations[relation.id].computed = true;\n\n    // Relation does not have a before or after attribute or is in the initial array\n    if (!adjacentRelId || relationInInitialArray[adjacentRelId]) {\n      sortedConnect.push(relation);\n      return;\n    }\n\n    // Look if id is referenced elsewhere in the array\n    if (mappedRelations[adjacentRelId]) {\n      computeRelation(adjacentRelation, { ...relationsSeenInBranch, [relation.id]: true });\n      sortedConnect.push(relation);\n    } else if (strictSort) {\n      // If we reach this point, it means that the adjacent relation is not in the connect array\n      // and it is not in the database.\n      throw new InvalidRelationError(\n        `There was a problem connecting relation with id ${\n          relation.id\n        } at position ${JSON.stringify(\n          relation.position\n        )}. The relation with id ${adjacentRelId} needs to be connected first.`\n      );\n    } else {\n      // We are in non-strict mode so we can push the relation.\n      sortedConnect.push({ id: relation.id, position: { end: true } });\n    }\n  };\n\n  // Iterate over connectArr and populate sortedConnect\n  connectArr.forEach((relation) => computeRelation(relation, {}));\n\n  return sortedConnect;\n};\n\n/**\n * Responsible for calculating the relations order when connecting them.\n *\n * The connect method takes an array of relations with positional attributes:\n * - before: the id of the relation to connect before\n * - after: the id of the relation to connect after\n * - end: it should be at the end\n * - start: it should be at the start\n *\n * Example:\n *  - Having a connect array like:\n *      [ { id: 4, before: 2 }, { id: 4, before: 3}, {id: 5, before: 4} ]\n * - With the initial relations:\n *      [ { id: 2, order: 4 }, { id: 3, order: 10 } ]\n * - Step by step, going through the connect array, the array of relations would be:\n *      [ { id: 4, order: 3.5 }, { id: 2, order: 4 }, { id: 3, order: 10 } ]\n *      [ { id: 2, order: 4 }, { id: 4, order: 3.5 }, { id: 3, order: 10 } ]\n *      [ { id: 2, order: 4 }, { id: 5, order: 3.5 },  { id: 4, order: 3.5 }, { id: 3, order: 10 } ]\n * - The final step would be to recalculate fractional order values.\n *      [ { id: 2, order: 4 }, { id: 5, order: 3.33 },  { id: 4, order: 3.66 }, { id: 3, order: 10 } ]\n *\n * @param {Array<*>} initArr - array of relations to initialize the class with\n * @param {string} idColumn - the column name of the id\n * @param {string} orderColumn - the column name of the order\n * @param {boolean} strict - if true, will throw an error if a relation is connected adjacent to\n *                               another one that does not exist\n * @return {*}\n */\nconst relationsOrderer = <TRelation extends Record<string, ID | number | null>>(\n  initArr: TRelation[],\n  idColumn: keyof TRelation,\n  orderColumn: keyof TRelation,\n  strict?: boolean\n) => {\n  const computedRelations: OrderedLink[] = castArray(initArr ?? []).map((r) => ({\n    init: true,\n    id: r[idColumn] as ID,\n    order: Number(r[orderColumn]) || 1,\n  }));\n\n  const maxOrder = maxBy('order', computedRelations)?.order || 0;\n\n  const findRelation = (id: ID) => {\n    const idx = computedRelations.findIndex((r) => r.id === id);\n    return { idx, relation: computedRelations[idx] };\n  };\n\n  const removeRelation = (r: Link) => {\n    const { idx } = findRelation(r.id);\n    if (idx >= 0) {\n      computedRelations.splice(idx, 1);\n    }\n  };\n\n  const insertRelation = (r: Link) => {\n    let idx;\n\n    if (r.position?.before) {\n      const { idx: _idx, relation } = findRelation(r.position.before);\n      if (relation.init) {\n        r.order = relation.order - 0.5;\n      } else {\n        r.order = relation.order;\n      }\n      idx = _idx;\n    } else if (r.position?.after) {\n      const { idx: _idx, relation } = findRelation(r.position.after);\n      if (relation.init) {\n        r.order = relation.order + 0.5;\n      } else {\n        r.order = relation.order;\n      }\n\n      idx = _idx + 1;\n    } else if (r.position?.start) {\n      r.order = 0.5;\n      idx = 0;\n    } else {\n      r.order = maxOrder + 0.5;\n      idx = computedRelations.length;\n    }\n\n    // Insert the relation in the array\n    computedRelations.splice(idx, 0, r as OrderedLink);\n  };\n\n  return {\n    disconnect(relations: Link | Link[]) {\n      castArray(relations).forEach((relation) => {\n        removeRelation(relation);\n      });\n      return this;\n    },\n    connect(relations: Link | Link[]) {\n      sortConnectArray(castArray(relations), computedRelations, strict).forEach((relation) => {\n        this.disconnect(relation);\n\n        try {\n          insertRelation(relation);\n        } catch (err) {\n          throw new Error(\n            `There was a problem connecting relation with id ${\n              relation.id\n            } at position ${JSON.stringify(\n              relation.position\n            )}. The list of connect relations is not valid`\n          );\n        }\n      });\n      return this;\n    },\n    get() {\n      return computedRelations;\n    },\n    /**\n     * Get a map between the relation id and its order\n     */\n    getOrderMap() {\n      return _(computedRelations)\n        .groupBy('order')\n        .reduce((acc, relations) => {\n          if (relations[0]?.init) return acc;\n          relations.forEach((relation, idx) => {\n            acc[relation.id] = Math.floor(relation.order) + (idx + 1) / (relations.length + 1);\n          });\n          return acc;\n        }, {} as Record<ID, number>);\n    },\n  };\n};\n\nexport { relationsOrderer, sortConnectArray };\n","import { Knex } from 'knex';\n\nimport { cleanInverseOrderColumn } from '../../regular-relations';\nimport type { ID, Relation } from '../../../types';\n\nconst replaceRegularRelations = async ({\n  targetId,\n  sourceId,\n  attribute,\n  omitIds,\n  transaction: trx,\n}: {\n  targetId: ID;\n  sourceId: ID;\n  attribute: Relation.Bidirectional;\n  omitIds: ID[];\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n\n  const { joinColumn, inverseJoinColumn } = joinTable;\n\n  // We are effectively stealing the relation from the cloned entity\n  await strapi.db.entityManager\n    .createQueryBuilder(joinTable.name)\n    .update({ [joinColumn.name]: targetId })\n    .where({ [joinColumn.name]: sourceId })\n    .where({ $not: { [inverseJoinColumn.name]: omitIds } })\n    .onConflict([joinColumn.name, inverseJoinColumn.name])\n    .ignore()\n    .transacting(trx)\n    .execute();\n};\n\nconst cloneRegularRelations = async ({\n  targetId,\n  sourceId,\n  attribute,\n  transaction: trx,\n}: {\n  targetId: ID;\n  sourceId: ID;\n  attribute: Relation.Bidirectional;\n  transaction?: Knex.Transaction;\n}) => {\n  const { joinTable } = attribute;\n  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;\n  const connection = strapi.db.getConnection();\n\n  // Get the columns to select\n  const columns = [joinColumn.name, inverseJoinColumn.name];\n  if (orderColumnName) {\n    columns.push(orderColumnName);\n  }\n\n  if (inverseOrderColumnName) {\n    columns.push(inverseOrderColumnName);\n  }\n\n  if (joinTable.on) {\n    columns.push(...Object.keys(joinTable.on));\n  }\n\n  const selectStatement = connection\n    .select(\n      // Override joinColumn with the new id\n      { [joinColumn.name]: targetId },\n      // The rest of columns will be the same\n      ...columns.slice(1)\n    )\n    .where(joinColumn.name, sourceId)\n    .from(joinTable.name)\n    .toSQL();\n\n  // Insert the clone relations\n  await strapi.db.entityManager\n    .createQueryBuilder(joinTable.name)\n    .insert(\n      strapi.db.connection.raw(\n        `(${columns.join(',')})  ${selectStatement.sql}`,\n        selectStatement.bindings\n      )\n    )\n    .onConflict([joinColumn.name, inverseJoinColumn.name])\n    .ignore()\n    .transacting(trx)\n    .execute();\n\n  // Clean the inverse order column\n  if (inverseOrderColumnName) {\n    await cleanInverseOrderColumn({\n      id: targetId,\n      attribute,\n      trx: trx as Knex.Transaction,\n    });\n  }\n};\n\nexport { replaceRegularRelations, cloneRegularRelations };\n","import {\n  castArray,\n  compact,\n  difference,\n  differenceWith,\n  flow,\n  has,\n  isArray,\n  isEmpty,\n  isEqual,\n  isInteger,\n  isNil,\n  isNull,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  isUndefined,\n  map,\n  mergeWith,\n  omit,\n  pick,\n  uniqBy,\n  uniqWith,\n} from 'lodash/fp';\n\nimport { mapAsync } from '@strapi/utils';\nimport * as types from '../utils/types';\nimport { createField } from '../fields';\nimport { createQueryBuilder } from '../query';\nimport { createRepository } from './entity-repository';\nimport { deleteRelatedMorphOneRelationsAfterMorphToManyUpdate } from './morph-relations';\nimport {\n  isPolymorphic,\n  isBidirectional,\n  isAnyToOne,\n  isOneToAny,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n} from '../metadata';\nimport {\n  deletePreviousOneToAnyRelations,\n  deletePreviousAnyToOneRelations,\n  deleteRelations,\n  cleanOrderColumns,\n} from './regular-relations';\nimport { relationsOrderer } from './relations-orderer';\nimport {\n  replaceRegularRelations,\n  cloneRegularRelations,\n} from './relations/cloning/regular-relations';\nimport { DatabaseError } from '../errors';\nimport type { Database } from '..';\nimport type { Meta } from '../metadata';\nimport type { ID } from '../types';\nimport { EntityManager, Repository, Entity } from './types';\n\nexport * from './types';\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n  isObject(value) && !isNil(value);\n\nconst toId = (value: unknown | { id: unknown }): ID => {\n  if (isRecord(value) && 'id' in value && isValidId(value.id)) {\n    return value.id;\n  }\n\n  if (isValidId(value)) {\n    return value;\n  }\n\n  throw new Error(`Invalid id, expected a string or integer, got ${value}`);\n};\nconst toIds = (value: unknown): ID[] => castArray(value || []).map(toId);\n\nconst isValidId = (value: unknown): value is ID => isString(value) || isInteger(value);\n\nconst isValidObjectId = (value: unknown): value is Entity =>\n  isRecord(value) && 'id' in value && isValidId(value.id);\n\nconst toIdArray = (\n  data: unknown\n): {\n  id: ID;\n  __pivot?: { [key: string]: any };\n  [key: string]: any;\n}[] => {\n  const array = castArray(data)\n    .filter((datum) => !isNil(datum))\n    .map((datum) => {\n      // if it is a string or an integer return an obj with id = to datum\n      if (isValidId(datum)) {\n        return { id: datum, __pivot: {} };\n      }\n\n      // if it is an object check it has at least a valid id\n      if (!isValidObjectId(datum)) {\n        throw new Error(`Invalid id, expected a string or integer, got ${datum}`);\n      }\n\n      return datum;\n    });\n\n  return uniqWith(isEqual, array);\n};\n\ntype ScalarAssoc = string | number | null;\ntype Assocs =\n  | ScalarAssoc\n  | { id: ScalarAssoc | Array<ScalarAssoc> }\n  | Array<ScalarAssoc>\n  | {\n      set?: Array<ScalarAssoc> | null;\n      options?: { strict?: boolean };\n      connect?: Array<{\n        id: ScalarAssoc;\n        position?: { start?: boolean; end?: boolean; before?: ID; after?: ID };\n        __pivot?: any;\n      }> | null;\n      disconnect?: Array<ScalarAssoc> | null;\n    };\n\nconst toAssocs = (data: Assocs) => {\n  if (\n    isArray(data) ||\n    isString(data) ||\n    isNumber(data) ||\n    isNull(data) ||\n    (isRecord(data) && 'id' in data)\n  ) {\n    return {\n      set: isNull(data) ? data : toIdArray(data),\n    };\n  }\n\n  if (data?.set) {\n    return {\n      set: isNull(data.set) ? data.set : toIdArray(data.set),\n    };\n  }\n\n  return {\n    options: {\n      strict: data?.options?.strict,\n    },\n    connect: toIdArray(data?.connect).map((elm) => ({\n      id: elm.id,\n      position: elm.position ? elm.position : { end: true },\n      __pivot: elm.__pivot ?? {},\n    })),\n    disconnect: toIdArray(data?.disconnect),\n  };\n};\n\nconst processData = (\n  metadata: Meta,\n  data: Record<string, unknown> = {},\n  { withDefaults = false } = {}\n) => {\n  const { attributes } = metadata;\n\n  const obj: Record<string, unknown> = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (types.isScalarAttribute(attribute)) {\n      const field = createField(attribute);\n\n      if (isUndefined(data[attributeName])) {\n        if (!isUndefined(attribute.default) && withDefaults) {\n          if (typeof attribute.default === 'function') {\n            obj[attributeName] = attribute.default();\n          } else {\n            obj[attributeName] = attribute.default;\n          }\n        }\n        continue;\n      }\n\n      if (\n        'validate' in field &&\n        typeof field.validate === 'function' &&\n        data[attributeName] !== null\n      ) {\n        field.validate(data[attributeName]);\n      }\n\n      const val = data[attributeName] === null ? null : field.toDB(data[attributeName]);\n\n      obj[attributeName] = val;\n    }\n\n    if (types.isRelationalAttribute(attribute)) {\n      // oneToOne & manyToOne\n      if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // allow setting to null\n        const attrValue = !isUndefined(data[attributeName])\n          ? data[attributeName]\n          : data[joinColumnName];\n\n        if (!isUndefined(attrValue)) {\n          obj[joinColumnName] = attrValue;\n        }\n\n        continue;\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\n        const { idColumn, typeColumn, typeField = '__type' } = attribute.morphColumn;\n\n        const value = data[attributeName] as Record<string, unknown>;\n\n        if (value === null) {\n          Object.assign(obj, {\n            [idColumn.name]: null,\n            [typeColumn.name]: null,\n          });\n\n          continue;\n        }\n\n        if (!isUndefined(value)) {\n          if (!has('id', value) || !has(typeField, value)) {\n            throw new Error(`Expects properties ${typeField} an id to make a morph association`);\n          }\n\n          Object.assign(obj, {\n            [idColumn.name]: value.id,\n            [typeColumn.name]: value[typeField],\n          });\n        }\n      }\n    }\n  }\n\n  return obj;\n};\nexport const createEntityManager = (db: Database): EntityManager => {\n  const repoMap: Record<string, Repository> = {};\n\n  return {\n    async findOne(uid, params) {\n      const states = await db.lifecycles.run('beforeFindOne', uid, { params });\n\n      const result = await this.createQueryBuilder(uid)\n        .init(params)\n        .first()\n        .execute<Entity | null>();\n\n      await db.lifecycles.run('afterFindOne', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // should we name it findOne because people are used to it ?\n    async findMany(uid, params) {\n      const states = await db.lifecycles.run('beforeFindMany', uid, { params });\n\n      const result = await this.createQueryBuilder(uid).init(params).execute<any[]>();\n\n      await db.lifecycles.run('afterFindMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async count(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCount', uid, { params });\n\n      const res = await this.createQueryBuilder(uid)\n        .init(pick(['_q', 'where', 'filters'], params))\n        .count()\n        .first()\n        .execute<{ count: number }>();\n\n      const result = Number(res.count);\n\n      await db.lifecycles.run('afterCount', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async create(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCreate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isPlainObject(data)) {\n        throw new Error('Create expects a data object');\n      }\n\n      const dataToInsert = processData(metadata, data, { withDefaults: true });\n\n      const res = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const id = isRecord(res[0]) ? res[0].id : res[0];\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.attachRelations(uid, id, data, { transaction: trx.get() });\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).delete().execute();\n        throw e;\n      }\n\n      // TODO: in case there is no select or populate specified return the inserted data ?\n      // TODO: do not trigger the findOne lifecycles ?\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n      });\n\n      await db.lifecycles.run('afterCreate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async createMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCreateMany', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isArray(data)) {\n        throw new Error('CreateMany expects data to be an array');\n      }\n\n      const dataToInsert = data.map((datum) =>\n        processData(metadata, datum, { withDefaults: true })\n      );\n\n      if (isEmpty(dataToInsert)) {\n        throw new Error('Nothing to insert');\n      }\n\n      const createdEntries = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const result = {\n        count: data.length,\n        ids: createdEntries.map((entry) => (typeof entry === 'object' ? entry?.id : entry)),\n      };\n\n      await db.lifecycles.run('afterCreateMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async update(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeUpdate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { where, data } = params;\n\n      if (!isPlainObject(data)) {\n        throw new Error('Update requires a data object');\n      }\n\n      if (isEmpty(where)) {\n        throw new Error('Update requires a where parameter');\n      }\n\n      const entity = await this.createQueryBuilder(uid)\n        .select('*')\n        .where(where)\n        .first()\n        .execute<{ id: ID }>({ mapResults: false });\n\n      if (!entity) {\n        return null;\n      }\n\n      const { id } = entity;\n\n      const dataToUpdate = processData(metadata, data);\n\n      if (!isEmpty(dataToUpdate)) {\n        await this.createQueryBuilder(uid).where({ id }).update(dataToUpdate).execute();\n      }\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.updateRelations(uid, id, data, { transaction: trx.get() });\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).update(entity).execute();\n        throw e;\n      }\n\n      // TODO: do not trigger the findOne lifecycles ?\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n      });\n\n      await db.lifecycles.run('afterUpdate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async updateMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeUpdateMany', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { where, data } = params;\n\n      const dataToUpdate = processData(metadata, data);\n\n      if (isEmpty(dataToUpdate)) {\n        throw new Error('Update requires data');\n      }\n\n      const updatedRows = await this.createQueryBuilder(uid)\n        .where(where)\n        .update(dataToUpdate)\n        .execute<number>();\n\n      const result = { count: updatedRows };\n\n      await db.lifecycles.run('afterUpdateMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async clone(uid, cloneId, params = {}) {\n      const states = await db.lifecycles.run('beforeCreate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isNil(data) && !isPlainObject(data)) {\n        throw new Error('Create expects a data object');\n      }\n\n      // TODO: Handle join columns?\n      const entity = await this.findOne(uid, { where: { id: cloneId } });\n\n      const dataToInsert = flow(\n        // Omit unwanted properties\n        omit(['id', 'created_at', 'updated_at']),\n        // Merge with provided data, set attribute to null if data attribute is null\n        mergeWith(data || {}, (original: unknown, override: unknown) =>\n          override === null ? override : original\n        ),\n        // Process data with metadata\n        (entity: Record<string, unknown>) => processData(metadata, entity, { withDefaults: true })\n      )(entity);\n\n      const res = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const id = isRecord(res[0]) ? res[0].id : res[0];\n\n      const trx = await strapi.db.transaction();\n      try {\n        const cloneAttrs = Object.entries(metadata.attributes).reduce((acc, [attrName, attr]) => {\n          // TODO: handle components in the db layer\n          if (\n            types.isRelationalAttribute(attr) &&\n            'joinTable' in attr &&\n            attr.joinTable &&\n            !('component' in attr)\n          ) {\n            acc.push(attrName);\n          }\n          return acc;\n        }, [] as string[]);\n\n        await this.cloneRelations(uid, id, cloneId, data, { cloneAttrs, transaction: trx.get() });\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).delete().execute();\n        throw e;\n      }\n\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n      });\n\n      await db.lifecycles.run('afterCreate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async delete(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeDelete', uid, { params });\n\n      const { where, select, populate } = params;\n\n      if (isEmpty(where)) {\n        throw new Error('Delete requires a where parameter');\n      }\n\n      // TODO: do not trigger the findOne lifecycles ?\n      const entity = await this.findOne(uid, {\n        select: select && ['id'].concat(select),\n        where,\n        populate,\n      });\n\n      if (!entity) {\n        return null;\n      }\n\n      const { id } = entity;\n\n      await this.createQueryBuilder(uid).where({ id }).delete().execute();\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.deleteRelations(uid, id, { transaction: trx.get() });\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        throw e;\n      }\n\n      await db.lifecycles.run('afterDelete', uid, { params, result: entity }, states);\n\n      return entity;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async deleteMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeDeleteMany', uid, { params });\n\n      const { where } = params;\n\n      const deletedRows = await this.createQueryBuilder(uid)\n        .where(where)\n        .delete()\n        .execute<number>();\n\n      const result = { count: deletedRows };\n\n      await db.lifecycles.run('afterDeleteMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    /**\n     * Attach relations to a new entity\n     */\n    async attachRelations(uid, id, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        const isValidLink = has(attributeName, data) && !isNil(data[attributeName]);\n\n        if (attribute.type !== 'relation' || !isValidLink) {\n          continue;\n        }\n\n        const cleanRelationData = toAssocs(data[attributeName]);\n\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n          if (targetAttribute.type !== 'relation') {\n            throw new Error(\n              `Expected target attribute ${target}.${morphBy} to be a relation attribute`\n            );\n          }\n\n          if (targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            const relId = toId(cleanRelationData.set?.[0]);\n\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .where({ id: relId })\n              .transacting(trx)\n              .execute();\n          } else if (targetAttribute.relation === 'morphToMany') {\n            const { joinTable } = targetAttribute;\n            const { joinColumn, morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            if (isEmpty(cleanRelationData.set)) {\n              continue;\n            }\n\n            const rows =\n              cleanRelationData.set?.map((data, idx) => {\n                return {\n                  [joinColumn.name]: data.id,\n                  [idColumn.name]: id,\n                  [typeColumn.name]: uid,\n                  ...(('on' in joinTable && joinTable.on) || {}),\n                  ...(data.__pivot || {}),\n                  order: idx + 1,\n                  field: attributeName,\n                };\n              }) ?? [];\n\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n          }\n\n          continue;\n        } else if (attribute.relation === 'morphToOne') {\n          // handled on the entry itself\n          continue;\n        } else if (attribute.relation === 'morphToMany') {\n          const { joinTable } = attribute;\n          const { joinColumn, morphColumn } = joinTable;\n\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n          if (isEmpty(cleanRelationData.set)) {\n            continue;\n          }\n\n          const rows =\n            cleanRelationData.set?.map((data, idx) => ({\n              [joinColumn.name]: id,\n              [idColumn.name]: data.id,\n              [typeColumn.name]: data[typeField],\n              ...(('on' in joinTable && joinTable.on) || {}),\n              ...(data.__pivot || {}),\n              order: idx + 1,\n            })) ?? [];\n\n          // delete previous relations\n          await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows as any, {\n            uid,\n            attributeName,\n            joinTable,\n            db,\n            transaction: trx,\n          });\n\n          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n\n          continue;\n        }\n\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          const relIdsToAdd = toIds(cleanRelationData.set);\n          if (\n            attribute.relation === 'oneToOne' &&\n            isBidirectional(attribute) &&\n            relIdsToAdd.length\n          ) {\n            await this.createQueryBuilder(uid)\n              .where({ [attribute.joinColumn.name]: relIdsToAdd, id: { $ne: id } })\n              .update({ [attribute.joinColumn.name]: null })\n              .transacting(trx)\n              .execute();\n          }\n\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          // TODO: check it is an id & the entity exists (will throw due to FKs otherwise so not a big pbl in SQL)\n          const relIdsToAdd = toIds(cleanRelationData.set);\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n\n          await this.createQueryBuilder(target)\n            .update({ [attribute.joinColumn.referencedColumn]: id })\n            // NOTE: works if it is an array or a single id\n            .where({ id: relIdsToAdd })\n            .transacting(trx)\n            .execute();\n        }\n\n        if ('joinTable' in attribute && attribute.joinTable) {\n          // need to set the column on the target\n\n          const { joinTable } = attribute;\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\n            joinTable;\n\n          const relsToAdd = (cleanRelationData.set || cleanRelationData.connect) ?? [];\n          const relIdsToadd = toIds(relsToAdd);\n\n          if (isBidirectional(attribute) && isOneToAny(attribute)) {\n            await deletePreviousOneToAnyRelations({\n              id,\n              attribute,\n              relIdsToadd,\n              db,\n              transaction: trx,\n            });\n          }\n\n          // prepare new relations to insert\n          const insert = uniqBy('id', relsToAdd).map((data) => {\n            return {\n              [joinColumn.name]: id,\n              [inverseJoinColumn.name]: data.id,\n              ...(('on' in joinTable && joinTable.on) || {}),\n              ...(data.__pivot || {}),\n            };\n          }) as Record<string, any>[];\n\n          // add order value\n          if (cleanRelationData.set && hasOrderColumn(attribute)) {\n            insert.forEach((data: Record<string, unknown>, idx) => {\n              data[orderColumnName] = idx + 1;\n            });\n          } else if (cleanRelationData.connect && hasOrderColumn(attribute)) {\n            // use position attributes to calculate order\n            const orderMap = relationsOrderer(\n              [],\n              inverseJoinColumn.name,\n              joinTable.orderColumnName,\n              true // Always make an strict connect when inserting\n            )\n              .connect(relsToAdd)\n              .get()\n              // set the order based on the order of the ids\n              .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {} as Record<ID, number>);\n\n            insert.forEach((row: Record<string, unknown>) => {\n              row[orderColumnName] = orderMap[row[inverseJoinColumn.name] as number];\n            });\n          }\n\n          // add inv_order value\n          if (hasInverseOrderColumn(attribute)) {\n            const maxResults = await db\n              .getConnection()\n              .select(inverseJoinColumn.name)\n              .max(inverseOrderColumnName, { as: 'max' })\n              .whereIn(inverseJoinColumn.name, relIdsToadd)\n              .where(joinTable.on || {})\n              .groupBy(inverseJoinColumn.name)\n              .from(joinTable.name)\n              .transacting(trx);\n\n            const maxMap = maxResults.reduce(\n              (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n              {} as Record<string, number>\n            );\n\n            insert.forEach((rel) => {\n              rel[inverseOrderColumnName] = (maxMap[rel[inverseJoinColumn.name]] || 0) + 1;\n            });\n          }\n\n          if (insert.length === 0) {\n            continue;\n          }\n\n          // insert new relations\n          await this.createQueryBuilder(joinTable.name).insert(insert).transacting(trx).execute();\n        }\n      }\n    },\n\n    /**\n     * Updates relations of an existing entity\n     */\n    // TODO: check relation exists (handled by FKs except for polymorphics)\n    async updateRelations(uid, id, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        if (attribute.type !== 'relation' || !has(attributeName, data)) {\n          continue;\n        }\n        const cleanRelationData = toAssocs(data[attributeName]);\n\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            // update instead of deleting because the relation is directly on the entity table\n            // and not in a join table\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .transacting(trx)\n              .execute();\n\n            if (!isNull(cleanRelationData.set)) {\n              const relId = toIds(cleanRelationData.set?.[0]);\n              await this.createQueryBuilder(target)\n                .update({ [idColumn.name]: id, [typeColumn.name]: uid })\n                .where({ id: relId })\n                .transacting(trx)\n                .execute();\n            }\n          } else if (\n            targetAttribute.type === 'relation' &&\n            targetAttribute.relation === 'morphToMany'\n          ) {\n            const { joinTable } = targetAttribute;\n            const { joinColumn, morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                field: attributeName,\n              })\n              .transacting(trx)\n              .execute();\n\n            if (isEmpty(cleanRelationData.set)) {\n              continue;\n            }\n\n            const rows = cleanRelationData.set?.map((data, idx) => ({\n              [joinColumn.name]: data.id,\n              [idColumn.name]: id,\n              [typeColumn.name]: uid,\n              ...(joinTable.on || {}),\n              ...(data.__pivot || {}),\n              order: idx + 1,\n              field: attributeName,\n            })) as Record<string, any>;\n\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n          }\n\n          continue;\n        }\n\n        if (attribute.relation === 'morphToOne') {\n          // handled on the entry itself\n          continue;\n        }\n\n        if (attribute.relation === 'morphToMany') {\n          const { joinTable } = attribute;\n          const { joinColumn, morphColumn } = joinTable;\n\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n          await this.createQueryBuilder(joinTable.name)\n            .delete()\n            .where({\n              [joinColumn.name]: id,\n              ...(joinTable.on || {}),\n            })\n            .transacting(trx)\n            .execute();\n\n          if (isEmpty(cleanRelationData.set)) {\n            continue;\n          }\n\n          const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\n            [joinColumn.name]: id,\n            [idColumn.name]: data.id,\n            [typeColumn.name]: data[typeField],\n            ...(joinTable.on || {}),\n            ...(data.__pivot || {}),\n            order: idx + 1,\n          })) as Record<string, any>[];\n\n          // delete previous relations\n          await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows, {\n            uid,\n            attributeName,\n            joinTable,\n            db,\n            transaction: trx,\n          });\n\n          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n\n          continue;\n        }\n\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          // handled in the row itself\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side.\n        // Since it is a join column no need to remove previous relations\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n\n          if (!isNull(cleanRelationData.set)) {\n            const relIdsToAdd = toIds(cleanRelationData.set);\n            await this.createQueryBuilder(target)\n              .where({ id: relIdsToAdd })\n              .update({ [attribute.joinColumn.referencedColumn]: id })\n              .transacting(trx)\n              .execute();\n          }\n        }\n\n        if (attribute.joinTable) {\n          const { joinTable } = attribute;\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\n            joinTable;\n          const select = [joinColumn.name, inverseJoinColumn.name];\n          if (hasOrderColumn(attribute)) {\n            select.push(orderColumnName);\n          }\n          if (hasInverseOrderColumn(attribute)) {\n            select.push(inverseOrderColumnName);\n          }\n\n          // only delete relations\n          if (isNull(cleanRelationData.set)) {\n            await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\n          } else {\n            const isPartialUpdate = !has('set', cleanRelationData);\n            let relIdsToaddOrMove: ID[];\n\n            if (isPartialUpdate) {\n              if (isAnyToOne(attribute)) {\n                cleanRelationData.connect = cleanRelationData.connect?.slice(-1);\n              }\n              relIdsToaddOrMove = toIds(cleanRelationData.connect);\n              const relIdsToDelete = toIds(\n                differenceWith(\n                  isEqual,\n                  cleanRelationData.disconnect,\n                  cleanRelationData.connect ?? []\n                )\n              );\n\n              if (!isEmpty(relIdsToDelete)) {\n                await deleteRelations({ id, attribute, db, relIdsToDelete, transaction: trx });\n              }\n\n              if (isEmpty(cleanRelationData.connect)) {\n                continue;\n              }\n\n              // Fetch current relations to handle ordering\n              let currentMovingRels: Record<string, ID>[] = [];\n\n              if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\n                currentMovingRels = await this.createQueryBuilder(joinTable.name)\n                  .select(select)\n                  .where({\n                    [joinColumn.name]: id,\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute();\n              }\n\n              // prepare relations to insert\n              const insert = uniqBy('id', cleanRelationData.connect).map((relToAdd) => ({\n                [joinColumn.name]: id,\n                [inverseJoinColumn.name]: relToAdd.id,\n                ...(joinTable.on || {}),\n                ...(relToAdd.__pivot || {}),\n              }));\n\n              if (hasOrderColumn(attribute)) {\n                // Get all adjacent relations and the one with the highest order\n                const adjacentRelations = await this.createQueryBuilder(joinTable.name)\n                  .where({\n                    $or: [\n                      {\n                        [joinColumn.name]: id,\n                        [inverseJoinColumn.name]: {\n                          $in: compact(\n                            cleanRelationData.connect?.map(\n                              (r) => r.position?.after || r.position?.before\n                            )\n                          ),\n                        },\n                      },\n                      {\n                        [joinColumn.name]: id,\n                        [orderColumnName]: this.createQueryBuilder(joinTable.name)\n                          .max(orderColumnName)\n                          .where({ [joinColumn.name]: id })\n                          .where(joinTable.on || {})\n                          .transacting(trx)\n                          .getKnexQuery(),\n                      },\n                    ],\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute<Array<Record<string, any>>>();\n\n                const orderMap = relationsOrderer(\n                  adjacentRelations,\n                  inverseJoinColumn.name,\n                  joinTable.orderColumnName,\n                  cleanRelationData.options?.strict\n                )\n                  .connect(cleanRelationData.connect ?? [])\n                  .getOrderMap();\n\n                insert.forEach((row) => {\n                  row[orderColumnName] = orderMap[row[inverseJoinColumn.name]];\n                });\n              }\n\n              // add inv order value\n              if (hasInverseOrderColumn(attribute)) {\n                const nonExistingRelsIds: ID[] = difference(\n                  relIdsToaddOrMove,\n                  map(inverseJoinColumn.name, currentMovingRels)\n                );\n\n                const maxResults = await db\n                  .getConnection()\n                  .select(inverseJoinColumn.name)\n                  .max(inverseOrderColumnName, { as: 'max' })\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\n                  .where(joinTable.on || {})\n                  .groupBy(inverseJoinColumn.name)\n                  .from(joinTable.name)\n                  .transacting(trx);\n\n                const maxMap = maxResults.reduce(\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n                  {}\n                );\n\n                insert.forEach((row) => {\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\n                });\n              }\n\n              // insert rows\n              const query = this.createQueryBuilder(joinTable.name)\n                .insert(insert)\n                .onConflict(joinTable.pivotColumns)\n                .transacting(trx);\n\n              if (hasOrderColumn(attribute)) {\n                query.merge([orderColumnName]);\n              } else {\n                query.ignore();\n              }\n\n              await query.execute();\n\n              // remove gap between orders\n              await cleanOrderColumns({ attribute, db, id, transaction: trx });\n            } else {\n              if (isAnyToOne(attribute)) {\n                cleanRelationData.set = cleanRelationData.set?.slice(-1);\n              }\n              // overwrite all relations\n              relIdsToaddOrMove = toIds(cleanRelationData.set);\n              await deleteRelations({\n                id,\n                attribute,\n                db,\n                relIdsToDelete: 'all',\n                relIdsToNotDelete: relIdsToaddOrMove,\n                transaction: trx,\n              });\n\n              if (isEmpty(cleanRelationData.set)) {\n                continue;\n              }\n\n              const insert = uniqBy('id', cleanRelationData.set).map((relToAdd) => ({\n                [joinColumn.name]: id,\n                [inverseJoinColumn.name]: relToAdd.id,\n                ...(joinTable.on || {}),\n                ...(relToAdd.__pivot || {}),\n              }));\n\n              // add order value\n              if (hasOrderColumn(attribute)) {\n                insert.forEach((row, idx) => {\n                  row[orderColumnName] = idx + 1;\n                });\n              }\n\n              // add inv order value\n              if (hasInverseOrderColumn(attribute)) {\n                const existingRels = await this.createQueryBuilder(joinTable.name)\n                  .select(inverseJoinColumn.name)\n                  .where({\n                    [joinColumn.name]: id,\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute<Array<Record<string, ID>>>();\n\n                const inverseRelsIds = map(inverseJoinColumn.name, existingRels);\n\n                const nonExistingRelsIds = difference(relIdsToaddOrMove, inverseRelsIds);\n\n                const maxResults = await db\n                  .getConnection()\n                  .select(inverseJoinColumn.name)\n                  .max(inverseOrderColumnName, { as: 'max' })\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\n                  .where(joinTable.on || {})\n                  .groupBy(inverseJoinColumn.name)\n                  .from(joinTable.name)\n                  .transacting(trx);\n\n                const maxMap = maxResults.reduce(\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n                  {}\n                );\n\n                insert.forEach((row: any) => {\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\n                });\n              }\n\n              // insert rows\n              const query = this.createQueryBuilder(joinTable.name)\n                .insert(insert)\n                .onConflict(joinTable.pivotColumns)\n                .transacting(trx);\n\n              if (hasOrderColumn(attribute)) {\n                query.merge([orderColumnName]);\n              } else {\n                query.ignore();\n              }\n\n              await query.execute();\n            }\n\n            // Delete the previous relations for oneToAny relations\n            if (isBidirectional(attribute) && isOneToAny(attribute)) {\n              await deletePreviousOneToAnyRelations({\n                id,\n                attribute,\n                relIdsToadd: relIdsToaddOrMove,\n                db,\n                transaction: trx,\n              });\n            }\n\n            // Delete the previous relations for anyToOne relations\n            if (isAnyToOne(attribute)) {\n              await deletePreviousAnyToOneRelations({\n                id,\n                attribute,\n                relIdToadd: relIdsToaddOrMove[0],\n                db,\n                transaction: trx,\n              });\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * Delete relational associations of an existing entity\n     * This removes associations but doesn't do cascade deletions for components for example. This will be handled on the entity service layer instead\n     * NOTE: Most of the deletion should be handled by ON DELETE CASCADE for dialects that have FKs\n     *\n     * @param {EntityManager} em - entity manager instance\n     * @param {Metadata} metadata - model metadta\n     * @param {ID} id - entity ID\n     */\n    async deleteRelations(uid, id, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        if (attribute.type !== 'relation') {\n          continue;\n        }\n\n        /*\n          if morphOne | morphMany\n            if morphBy is morphToOne\n              set null\n            if morphBy is morphToOne\n              delete links\n        */\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .transacting(trx)\n              .execute();\n          } else if (\n            targetAttribute.type === 'relation' &&\n            targetAttribute.relation === 'morphToMany'\n          ) {\n            const { joinTable } = targetAttribute;\n            const { morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                field: attributeName,\n              })\n              .transacting(trx)\n              .execute();\n          }\n\n          continue;\n        }\n\n        /*\n          if morphToOne\n            nothing to do\n        */\n        if (attribute.relation === 'morphToOne') {\n          // do nothing\n        }\n\n        /*\n            if morphToMany\n            delete links\n        */\n        if (attribute.relation === 'morphToMany') {\n          const { joinTable } = attribute;\n          const { joinColumn } = joinTable;\n\n          await this.createQueryBuilder(joinTable.name)\n            .delete()\n            .where({\n              [joinColumn.name]: id,\n              ...(joinTable.on || {}),\n            })\n            .transacting(trx)\n            .execute();\n\n          continue;\n        }\n\n        // do not need to delete links when using foreign keys\n        if (db.dialect.usesForeignKeys()) {\n          return;\n        }\n\n        // NOTE: we do not remove existing associations with the target as it should handled by unique FKs instead\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          // nothing to do => relation already added on the table\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side.\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n        }\n\n        if ('joinTable' in attribute && attribute.joinTable) {\n          await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\n        }\n      }\n    },\n\n    // TODO: Clone polymorphic relations\n    /**\n     *\n     * @param {string} uid - uid of the entity to clone\n     * @param {number} targetId - id of the entity to clone into\n     * @param {number} sourceId - id of the entity to clone from\n     * @param {object} opt\n     * @param {object} opt.cloneAttrs - key value pair of attributes to clone\n     * @param {object} opt.transaction - transaction to use\n     * @example cloneRelations('user', 3, 1, { cloneAttrs: [\"comments\"]})\n     * @example cloneRelations('post', 5, 2, { cloneAttrs: [\"comments\", \"likes\"] })\n     */\n    async cloneRelations(uid, targetId, sourceId, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { cloneAttrs = [], transaction } = options ?? {};\n\n      if (!attributes) {\n        return;\n      }\n\n      await mapAsync(cloneAttrs, async (attrName: string) => {\n        const attribute = attributes[attrName];\n\n        if (attribute.type !== 'relation') {\n          throw new DatabaseError(\n            `Attribute ${attrName} is not a relation attribute. Cloning relations is only supported for relation attributes.`\n          );\n        }\n\n        if (isPolymorphic(attribute)) {\n          // TODO: add support for cloning polymorphic relations\n          return;\n        }\n\n        if ('joinColumn' in attribute) {\n          // TODO: add support for cloning oneToMany relations on the owning side\n          return;\n        }\n\n        if (!attribute.joinTable) {\n          return;\n        }\n\n        let omitIds: ID[] = [];\n        if (has(attrName, data)) {\n          const cleanRelationData = toAssocs(data[attrName]);\n\n          // Don't clone if the relation attr is being set\n          if (cleanRelationData.set) {\n            return;\n          }\n\n          // Disconnected relations don't need to be cloned\n          if (cleanRelationData.disconnect) {\n            omitIds = toIds(cleanRelationData.disconnect);\n          }\n        }\n\n        if (isOneToAny(attribute) && isBidirectional(attribute)) {\n          await replaceRegularRelations({ targetId, sourceId, attribute, omitIds, transaction });\n        } else {\n          await cloneRegularRelations({ targetId, sourceId, attribute, transaction });\n        }\n      });\n\n      await this.updateRelations(uid, targetId, data, { transaction });\n    },\n\n    // TODO: add lifecycle events\n    async populate(uid, entity, populate) {\n      const entry = await this.findOne(uid, {\n        select: ['id'],\n        where: { id: entity.id },\n        populate,\n      });\n\n      return { ...entity, ...entry };\n    },\n\n    // TODO: add lifecycle events\n    async load(uid, entity, fields, populate) {\n      const { attributes } = db.metadata.get(uid);\n\n      const fieldsArr = castArray(fields);\n      fieldsArr.forEach((field) => {\n        const attribute = attributes[field];\n\n        if (!attribute || attribute.type !== 'relation') {\n          throw new Error(`Invalid load. Expected ${field} to be a relational attribute`);\n        }\n      });\n\n      const entry = await this.findOne(uid, {\n        select: ['id'],\n        where: { id: entity.id },\n        populate: fieldsArr.reduce((acc, field) => {\n          acc[field] = populate || true;\n          return acc;\n        }, {} as Record<string, unknown>),\n      });\n\n      if (!entry) {\n        return null;\n      }\n\n      if (Array.isArray(fields)) {\n        return pick(fields, entry);\n      }\n\n      return entry[fields];\n    },\n\n    // cascading\n    // aggregations\n    // -> avg\n    // -> min\n    // -> max\n    // -> grouping\n\n    // formulas\n    // custom queries\n\n    // utilities\n    // -> map result\n    // -> map input\n\n    // extra features\n    // -> virtuals\n    // -> private\n\n    createQueryBuilder(uid) {\n      return createQueryBuilder(uid, db);\n    },\n\n    getRepository(uid) {\n      if (!repoMap[uid]) {\n        repoMap[uid] = createRepository(uid, db);\n      }\n\n      return repoMap[uid];\n    },\n  };\n};\n","import type { Database } from '..';\n\nexport interface Options {\n  db: Database;\n  tableName?: string;\n}\n\nexport const createStorage = (opts: Options) => {\n  const { db, tableName = 'strapi_migrations' } = opts;\n\n  const hasMigrationTable = () => db.getSchemaConnection().hasTable(tableName);\n\n  const createMigrationTable = () => {\n    return db.getSchemaConnection().createTable(tableName, (table) => {\n      table.increments('id');\n      table.string('name');\n      table.datetime('time', { useTz: false });\n    });\n  };\n\n  return {\n    async logMigration({ name }: { name: string }) {\n      await db\n        .getConnection()\n        .insert({\n          name,\n          time: new Date(),\n        })\n        .into(tableName);\n    },\n\n    async unlogMigration({ name }: { name: string }) {\n      await db.getConnection(tableName).del().where({ name });\n    },\n\n    async executed() {\n      if (!(await hasMigrationTable())) {\n        await createMigrationTable();\n        return [];\n      }\n\n      const logs = await db.getConnection(tableName).select().from(tableName).orderBy('time');\n\n      return logs.map((log: { name: string }) => log.name);\n    },\n  };\n};\n","import path from 'node:path';\nimport fse from 'fs-extra';\nimport { Umzug } from 'umzug';\n\nimport type { Resolver } from 'umzug';\nimport type { Knex } from 'knex';\n\nimport { createStorage } from './storage';\n\nimport type { Database } from '..';\n\nexport interface MigrationProvider {\n  shouldRun(): Promise<boolean>;\n  up(): Promise<void>;\n  down(): Promise<void>;\n}\n\ntype MigrationResolver = Resolver<{ db: Database }>;\n\nconst wrapTransaction = (db: Database) => (fn: (knex: Knex) => unknown) => () => {\n  return db.connection.transaction((trx) => Promise.resolve(fn(trx)));\n};\n\n// TODO: check multiple commands in one sql statement\nconst migrationResolver: MigrationResolver = ({ name, path, context }) => {\n  const { db } = context;\n\n  if (!path) {\n    throw new Error(`Migration ${name} has no path`);\n  }\n\n  // if sql file run with knex raw\n  if (path.match(/\\.sql$/)) {\n    const sql = fse.readFileSync(path, 'utf8');\n\n    return {\n      name,\n      up: wrapTransaction(db)((knex) => knex.raw(sql)),\n      async down() {\n        throw new Error('Down migration is not supported for sql files');\n      },\n    };\n  }\n\n  // NOTE: we can add some ts register if we want to handle ts migration files at some point\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const migration = require(path);\n  return {\n    name,\n    up: wrapTransaction(db)(migration.up),\n    down: wrapTransaction(db)(migration.down),\n  };\n};\n\nconst createUmzugProvider = (db: Database) => {\n  const migrationDir = path.join(strapi.dirs.app.root, 'database/migrations');\n\n  fse.ensureDirSync(migrationDir);\n\n  return new Umzug({\n    storage: createStorage({ db, tableName: 'strapi_migrations' }),\n    logger: console,\n    context: { db },\n    migrations: {\n      glob: ['*.{js,sql}', { cwd: migrationDir }],\n      resolve: migrationResolver,\n    },\n  });\n};\n\n// NOTE: when needed => add internal migrations for core & plugins. How do we overlap them with users migrations ?\n\n/**\n * Creates migrations provider\n * @type {import('.').createMigrationsProvider}\n */\nexport const createMigrationsProvider = (db: Database): MigrationProvider => {\n  const migrations = createUmzugProvider(db);\n\n  return {\n    async shouldRun() {\n      const pending = await migrations.pending();\n\n      return pending.length > 0 && db.config?.settings?.runMigrations === true;\n    },\n    async up() {\n      await migrations.up();\n    },\n    async down() {\n      await migrations.down();\n    },\n  };\n};\n","import type { Subscriber } from '../types';\n\n/**\n * For each model try to run it's lifecycles function if any is defined\n */\nexport const modelsLifecyclesSubscriber: Subscriber = async (event) => {\n  const { model } = event;\n\n  if (model.lifecycles && event.action in model.lifecycles) {\n    await model.lifecycles[event.action]?.(event);\n  }\n};\n","import _ from 'lodash';\nimport type { Event, Subscriber } from '../types';\n\n// NOTE: we could add onCreate & onUpdate on field level to do this instead\nexport const timestampsLifecyclesSubscriber: Subscriber = {\n  /**\n   * Init createdAt & updatedAt before create\n   */\n  beforeCreate(event: Event) {\n    const { data } = event.params;\n\n    const now = new Date();\n    _.defaults(data, { createdAt: now, updatedAt: now });\n  },\n\n  /**\n   * Init createdAt & updatedAt before create\n   * @param {Event} event\n   */\n  beforeCreateMany(event) {\n    const { data } = event.params;\n\n    const now = new Date();\n    if (_.isArray(data)) {\n      data.forEach((data) => _.defaults(data, { createdAt: now, updatedAt: now }));\n    }\n  },\n\n  /**\n   * Update updatedAt before update\n   * @param {Event} event\n   */\n  beforeUpdate(event) {\n    const { data } = event.params;\n\n    const now = new Date();\n    _.assign(data, { updatedAt: now });\n  },\n\n  /**\n   * Update updatedAt before update\n   * @param {Event} event\n   */\n  beforeUpdateMany(event) {\n    const { data } = event.params;\n\n    const now = new Date();\n    if (_.isArray(data)) {\n      data.forEach((data) => _.assign(data, { updatedAt: now }));\n    }\n  },\n};\n","import type { Subscriber } from '../types';\n\nexport const isValidSubscriber = (subscriber: Subscriber) => {\n  return (\n    typeof subscriber === 'function' || (typeof subscriber === 'object' && subscriber !== null)\n  );\n};\n\nexport { modelsLifecyclesSubscriber } from './models-lifecycles';\nexport { timestampsLifecyclesSubscriber } from './timestamps';\n","import { strict as assert } from 'assert';\n\nimport * as subscriberUtils from './subscribers';\n\nimport type { Action, Event, Params, Subscriber } from './types';\nimport type { Database } from '..';\n\nexport type * from './types';\n\nexport type State = Record<string, unknown>;\nexport type States = Map<Subscriber, State>;\n\nexport interface Properties {\n  params: Params;\n  result?: unknown;\n}\n\nexport interface LifecycleProvider {\n  subscribe(subscriber: Subscriber): () => void;\n  clear(): void;\n  run(action: Action, uid: string, properties: Properties, states?: States): Promise<States>;\n  createEvent(action: Action, uid: string, properties: Properties, state: State): Event;\n}\n\nexport const createLifecyclesProvider = (db: Database): LifecycleProvider => {\n  let subscribers = [\n    subscriberUtils.timestampsLifecyclesSubscriber,\n    subscriberUtils.modelsLifecyclesSubscriber,\n  ];\n\n  return {\n    subscribe(subscriber) {\n      assert(\n        subscriberUtils.isValidSubscriber(subscriber),\n        'Invalid subscriber. Expected function or object'\n      );\n\n      subscribers.push(subscriber);\n\n      return () => subscribers.splice(subscribers.indexOf(subscriber), 1);\n    },\n\n    clear() {\n      subscribers = [];\n    },\n\n    createEvent(action, uid, properties, state): Event {\n      const model = db.metadata.get(uid);\n\n      return {\n        action,\n        model,\n        state,\n        ...properties,\n      };\n    },\n\n    /**\n     * @param {string} action\n     * @param {string} uid\n     * @param {{ params?: any, result?: any }} properties\n     * @param {Map<any, any>} states\n     */\n    async run(action, uid, properties, states = new Map()) {\n      for (let i = 0; i < subscribers.length; i += 1) {\n        const subscriber = subscribers[i];\n        if (typeof subscriber === 'function') {\n          const state = states.get(subscriber) || {};\n          const event = this.createEvent(action, uid, properties, state);\n          await subscriber(event);\n          if (event.state) {\n            states.set(subscriber, event.state || state);\n          }\n          continue;\n        }\n\n        const hasAction = action in subscriber;\n        const hasModel = !subscriber.models || subscriber.models.includes(uid);\n\n        if (hasAction && hasModel) {\n          const state = states.get(subscriber) || {};\n          const event = this.createEvent(action, uid, properties, state);\n\n          await subscriber[action]?.(event);\n          if (event.state) {\n            states.set(subscriber, event.state);\n          }\n        }\n      }\n\n      return states;\n    },\n  };\n};\n","import knex from 'knex';\nimport type { Knex } from 'knex';\nimport SqliteClient from 'knex/lib/dialects/sqlite3/index';\n\nclass LegacySqliteClient extends SqliteClient {\n  _driver() {\n    /* eslint-disable-next-line import/no-extraneous-dependencies */\n    return require('sqlite3');\n  }\n}\n\nconst clientMap = {\n  'better-sqlite3': 'better-sqlite3',\n  '@vscode/sqlite3': 'sqlite',\n  sqlite3: LegacySqliteClient,\n} as const;\n\ntype ClientKey = keyof typeof clientMap;\n\nconst trySqlitePackage = (packageName: ClientKey): ClientKey | false => {\n  try {\n    require.resolve(packageName);\n    return packageName;\n  } catch (error) {\n    if (error instanceof Error && 'code' in error && error.code === 'MODULE_NOT_FOUND') {\n      return false;\n    }\n    throw error;\n  }\n};\n\nconst getSqlitePackageName = (): ClientKey => {\n  // NOTE: allow forcing the package to use (mostly used for testing purposes)\n  if (typeof process.env.SQLITE_PKG !== 'undefined') {\n    return process.env.SQLITE_PKG as ClientKey;\n  }\n\n  // NOTE: this tries to find the best sqlite module possible to use\n  // while keeping retro compatibility\n  const matchingPackage: ClientKey | false =\n    trySqlitePackage('better-sqlite3') ||\n    trySqlitePackage('@vscode/sqlite3') ||\n    trySqlitePackage('sqlite3');\n\n  if (!matchingPackage) {\n    throw new Error('No sqlite package found');\n  }\n\n  return matchingPackage;\n};\n\nexport const createConnection = (config: Knex.Config) => {\n  const knexConfig = { ...config };\n  if (knexConfig.client === 'sqlite') {\n    const sqlitePackageName = getSqlitePackageName();\n\n    knexConfig.client = clientMap[sqlitePackageName] as Knex.Config['client'];\n  }\n\n  return knex(knexConfig);\n};\n","import type { Model } from '../types';\n\nexport interface Attribute {\n  type: string;\n  multiple?: boolean;\n}\n\nexport interface ContentType {\n  uid: string;\n  modelName: string;\n  collectionName: string;\n  attributes: Record<string, Attribute>;\n}\n\nconst transformAttribute = (attribute: Attribute) => {\n  switch (attribute.type) {\n    case 'media': {\n      return {\n        type: 'relation',\n        relation: attribute.multiple === true ? 'morphMany' : 'morphOne',\n        target: 'plugin::upload.file',\n        morphBy: 'related',\n      };\n    }\n    default: {\n      return attribute;\n    }\n  }\n};\n\n// TODO: model logic outside DB\nexport const transformContentTypes = (contentTypes: ContentType[]): Model[] => {\n  return contentTypes.map((contentType) => {\n    const model = {\n      ...contentType,\n      // reuse new model def\n      singularName: contentType.modelName,\n      tableName: contentType.collectionName,\n      attributes: {\n        ...Object.keys(contentType.attributes || {}).reduce((attrs, attrName) => {\n          return Object.assign(attrs, {\n            [attrName]: transformAttribute(contentType.attributes[attrName]),\n          });\n        }, {}),\n      },\n    };\n\n    return model;\n  });\n};\n","import { getJoinTableName } from '../../metadata';\n\nimport type { Database } from '../..';\nimport type { Relation } from '../../types';\n\ntype Link = {\n  relation: Relation.Bidirectional & { inversedBy: string };\n  invRelation: Relation.Bidirectional & { inversedBy: string };\n};\n\nconst getLinksWithoutMappedBy = (db: Database): Array<Link> => {\n  const relationsToUpdate: Record<string, Link> = {};\n\n  db.metadata.forEach((contentType) => {\n    const attributes = contentType.attributes;\n\n    // For each relation attribute, add the joinTable name to tablesToUpdate\n    Object.values(attributes).forEach((attribute) => {\n      if (attribute.type !== 'relation') {\n        return;\n      }\n\n      if ('inversedBy' in attribute && attribute.inversedBy) {\n        const invRelation = db.metadata.get(attribute.target).attributes[attribute.inversedBy];\n\n        // Both relations use inversedBy.\n        if ('inversedBy' in invRelation && invRelation.inversedBy) {\n          relationsToUpdate[attribute.joinTable.name] = {\n            relation: attribute as Relation.Bidirectional & { inversedBy: string },\n            invRelation: invRelation as Relation.Bidirectional & { inversedBy: string },\n          };\n        }\n      }\n    });\n  });\n\n  return Object.values(relationsToUpdate);\n};\n\nconst isLinkTableEmpty = async (db: Database, linkTableName: string) => {\n  // If the table doesn't exist, it's empty\n  const exists = await db.getSchemaConnection().hasTable(linkTableName);\n  if (!exists) return true;\n\n  const result = await db.getConnection().from(linkTableName).count('* as count');\n  return Number(result[0].count) === 0;\n};\n\n/**\n * Validates bidirectional relations before starting the server.\n * - If both sides use inversedBy, one of the sides must switch to mappedBy.\n *    When this happens, two join tables exist in the database.\n *    This makes sure you switch the side which does not delete any data.\n *\n * @param {*} db\n * @return {*}\n */\nexport const validateBidirectionalRelations = async (db: Database) => {\n  const invalidLinks = getLinksWithoutMappedBy(db);\n\n  for (const { relation, invRelation } of invalidLinks) {\n    const contentType = db.metadata.get(invRelation.target);\n    const invContentType = db.metadata.get(relation.target);\n\n    // Generate the join table name based on the relation target table and attribute name.\n    const joinTableName = getJoinTableName(contentType.tableName, invRelation.inversedBy);\n    const inverseJoinTableName = getJoinTableName(invContentType.tableName, relation.inversedBy);\n\n    const joinTableEmpty = await isLinkTableEmpty(db, joinTableName);\n    const inverseJoinTableEmpty = await isLinkTableEmpty(db, inverseJoinTableName);\n\n    if (joinTableEmpty) {\n      process.emitWarning(\n        `Error on attribute \"${invRelation.inversedBy}\" in model \"${contentType.singularName}\" (${contentType.uid}).` +\n          ` Please modify your ${contentType.singularName} schema by renaming the key \"inversedBy\" to \"mappedBy\".` +\n          ` Ex: { \"inversedBy\": \"${relation.inversedBy}\" } -> { \"mappedBy\": \"${relation.inversedBy}\" }`\n      );\n    } else if (inverseJoinTableEmpty) {\n      // Its safe to delete the inverse join table\n      process.emitWarning(\n        `Error on attribute \"${relation.inversedBy}\" in model \"${invContentType.singularName}\" (${invContentType.uid}).` +\n          ` Please modify your ${invContentType.singularName} schema by renaming the key \"inversedBy\" to \"mappedBy\".` +\n          ` Ex: { \"inversedBy\": \"${invRelation.inversedBy}\" } -> { \"mappedBy\": \"${invRelation.inversedBy}\" }`\n      );\n    } else {\n      // Both sides have data in the join table\n    }\n  }\n};\n","import { validateBidirectionalRelations } from './bidirectional';\n\nimport type { Database } from '../..';\n\n/**\n * Validates if relations data and tables are in a valid state before\n * starting the server.\n */\nexport const validateRelations = async (db: Database) => {\n  await validateBidirectionalRelations(db);\n};\n","import { validateRelations } from './relations';\n\nimport type { Database } from '..';\n\n/**\n * Validate if the database is in a valid state before starting the server.\n */\nexport async function validateDatabase(db: Database) {\n  await validateRelations(db);\n}\n","import type { Knex } from 'knex';\n\nimport { Dialect, getDialect } from './dialects';\nimport { createSchemaProvider, SchemaProvider } from './schema';\nimport { createMetadata, Metadata } from './metadata';\nimport { createEntityManager, EntityManager } from './entity-manager';\nimport { createMigrationsProvider, MigrationProvider } from './migrations';\nimport { createLifecyclesProvider, LifecycleProvider } from './lifecycles';\nimport { createConnection } from './connection';\nimport * as errors from './errors';\nimport { Callback, transactionCtx, TransactionObject } from './transaction-context';\n\n// TODO: move back into strapi\nimport { transformContentTypes } from './utils/content-types';\nimport { validateDatabase } from './validations';\nimport { Model } from './types';\n\nexport { isKnexQuery } from './utils/knex';\n\ninterface Settings {\n  forceMigration?: boolean;\n  runMigrations?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface DatabaseConfig {\n  connection: Knex.Config;\n  settings: Settings;\n  models: Model[];\n}\n\nclass Database {\n  connection: Knex;\n\n  dialect: Dialect;\n\n  config: DatabaseConfig;\n\n  metadata: Metadata;\n\n  schema: SchemaProvider;\n\n  migrations: MigrationProvider;\n\n  lifecycles: LifecycleProvider;\n\n  entityManager: EntityManager;\n\n  static transformContentTypes = transformContentTypes;\n\n  static async init(config: DatabaseConfig) {\n    const db = new Database(config);\n    await validateDatabase(db);\n    return db;\n  }\n\n  constructor(config: DatabaseConfig) {\n    this.metadata = createMetadata(config.models);\n\n    this.config = {\n      ...config,\n      settings: {\n        forceMigration: true,\n        runMigrations: true,\n        ...(config.settings ?? {}),\n      },\n    };\n\n    this.dialect = getDialect(this);\n    this.dialect.configure();\n\n    this.connection = createConnection(this.config.connection);\n\n    this.dialect.initialize();\n\n    this.schema = createSchemaProvider(this);\n\n    this.migrations = createMigrationsProvider(this);\n    this.lifecycles = createLifecyclesProvider(this);\n\n    this.entityManager = createEntityManager(this);\n  }\n\n  query(uid: string) {\n    if (!this.metadata.has(uid)) {\n      throw new Error(`Model ${uid} not found`);\n    }\n\n    return this.entityManager.getRepository(uid);\n  }\n\n  inTransaction() {\n    return !!transactionCtx.get();\n  }\n\n  transaction(): Promise<TransactionObject>;\n  transaction<TCallback extends Callback>(c: TCallback): Promise<ReturnType<TCallback>>;\n  async transaction<TCallback extends Callback>(\n    cb?: TCallback\n  ): Promise<ReturnType<TCallback> | TransactionObject> {\n    const notNestedTransaction = !transactionCtx.get();\n    const trx = notNestedTransaction\n      ? await this.connection.transaction()\n      : (transactionCtx.get() as Knex.Transaction);\n\n    async function commit() {\n      if (notNestedTransaction) {\n        await transactionCtx.commit(trx);\n      }\n    }\n\n    async function rollback() {\n      if (notNestedTransaction) {\n        await transactionCtx.rollback(trx);\n      }\n    }\n\n    if (!cb) {\n      return { commit, rollback, get: () => trx };\n    }\n\n    return transactionCtx.run(trx, async () => {\n      try {\n        const callbackParams = {\n          trx,\n          commit,\n          rollback,\n          onCommit: transactionCtx.onCommit,\n          onRollback: transactionCtx.onRollback,\n        };\n        const res = await cb(callbackParams);\n        await commit();\n        return res;\n      } catch (error) {\n        await rollback();\n        throw error;\n      }\n    });\n  }\n\n  getSchemaName(): string | undefined {\n    return this.connection.client.connectionSettings.schema;\n  }\n\n  getConnection(): Knex;\n  getConnection(tableName?: string): Knex.QueryBuilder;\n  getConnection(tableName?: string): Knex | Knex.QueryBuilder {\n    const schema = this.getSchemaName();\n    const connection = tableName ? this.connection(tableName) : this.connection;\n    return schema ? connection.withSchema(schema) : connection;\n  }\n\n  getSchemaConnection(trx = this.connection) {\n    const schema = this.getSchemaName();\n    return schema ? trx.schema.withSchema(schema) : trx.schema;\n  }\n\n  queryBuilder(uid: string) {\n    return this.entityManager.createQueryBuilder(uid);\n  }\n\n  async destroy() {\n    await this.lifecycles.clear();\n    await this.connection.destroy();\n  }\n}\n\nexport { Database, errors };\n"],"names":["SQL_QUERIES","toStrapiType","index","errors.NotNullError","PostgresClass","MysqlClass","SqliteClass","debug","helpers","createColumn","createTable","table","srcTable","types.isScalarAttribute","metadata","types.isComponent","types.isDynamicZone","types.isRelationalAttribute","isString","types.isScalar","types.isRelation","knex","types.isString","types.isNumber","map","qb","rows","isRecord","keys","helpers.toColumnName","groupBy","helpers.createJoin","helpers.processOrderBy","helpers.processWhere","helpers.processPopulate","helpers.toRow","helpers.applyWhere","helpers.applySearch","helpers.applyJoins","helpers.applyPopulate","helpers.fromRow","helpers.ReadableQuery","strict","_","isNumber","entity","data","path","subscriberUtils.timestampsLifecyclesSubscriber","subscriberUtils.modelsLifecyclesSubscriber","assert","subscriberUtils.isValidSubscriber"],"mappings":"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"}